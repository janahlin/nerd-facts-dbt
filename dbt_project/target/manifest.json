{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/manifest/v12.json", "dbt_version": "1.9.3", "generated_at": "2025-03-17T09:56:57.868496Z", "invocation_id": "f6bf1b47-d554-4a69-a28f-32f4a758609e", "env": {}, "project_name": "nerd_facts_dbt", "project_id": "7d95999fae80835141c5f59ccf21274b", "user_id": "a33a0cc6-618e-48cb-87c4-b72647cdd80b", "send_anonymous_usage_stats": true, "adapter_type": "postgres"}, "nodes": {"model.nerd_facts_dbt.dim_pokemon_moves": {"database": "nerd_facts", "schema": "public", "name": "dim_pokemon_moves", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/dim_pokemon_moves.sql", "original_file_path": "models/marts/pokemon/dim_pokemon_moves.sql", "unique_id": "model.nerd_facts_dbt.dim_pokemon_moves", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "dim_pokemon_moves"], "alias": "dim_pokemon_moves", "checksum": {"name": "sha256", "checksum": "eb52ce7d919bf15d0ed6b75651577220d0e8a0c4edde574a7cbc0e6e6fab93ec"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "move_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["move_id"]}, {"columns": ["name"]}, {"columns": ["type"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["move_id"]}, {"columns": ["name"]}, {"columns": ["type"]}], "unique_key": "move_key"}, "created_at": 1742203914.2271771, "relation_name": "\"nerd_facts\".\"public\".\"dim_pokemon_moves\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['move_id']}, {'columns': ['name']}, {'columns': ['type']}],\n    unique_key = 'move_key'\n  )\n}}\n\n/*\n  Model: dim_pokemon_moves\n  Description: Dimension table for Pok\u00e9mon moves with comprehensive attributes\n  \n  Notes:\n  - Provides detailed information about all moves in the Pok\u00e9mon games\n  - Contains move statistics like power, accuracy, and PP\n  - Classifies moves by type, category, and effect\n  - Includes generation information and competitive relevance\n  - Serves as a reference dimension for move-related analyses\n*/\n\nWITH base_moves AS (\n    SELECT\n        id AS move_id,\n        name,\n        NULLIF(type, 'unknown') AS type,\n        NULLIF(power::TEXT, 'null')::INTEGER AS power,\n        NULLIF(pp::TEXT, 'null')::INTEGER AS pp,\n        NULLIF(accuracy::TEXT, 'null')::INTEGER AS accuracy,\n        priority,\n        damage_class,\n        effect_text,\n        effect_chance,\n        generation_id\n    FROM {{ ref('stg_pokeapi_moves') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['move_id']) }} AS move_key,\n    \n    -- Core identifiers\n    move_id,\n    name,\n    \n    -- Move attributes\n    type,\n    COALESCE(power, 0) AS power,\n    COALESCE(pp, 0) AS pp,\n    COALESCE(accuracy, 0) AS accuracy,\n    COALESCE(priority, 0) AS priority,\n    COALESCE(damage_class, 'physical') AS damage_class,\n    \n    -- Effect information\n    effect_text,\n    COALESCE(effect_chance, 0) AS effect_chance,\n    \n    -- Generation information\n    COALESCE(generation_id, 1) AS generation_id,\n    \n    -- Move category classification\n    CASE\n        WHEN damage_class = 'status' THEN 'Status'\n        WHEN power IS NULL OR power = 0 THEN 'Status'\n        WHEN power < 40 THEN 'Weak'\n        WHEN power < 70 THEN 'Medium'\n        WHEN power < 90 THEN 'Strong'\n        WHEN power < 110 THEN 'Very Strong'\n        ELSE 'Extreme'\n    END AS power_category,\n    \n    -- Accuracy classification\n    CASE\n        WHEN accuracy IS NULL THEN 'Always Hits'\n        WHEN accuracy < 50 THEN 'Very Inaccurate'\n        WHEN accuracy < 70 THEN 'Inaccurate'\n        WHEN accuracy < 85 THEN 'Moderate'\n        WHEN accuracy < 95 THEN 'Accurate'\n        WHEN accuracy < 100 THEN 'Very Accurate'\n        WHEN accuracy = 100 THEN 'Perfect'\n        ELSE 'Unknown'\n    END AS accuracy_category,\n    \n    -- Move effect category based on effect text\n    CASE\n        WHEN effect_text LIKE '%boost%' OR \n             effect_text LIKE '%raise%' OR \n             effect_text LIKE '%increase%' THEN 'Stat Boost'\n        WHEN effect_text LIKE '%lower%' OR \n             effect_text LIKE '%decrease%' OR \n             effect_text LIKE '%reduce%' THEN 'Stat Reduction'\n        WHEN effect_text LIKE '%paralyze%' THEN 'Paralyze'\n        WHEN effect_text LIKE '%burn%' THEN 'Burn'\n        WHEN effect_text LIKE '%poison%' OR \n             effect_text LIKE '%toxic%' THEN 'Poison'\n        WHEN effect_text LIKE '%sleep%' THEN 'Sleep'\n        WHEN effect_text LIKE '%freeze%' THEN 'Freeze'\n        WHEN effect_text LIKE '%confus%' THEN 'Confusion'\n        WHEN effect_text LIKE '%flinch%' THEN 'Flinch'\n        WHEN effect_text LIKE '%trap%' THEN 'Trap'\n        WHEN effect_text LIKE '%heal%' OR \n             effect_text LIKE '%restore%' THEN 'Healing'\n        WHEN effect_text LIKE '%protect%' OR \n             effect_text LIKE '%protect%' THEN 'Protection'\n        WHEN effect_text LIKE '%critical%' THEN 'Critical Hit'\n        WHEN effect_text LIKE '%priority%' OR priority > 0 THEN 'Priority'\n        WHEN damage_class = 'status' THEN 'Status Effect'\n        WHEN power > 0 THEN 'Direct Damage'\n        ELSE 'Other'\n    END AS effect_category,\n    \n    -- Competitive relevance score (1-10)\n    CASE\n        -- Extremely useful moves in competitive\n        WHEN name IN ('Stealth Rock', 'Spikes', 'Toxic Spikes', 'Defog', 'Rapid Spin',\n                   'Recover', 'Wish', 'Protect', 'Substitute', 'Will-O-Wisp',\n                   'Scald', 'Knock Off', 'U-turn', 'Volt Switch', 'Toxic',\n                   'Thunder Wave', 'Dragon Dance', 'Swords Dance', 'Nasty Plot',\n                   'Calm Mind', 'Quiver Dance', 'Roost', 'Leech Seed') THEN 10\n                   \n        -- Very strong attacks and utility moves\n        WHEN (power > 100 AND accuracy >= 90) OR \n             name IN ('Close Combat', 'Earthquake', 'Ice Beam', 'Thunderbolt',\n                   'Flamethrower', 'Surf', 'Stone Edge', 'Focus Blast',\n                   'Shadow Ball', 'Psyshock', 'Earth Power', 'Draco Meteor', \n                   'Moonblast', 'Play Rough', 'Gunk Shot', 'Brave Bird') THEN 9\n                   \n        -- Strong utility and common attacks\n        WHEN (power >= 80 AND accuracy >= 85) OR\n             name IN ('Taunt', 'Encore', 'Trick', 'Toxic', 'Synthesis', \n                   'Aromatherapy', 'Heal Bell', 'Sticky Web', 'Trick Room',\n                   'Tailwind', 'Moonlight', 'Morning Sun') THEN 8\n                   \n        -- Useful moves but not top tier\n        WHEN (power >= 70 AND accuracy >= 80) OR\n             name IN ('Light Screen', 'Reflect', 'Hypnosis', 'Sleep Powder',\n                   'Stun Spore', 'Thunder Wave') THEN 7\n                   \n        -- Standard damage moves with decent stats\n        WHEN power >= 60 AND accuracy >= 90 THEN 6\n        \n        -- Status moves without specific utility\n        WHEN damage_class = 'status' THEN 5\n        \n        -- Weak but accurate moves\n        WHEN power < 60 AND accuracy > 90 THEN 4\n        \n        -- Inaccurate moves\n        WHEN accuracy < 80 AND power > 0 THEN 3\n        \n        -- Very weak moves\n        WHEN power < 40 THEN 2\n        \n        -- Other moves\n        ELSE 1\n    END AS competitive_score,\n    \n    -- Move uniqueness rating\n    CASE\n        -- Signature moves\n        WHEN name IN ('Spacial Rend', 'Roar of Time', 'Seed Flare', 'Blue Flare', 'Bolt Strike',\n                   'Fusion Flare', 'Fusion Bolt', 'Origin Pulse', 'Precipice Blades',\n                   'Dragon Ascent', 'Sacred Fire', 'Aeroblast', 'Shadow Force',\n                   'Doom Desire', 'Psycho Boost', 'Lunar Dance', 'Magma Storm',\n                   'Crush Grip', 'Judgment', 'Secret Sword', 'Relic Song', 'Light of Ruin',\n                   'Steam Eruption', 'Core Enforcer', 'Sunsteel Strike', 'Moongeist Beam',\n                   'Photon Geyser', 'Spectral Thief', 'Plasma Fists') THEN 'Signature'\n                   \n        -- Very rare moves (limited distribution)\n        WHEN name IN ('Shell Smash', 'Quiver Dance', 'Tail Glow', 'Dragon Dance',\n                   'Shift Gear', 'Coil', 'Geomancy', 'Mind Blown', 'Oblivion Wing',\n                   'Thousand Arrows', 'Thousand Waves', 'Diamond Storm') THEN 'Very Rare'\n                   \n        -- Rare but distributed moves\n        WHEN name IN ('Spore', 'Dark Void', 'Healing Wish', 'Lunar Dance', \n                   'Shore Up', 'Belly Drum', 'Fiery Dance', 'King\\'s Shield',\n                   'Spiky Shield', 'Baneful Bunker', 'Parting Shot') THEN 'Rare'\n                   \n        -- Uncommon moves\n        WHEN name IN ('Leech Seed', 'Aromatherapy', 'Heal Bell', 'Sticky Web',\n                   'Defog', 'Rapid Spin', 'Extreme Speed', 'Sucker Punch',\n                   'Bullet Punch', 'Aqua Jet', 'Mach Punch', 'Ice Shard') THEN 'Uncommon'\n                   \n        -- Common coverage moves\n        WHEN name IN ('Ice Beam', 'Thunderbolt', 'Flamethrower', 'Surf',\n                   'Earthquake', 'Stone Edge', 'Close Combat', 'Shadow Ball') THEN 'Standard'\n                   \n        -- Very common moves\n        WHEN name IN ('Toxic', 'Protect', 'Rest', 'Sleep Talk', 'Substitute') THEN 'Common'\n                   \n        -- Handle everything else based on damage class\n        WHEN damage_class = 'status' THEN 'Status'\n        ELSE 'Standard'\n    END AS move_rarity,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM base_moves\nORDER BY type, power DESC NULLS LAST, name", "language": "sql", "refs": [{"name": "stg_pokeapi_moves", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_pokeapi_abilities": {"database": "nerd_facts", "schema": "public", "name": "stg_pokeapi_abilities", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/pokeapi/stg_pokeapi_abilities.sql", "original_file_path": "models/staging/pokeapi/stg_pokeapi_abilities.sql", "unique_id": "model.nerd_facts_dbt.stg_pokeapi_abilities", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "stg_pokeapi_abilities"], "alias": "stg_pokeapi_abilities", "checksum": {"name": "sha256", "checksum": "9c47a60279656b8b0c45404f1f8a0a3b6b10a3d1fe3efb9967b03a88c84fdc13"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.2422147, "relation_name": "\"nerd_facts\".\"public\".\"stg_pokeapi_abilities\"", "raw_code": "/*\n  Model: stg_pokeapi_abilities\n  Description: Standardizes Pok\u00e9mon ability data from the PokeAPI\n  Source: raw.pokeapi_abilities\n  \n  Notes:\n  - Effect entries are extracted with language preference for English entries\n  - Generation data is parsed from the nested JSON structure\n  - NULL handling is added for all JSON extraction\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        generation,\n        effect_entries,\n        pokemon,\n        is_main_series\n    FROM raw.pokeapi_abilities\n    WHERE id IS NOT NULL\n),\n\n-- Extract English effect entries when available\neffect_entries_parsed AS (\n    SELECT\n        id,\n        (\n            -- First try to find an English entry\n            SELECT effect_entry->>'effect' \n            FROM jsonb_array_elements(effect_entries) AS effect_entry\n            WHERE effect_entry->>'language'->>'name' = 'en'\n            LIMIT 1\n        ) AS effect_en,\n        (\n            -- First try to find an English short entry\n            SELECT effect_entry->>'short_effect' \n            FROM jsonb_array_elements(effect_entries) AS effect_entry\n            WHERE effect_entry->>'language'->>'name' = 'en'\n            LIMIT 1\n        ) AS short_effect_en,\n        -- Fallback to first entry if no English entry exists\n        COALESCE(effect_entries->0->>'effect', '') AS effect_fallback,\n        COALESCE(effect_entries->0->>'short_effect', '') AS short_effect_fallback\n    FROM raw_data\n)\n\nSELECT\n    -- Primary identifiers\n    r.id,\n    r.name AS ability_name,\n    \n    -- Generation information\n    COALESCE(r.generation->>'name', 'unknown') AS generation_name,\n    CASE\n        WHEN r.generation->>'name' ~ 'generation-([i|v]+)'\n        THEN REGEXP_REPLACE(r.generation->>'name', 'generation-([i|v]+)', '\\1')\n        ELSE NULL\n    END AS generation_number,\n    \n    -- Effect descriptions\n    COALESCE(e.effect_en, e.effect_fallback) AS effect_description,\n    COALESCE(e.short_effect_en, e.short_effect_fallback) AS short_description,\n    \n    -- Pok\u00e9mon count with this ability\n    COALESCE(jsonb_array_length(r.pokemon), 0) AS pokemon_count,\n    \n    -- Canonical status\n    COALESCE(r.is_main_series, TRUE) AS is_main_series,\n    \n    -- Common words in effect description for classification\n    CASE\n        WHEN LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%boost%' OR \n             LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%increase%' THEN TRUE\n        ELSE FALSE\n    END AS is_stat_boosting,\n    \n    CASE\n        WHEN LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%weather%' THEN TRUE\n        ELSE FALSE\n    END AS is_weather_related,\n    \n    CASE\n        WHEN LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%status%' OR \n             LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%poison%' OR\n             LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%burn%' OR\n             LOWER(COALESCE(e.effect_en, e.effect_fallback)) LIKE '%paralyze%' THEN TRUE\n        ELSE FALSE\n    END AS affects_status_conditions,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data r\nJOIN effect_entries_parsed e ON r.id = e.id", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_netrunner_packs": {"database": "nerd_facts", "schema": "public", "name": "stg_netrunner_packs", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/netrunner/stg_netrunner_packs.sql", "original_file_path": "models/staging/netrunner/stg_netrunner_packs.sql", "unique_id": "model.nerd_facts_dbt.stg_netrunner_packs", "fqn": ["nerd_facts_dbt", "staging", "netrunner", "stg_netrunner_packs"], "alias": "stg_netrunner_packs", "checksum": {"name": "sha256", "checksum": "dee3d9f63f2e08ab4a5c4f47c9e513e61fa5657e22169f9a03d4d30204f988ee"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.244057, "relation_name": "\"nerd_facts\".\"public\".\"stg_netrunner_packs\"", "raw_code": "/*\n  Model: stg_netrunner_packs\n  Description: Standardizes Netrunner card pack data from the raw source\n  Source: raw.netrunner_packs\n  \n  Packs represent the physical card sets released for Netrunner, such as core sets,\n  deluxe expansions, and data packs within a cycle.\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        code,\n        name,\n        position,\n        date_release,\n        size,\n        cycle_code\n    FROM raw.netrunner_packs\n    WHERE code IS NOT NULL -- Filter out invalid entries\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    code,\n    name AS pack_name,\n    \n    -- Release information\n    CASE\n        WHEN date_release = '' THEN NULL\n        ELSE TO_DATE(date_release, 'YYYY-MM-DD')\n    END AS release_date,\n    \n    -- Pack attributes\n    position AS pack_position,\n    NULLIF(size, 0)::INTEGER AS card_count,\n    cycle_code,\n    \n    -- Derived fields\n    CASE\n        WHEN name ILIKE '%core%' THEN 'Core'\n        WHEN name ILIKE '%deluxe%' THEN 'Deluxe'\n        WHEN name ILIKE '%draft%' THEN 'Draft'\n        ELSE 'Data Pack'\n    END AS pack_type,\n    \n    -- Calculate approximate rotation status\n    CASE\n        WHEN cycle_code IN ('core', 'genesis', 'creation-and-control', 'spin', 'honor-and-profit', 'lunar') \n        THEN 'Rotated'\n        WHEN cycle_code IS NULL THEN 'Unknown'\n        ELSE 'Legal'\n    END AS rotation_status,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.bridge_pokemon_abilities": {"database": "nerd_facts", "schema": "public", "name": "bridge_pokemon_abilities", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/bridge_pokemon_abilities.sql", "original_file_path": "models/marts/pokemon/bridge_pokemon_abilities.sql", "unique_id": "model.nerd_facts_dbt.bridge_pokemon_abilities", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "bridge_pokemon_abilities"], "alias": "bridge_pokemon_abilities", "checksum": {"name": "sha256", "checksum": "c05c409aa293dfd6aea94bde7e1c772e07ef45acd6a016b8ce335903c9c3697a"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "pokemon_ability_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["ability_id"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["ability_id"]}], "unique_key": "pokemon_ability_id"}, "created_at": 1742203914.2527835, "relation_name": "\"nerd_facts\".\"public\".\"bridge_pokemon_abilities\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['pokemon_id']}, {'columns': ['ability_id']}],\n    unique_key = 'pokemon_ability_id'\n  )\n}}\n\n/*\n  Model: bridge_pokemon_abilities\n  Description: Bridge table connecting Pok\u00e9mon to their abilities\n  \n  Notes:\n  - Handles the many-to-many relationship between Pok\u00e9mon and abilities\n  - Extracts ability data from nested JSON in the pok\u00e9mon staging model\n  - Calculates synergy scores between Pok\u00e9mon and their abilities\n  - Provides context on whether abilities are hidden or standard\n  - Links to both Pok\u00e9mon and ability dimension tables with proper keys\n*/\n\nWITH pokemon_abilities AS (\n    -- Extract ability references from the pokemon data with improved error handling\n    SELECT\n        p.id AS pokemon_id,\n        p.name AS pokemon_name,\n        p.primary_type,\n        p.secondary_type,\n        p.generation_number,\n        p.is_legendary,\n        p.is_mythical,\n        p.total_base_stats,\n        COALESCE(ability_ref->>'name', 'Unknown') AS ability_name,\n        COALESCE((ability_ref->>'is_hidden')::boolean, FALSE) AS is_hidden,\n        COALESCE((ability_ref->>'slot')::integer, 1) AS slot_number\n    FROM {{ ref('stg_pokeapi_pokemon') }} p,\n    LATERAL jsonb_array_elements(\n        CASE WHEN p.abilities IS NULL OR p.abilities = 'null' THEN '[]'::jsonb\n        ELSE p.abilities END\n    ) AS ability_ref\n    WHERE p.id IS NOT NULL\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['pa.pokemon_id', 'pa.ability_name']) }} AS pokemon_ability_id,\n    \n    -- Foreign keys with proper surrogate keys\n    {{ dbt_utils.generate_surrogate_key(['pa.pokemon_id']) }} AS pokemon_key,\n    {{ dbt_utils.generate_surrogate_key(['a.ability_id']) }} AS ability_key,\n    \n    -- Base identifiers\n    pa.pokemon_id,\n    pa.pokemon_name,\n    pa.ability_name,\n    pa.is_hidden,\n    pa.slot_number,\n    \n    -- Reference data from ability dimension\n    a.ability_id,\n    COALESCE(a.effect_type, 'Unknown') AS effect_type,\n    COALESCE(a.tier, 'Unknown') AS ability_tier,\n    \n    -- Synergy rating between Pokemon and ability with significantly expanded logic\n    CASE\n        -- Top competitive synergies (examples from competitive play)\n        WHEN (pa.pokemon_name = 'Gengar' AND pa.ability_name = 'Levitate') THEN 5\n        WHEN (pa.pokemon_name = 'Gyarados' AND pa.ability_name = 'Intimidate') THEN 5\n        WHEN (pa.pokemon_name = 'Garchomp' AND pa.ability_name = 'Rough Skin') THEN 5\n        WHEN (pa.pokemon_name = 'Dragonite' AND pa.ability_name = 'Multiscale') THEN 5\n        WHEN (pa.pokemon_name = 'Tyranitar' AND pa.ability_name = 'Sand Stream') THEN 5\n        WHEN (pa.pokemon_name = 'Ferrothorn' AND pa.ability_name = 'Iron Barbs') THEN 5\n        WHEN (pa.pokemon_name = 'Excadrill' AND pa.ability_name = 'Sand Rush') THEN 5\n        WHEN (pa.pokemon_name = 'Serperior' AND pa.ability_name = 'Contrary') THEN 5\n        WHEN (pa.pokemon_name = 'Greninja' AND pa.ability_name = 'Protean') THEN 5\n        WHEN (pa.pokemon_name = 'Blaziken' AND pa.ability_name = 'Speed Boost') THEN 5\n        \n        -- Weather abilities synergy with types\n        WHEN (pa.ability_name = 'Drought' AND pa.primary_type = 'Fire') THEN 5\n        WHEN (pa.ability_name = 'Drizzle' AND pa.primary_type = 'Water') THEN 5\n        WHEN (pa.ability_name = 'Sand Stream' AND pa.primary_type IN ('Rock', 'Ground')) THEN 5\n        WHEN (pa.ability_name = 'Snow Warning' AND pa.primary_type = 'Ice') THEN 5\n        \n        -- Type boosting abilities\n        WHEN (pa.ability_name = 'Blaze' AND pa.primary_type = 'Fire') THEN 4\n        WHEN (pa.ability_name = 'Torrent' AND pa.primary_type = 'Water') THEN 4\n        WHEN (pa.ability_name = 'Overgrow' AND pa.primary_type = 'Grass') THEN 4\n        WHEN (pa.ability_name = 'Swarm' AND pa.primary_type = 'Bug') THEN 4\n        WHEN (pa.ability_name = 'Flash Fire' AND pa.primary_type = 'Fire') THEN 4\n        WHEN (pa.ability_name = 'Water Absorb' AND pa.primary_type = 'Water') THEN 4\n        WHEN (pa.ability_name = 'Motor Drive' AND pa.primary_type = 'Electric') THEN 4\n        \n        -- Type immunity abilities\n        WHEN (pa.ability_name = 'Levitate' AND pa.primary_type NOT IN ('Flying', 'Ground')) THEN 4.5\n        WHEN (pa.ability_name = 'Levitate' AND pa.primary_type IN ('Flying', 'Ground')) THEN 3.5 -- Redundant for Flying\n        WHEN (pa.ability_name = 'Flash Fire' AND pa.primary_type NOT IN ('Fire')) THEN 4\n        WHEN (pa.ability_name = 'Water Absorb' AND pa.primary_type NOT IN ('Water')) THEN 4\n        WHEN (pa.ability_name = 'Lightning Rod' AND pa.primary_type NOT IN ('Electric')) THEN 4\n        \n        -- Physical vs Special synergy based on stats\n        WHEN (pa.ability_name IN ('Intimidate', 'Marvel Scale', 'Guts') AND \n              pa.total_base_stats >= 500) THEN 4.5\n        WHEN (pa.ability_name IN ('Huge Power', 'Pure Power', 'Sheer Force') AND \n              pa.total_base_stats >= 400) THEN 4.5\n        \n        -- High stat Pok\u00e9mon with appropriate abilities\n        WHEN (pa.ability_name IN ('Huge Power', 'Pure Power', 'Tough Claws', 'Technician') AND \n              pa.total_base_stats >= 500) THEN 4\n        \n        -- Legendary/Mythical synergies are often designed to be good\n        WHEN (pa.is_legendary OR pa.is_mythical) AND pa.is_hidden = FALSE THEN 4.5\n        \n        -- Hidden abilities are often better (especially in later generations)\n        WHEN pa.is_hidden AND pa.generation_number >= 5 THEN 4\n        WHEN pa.is_hidden THEN 3.5\n        \n        -- Newer generations tend to have more balanced abilities\n        WHEN pa.generation_number >= 6 AND pa.is_hidden = FALSE THEN 3.5\n        \n        -- Default synergy (still decent)\n        ELSE 3\n    END AS ability_synergy,\n    \n    -- Competitive relevance indicator\n    CASE\n        WHEN pa.ability_name IN (\n            'Speed Boost', 'Protean', 'Intimidate', 'Drought', 'Drizzle', \n            'Sand Stream', 'Adaptability', 'Huge Power', 'Multiscale',\n            'Magic Guard', 'Regenerator', 'Mold Breaker', 'Contrary',\n            'Magic Bounce', 'Wonder Guard', 'Levitate', 'Unaware',\n            'Disguise', 'Prankster', 'Queenly Majesty', 'Justified',\n            'Serene Grace'\n        ) THEN TRUE\n        WHEN (pa.is_legendary OR pa.is_mythical) AND pa.is_hidden THEN TRUE\n        ELSE FALSE\n    END AS is_competitively_relevant,\n    \n    -- Generation relationship\n    CASE \n        WHEN pa.ability_name IN ('Intimidate', 'Levitate', 'Chlorophyll', \n                              'Swift Swim', 'Sand Stream', 'Drought', 'Drizzle') \n             AND pa.generation_number <= 3 THEN 'Original Ability'\n        WHEN pa.generation_number >= 6 AND pa.is_hidden THEN 'Modern Hidden Ability'\n        WHEN pa.is_hidden THEN 'Hidden Ability'\n        ELSE 'Standard Ability'\n    END AS ability_classification,\n    \n    -- Add data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM pokemon_abilities pa\nLEFT JOIN {{ ref('stg_pokeapi_pokemon') }} p ON pa.pokemon_id = p.id\nLEFT JOIN {{ ref('dim_pokemon_abilities') }} a ON pa.ability_name = a.ability_name\nORDER BY pa.pokemon_id, pa.slot_number", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "dim_pokemon_abilities", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.dim_pokemon_abilities"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_netrunner_card_power": {"database": "nerd_facts", "schema": "public", "name": "fct_netrunner_card_power", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/netrunner/fct_netrunner_card_power.sql", "original_file_path": "models/marts/netrunner/fct_netrunner_card_power.sql", "unique_id": "model.nerd_facts_dbt.fct_netrunner_card_power", "fqn": ["nerd_facts_dbt", "marts", "netrunner", "fct_netrunner_card_power"], "alias": "fct_netrunner_card_power", "checksum": {"name": "sha256", "checksum": "81efbffd54e8527898bff9cf1fdc936c1da7f79285c9214df8831760bee5c10b"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742203914.2602656, "relation_name": "\"nerd_facts\".\"public\".\"fct_netrunner_card_power\"", "raw_code": "/*\n  Model: fct_netrunner_card_power\n  Description: Fact table for Android: Netrunner card power metrics and evaluations\n  \n  Notes:\n  - Provides detailed card power assessments using multiple dimensions\n  - Calculates efficiency scores for different card types\n  - Evaluates meta relevance and rotation status\n  - Analyzes text patterns for synergy detection\n  - Differs from fact_netrunner_cards by focusing on power/efficiency metrics rather than general card facts\n*/\n\nWITH card_base AS (\n    SELECT\n        c.code AS card_code,\n        c.id AS card_id,\n        c.card_name,  -- Updated from 'title' based on staging model\n        c.type_name,  -- Updated from 'card_type' based on staging model\n        c.side_code,\n        c.side_name,\n        c.faction_code,\n        c.faction_name, -- Already included from improved stg_netrunner_cards\n        c.influence_cost, -- Updated from 'influence'\n        c.cost,\n        c.strength,\n        c.advancement_requirement,\n        c.agenda_points,\n        c.card_text,  -- Updated from 'text'\n        c.pack_code,  -- Added missing pack_code\n        c.memory_cost,\n        c.trash_cost,\n        c.is_unique,\n        c.keywords_array\n    FROM {{ ref('stg_netrunner_cards') }} c  -- Updated from stg_netrunner\n    WHERE c.id IS NOT NULL\n),\n\n-- Add pack release information\ncard_release AS (\n    SELECT\n        cb.*,\n        p.release_date,\n        p.cycle_code,\n        p.cycle_name,\n        -- Calculate how many days ago this card was released (with proper null handling)\n        CASE\n            WHEN p.release_date IS NULL THEN NULL\n            ELSE EXTRACT(DAYS FROM CURRENT_DATE - p.release_date) \n        END AS days_since_release\n    FROM card_base cb\n    LEFT JOIN {{ ref('stg_netrunner_packs') }} p ON cb.pack_code = p.code\n)\n\nSELECT\n    -- Generate surrogate key for fact table\n    {{ dbt_utils.generate_surrogate_key(['cr.card_code']) }} AS card_power_key,\n    \n    -- Foreign keys\n    {{ dbt_utils.generate_surrogate_key(['cr.card_code']) }} AS card_key,\n    {{ dbt_utils.generate_surrogate_key(['cr.faction_code']) }} AS faction_key,\n    {{ dbt_utils.generate_surrogate_key(['cr.pack_code']) }} AS pack_key,\n    {{ dbt_utils.generate_surrogate_key(['cr.side_code', 'cr.type_name']) }} AS card_type_key,\n    \n    -- Card identifiers\n    cr.card_code,\n    cr.card_id,\n    cr.card_name,\n    cr.type_name,\n    cr.faction_code,\n    cr.faction_name,\n    cr.side_code,\n    cr.side_name,\n    cr.pack_code,\n    cr.cycle_code,\n    \n    -- Core card metrics with NULL handling\n    COALESCE(cr.influence_cost, 0) AS influence_cost,\n    COALESCE(cr.cost, 0) AS cost,\n    COALESCE(cr.strength, 0) AS strength,\n    COALESCE(cr.advancement_requirement, 0) AS advancement_requirement,\n    COALESCE(cr.agenda_points, 0) AS agenda_points,\n    COALESCE(cr.memory_cost, 0) AS memory_cost,\n    COALESCE(cr.trash_cost, 0) AS trash_cost,\n    \n    -- Card economy efficiency with improved regex and error handling\n    CASE\n        -- Operations and Events (one-time economy)\n        WHEN cr.type_name IN ('Operation', 'Event') AND cr.card_text ILIKE '%gain%credit%' THEN\n            COALESCE(\n                NULLIF(REGEXP_REPLACE(\n                    REGEXP_REPLACE(cr.card_text, '.*gain ([0-9]+)[^0-9].*', '\\1', 'g'),\n                    '[^0-9]', '', 'g'\n                ), '')::INTEGER, 0\n            ) - COALESCE(cr.cost, 0)\n        -- Assets and Resources (recurring economy)\n        WHEN cr.type_name IN ('Asset', 'Resource') AND cr.card_text ILIKE '%gain%credit%' THEN\n            GREATEST(0, (\n                COALESCE(\n                    NULLIF(REGEXP_REPLACE(\n                        REGEXP_REPLACE(cr.card_text, '.*gain ([0-9]+)[^0-9].*', '\\1', 'g'),\n                        '[^0-9]', '', 'g'\n                    ), '')::INTEGER, 0\n                ) - COALESCE(cr.cost, 0)\n            ) / 2)\n        -- Fixed economy cards\n        WHEN cr.card_name IN ('Hedge Fund', 'Sure Gamble', 'IPO') THEN 4\n        WHEN cr.card_name IN ('Daily Casts', 'Adonis Campaign') THEN 3\n        WHEN cr.card_name IN ('PAD Campaign', 'Dirty Laundry') THEN 2\n        ELSE 0\n    END AS credit_efficiency,\n    \n    -- Card power metrics with improved type handling\n    CASE\n        -- Agenda efficiency\n        WHEN cr.type_name = 'Agenda' THEN \n            CASE\n                WHEN COALESCE(cr.agenda_points, 0) > 0 AND COALESCE(cr.advancement_requirement, 0) > 0 \n                THEN ROUND((cr.agenda_points::FLOAT / NULLIF(cr.advancement_requirement, 0)) * 5, 1)\n                ELSE 3\n            END\n        -- ICE efficiency\n        WHEN cr.type_name = 'ICE' THEN\n            CASE \n                WHEN cr.strength IS NULL THEN 2\n                WHEN COALESCE(cr.cost, 0) > 0 THEN ROUND((cr.strength::FLOAT / NULLIF(cr.cost, 0)) * 2, 1)\n                ELSE COALESCE(cr.strength, 2)\n            END\n        -- Icebreaker efficiency\n        WHEN cr.type_name = 'Program' AND cr.card_text ILIKE '%Icebreaker%' THEN\n            CASE\n                WHEN cr.strength IS NULL THEN 2\n                WHEN COALESCE(cr.cost, 0) > 0 THEN ROUND((cr.strength::FLOAT / NULLIF(cr.cost, 0)) * 2, 1)\n                ELSE COALESCE(cr.strength, 2)\n            END\n        -- Identity and special card types\n        WHEN cr.type_name = 'Identity' THEN 4\n        -- Default cost-based efficiency\n        WHEN cr.cost IS NULL THEN 3\n        ELSE GREATEST(1, 5 - COALESCE(cr.cost::FLOAT, 0) / 2)\n    END AS efficiency_score,\n    \n    -- Card power level classification - improved with more indicators\n    CASE\n        -- Known powerful/iconic cards\n        WHEN cr.card_name IN ('Account Siphon', 'Corroder', 'Medium', 'Parasite', \n                           'SanSan City Grid', 'Astroscript Pilot Program', 'Desperado',\n                           'Sure Gamble', 'Hedge Fund', 'Jackson Howard', \n                           'Scorched Earth', 'Daily Business Show', 'Breaking News') THEN 5\n                           \n        -- Powerful card types with good stats\n        WHEN cr.type_name = 'Agenda' AND \n             COALESCE(cr.agenda_points, 0) >= 3 AND \n             COALESCE(cr.advancement_requirement, 0) <= 5 THEN 5\n             \n        WHEN cr.type_name = 'ICE' AND \n             COALESCE(cr.strength, 0) >= 4 AND \n             COALESCE(cr.cost, 0) <= 4 THEN 4\n             \n        WHEN cr.type_name IN ('Console', 'Identity') THEN 4\n        \n        -- Unique and high-influence cards\n        WHEN cr.is_unique AND COALESCE(cr.influence_cost, 0) >= 3 THEN 4\n        WHEN COALESCE(cr.influence_cost, 0) >= 4 THEN 4\n        WHEN COALESCE(cr.influence_cost, 0) >= 2 THEN 3\n        \n        -- Consider keyword count - more keywords often mean more powerful cards\n        WHEN ARRAY_LENGTH(cr.keywords_array, 1) >= 3 THEN 4\n        \n        -- Default\n        ELSE 2\n    END AS power_level,\n    \n    -- Meta relevance with improved calculation\n    CASE\n        -- New releases\n        WHEN cr.days_since_release < 90 THEN 'New Release'\n        \n        -- Known meta-defining cards\n        WHEN cr.card_name IN ('Account Siphon', 'Corroder', 'Sure Gamble', 'Hedge Fund',\n                           'Astroscript Pilot Program', 'SanSan City Grid', \n                           'Jackson Howard', 'Desperado', 'Medium') THEN 'Meta Defining'\n                           \n        -- High power level cards\n        WHEN (\n            cr.card_name IN ('Breaking News', 'Scorched Earth', 'Daily Business Show',\n                         'Parasite', 'Eli 1.0', 'Caprice Nisei', 'Clone Chip')\n            OR \n            (cr.type_name = 'Agenda' AND \n             COALESCE(cr.agenda_points, 0) >= 3 AND \n             COALESCE(cr.advancement_requirement, 0) <= 5)\n            OR\n            (cr.is_unique AND COALESCE(cr.influence_cost, 0) >= 3)\n        ) THEN 'Meta Relevant'\n        \n        -- Standard cards\n        ELSE 'Standard'\n    END AS meta_status,\n    \n    -- Card synergy indicators with improved text pattern matching\n    CASE\n        -- Anarch synergies\n        WHEN (cr.card_text ILIKE '%virus%' OR \n              cr.card_text ILIKE '%trash%program%' OR\n              cr.card_text ILIKE '%install%virus%') \n             AND cr.faction_code = 'anarch' THEN TRUE\n             \n        -- Shaper synergies\n        WHEN (cr.card_text ILIKE '%stealth%' OR \n              cr.card_text ILIKE '%memory%' OR\n              cr.card_text ILIKE '%install%program%') \n             AND cr.faction_code = 'shaper' THEN TRUE\n             \n        -- Criminal synergies  \n        WHEN (cr.card_text ILIKE '%bypass%' OR \n              cr.card_text ILIKE '%credit%successful run%' OR\n              cr.card_text ILIKE '%expose%') \n             AND cr.faction_code = 'criminal' THEN TRUE\n             \n        -- NBN synergies\n        WHEN (cr.card_text ILIKE '%tag%' OR \n              cr.card_text ILIKE '%trace%' OR\n              cr.card_text ILIKE '%reveal%') \n             AND cr.faction_code = 'nbn' THEN TRUE\n             \n        -- Jinteki synergies\n        WHEN (cr.card_text ILIKE '%advance%' OR \n              cr.card_text ILIKE '%net damage%' OR\n              cr.card_text ILIKE '%reveal%') \n             AND cr.faction_code = 'jinteki' THEN TRUE\n             \n        -- Weyland synergies\n        WHEN (cr.card_text ILIKE '%bad publicity%' OR \n              cr.card_text ILIKE '%meat damage%' OR\n              cr.card_text ILIKE '%trash%resource%') \n             AND cr.faction_code = 'weyland-consortium' THEN TRUE\n             \n        -- HB synergies\n        WHEN (cr.card_text ILIKE '%bioroid%' OR \n              cr.card_text ILIKE '%brain damage%' OR\n              cr.card_text ILIKE '%click%break%') \n             AND cr.faction_code = 'haas-bioroid' THEN TRUE\n             \n        -- Default\n        ELSE FALSE\n    END AS has_faction_synergy,\n    \n    -- Post-rotation status with up-to-date cycle information\n    CASE\n        WHEN cr.cycle_code IN ('core', 'genesis', 'creation-and-control', 'spin', \n                            'honor-and-profit', 'lunar', 'order-and-chaos', \n                            'sansan', 'mumbad', 'flashpoint', 'red-sand') THEN 'Rotated'\n        WHEN cr.cycle_code IN ('terminal-directive', 'core2', 'kitara', 'reign-and-reverie') THEN 'Standard'\n        WHEN cr.cycle_code IS NULL THEN 'Unknown'\n        ELSE 'Standard'\n    END AS rotation_status,\n    \n    -- Calculate overall card rating (composite score)\n    CASE\n        -- Meta-defining cards\n        WHEN cr.card_name IN ('Account Siphon', 'Astroscript Pilot Program', 'Jackson Howard') THEN 95\n        -- Rating based on multiple factors\n        ELSE GREATEST(0, LEAST(100, (\n            (COALESCE(cr.influence_cost, 0) * 5) +\n            CASE WHEN cr.is_unique THEN 10 ELSE 0 END +\n            CASE \n                WHEN cr.type_name = 'Agenda' THEN (COALESCE(cr.agenda_points, 0) * 20) - (COALESCE(cr.advancement_requirement, 0) * 5)\n                WHEN cr.type_name = 'ICE' THEN (COALESCE(cr.strength, 0) * 5) \n                WHEN cr.type_name = 'Program' AND cr.card_text ILIKE '%Icebreaker%' THEN (COALESCE(cr.strength, 0) * 7)\n                WHEN cr.type_name IN ('Identity', 'Console') THEN 70\n                ELSE 50\n            END +\n            CASE WHEN cr.card_name IN ('Sure Gamble', 'Hedge Fund') THEN 30 ELSE 0 END +\n            CASE WHEN cr.card_text ILIKE '%gain%credit%' THEN 15 ELSE 0 END\n        )))\n    END AS card_rating,\n    \n    -- Card timing classification\n    CASE\n        WHEN cr.type_name IN ('Event', 'Operation') THEN 'One-time'\n        WHEN cr.type_name IN ('Asset', 'Resource', 'Hardware', 'Program', 'Identity', 'Console') THEN 'Permanent'\n        WHEN cr.type_name = 'ICE' THEN 'Defensive'\n        WHEN cr.type_name = 'Upgrade' THEN 'Enhancement'\n        WHEN cr.type_name = 'Agenda' THEN 'Objective'\n        ELSE 'Other'\n    END AS card_timing,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM card_release cr\nORDER BY cr.side_name, cr.faction_name, power_level DESC, cr.card_name", "language": "sql", "refs": [{"name": "stg_netrunner_cards", "package": null, "version": null}, {"name": "stg_netrunner_packs", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_pokemon_abilities": {"database": "nerd_facts", "schema": "public", "name": "dim_pokemon_abilities", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/dim_pokemon_abilities.sql", "original_file_path": "models/marts/pokemon/dim_pokemon_abilities.sql", "unique_id": "model.nerd_facts_dbt.dim_pokemon_abilities", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "dim_pokemon_abilities"], "alias": "dim_pokemon_abilities", "checksum": {"name": "sha256", "checksum": "8221b2ff82bee7467619271293bf539cbb835b921d22f7900e1e6bc89d89ecd7"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "ability_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["ability_id"]}, {"columns": ["ability_name"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["ability_id"]}, {"columns": ["ability_name"]}], "unique_key": "ability_id"}, "created_at": 1742203914.2789013, "relation_name": "\"nerd_facts\".\"public\".\"dim_pokemon_abilities\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['ability_id']}, {'columns': ['ability_name']}],\n    unique_key = 'ability_id'\n  )\n}}\n\n/*\n  Model: dim_pokemon_abilities\n  Description: Dimension table for Pok\u00e9mon abilities\n  \n  Notes:\n  - Analyzes ability distribution across all Pok\u00e9mon\n  - Categorizes abilities by effect type and competitive tier\n  - Calculates rarity metrics and battle style classifications\n  - Identifies hidden abilities and their gameplay significance\n  - Provides comprehensive categorization for analysis\n*/\n\nWITH ability_usage AS (\n    -- Count how many Pokemon have each ability with improved error handling\n    SELECT \n        COALESCE(ability_name, 'Unknown') AS ability_name,\n        COUNT(*) AS num_pokemon\n    FROM (\n        SELECT \n            jsonb_array_elements(\n                CASE WHEN abilities IS NULL OR abilities = 'null' THEN '[]'::jsonb\n                ELSE abilities END\n            )->>'name' AS ability_name\n        FROM {{ ref('stg_pokeapi_pokemon') }}\n        WHERE abilities IS NOT NULL AND abilities != 'null'\n    ) AS expanded_abilities\n    WHERE ability_name IS NOT NULL\n    GROUP BY ability_name\n),\n\n-- Calculate ability rarity percentiles\nability_ranks AS (\n    SELECT\n        ability_name,\n        num_pokemon,\n        PERCENT_RANK() OVER (ORDER BY num_pokemon) AS rarity_percentile\n    FROM ability_usage\n),\n\n-- Classify abilities by effect type with greatly expanded categories\nability_attributes AS (\n    SELECT\n        ability_name,\n        CASE\n            -- Stat modifiers (expanded)\n            WHEN ability_name IN ('Intimidate', 'Moxie', 'Guts', 'Huge Power', 'Pure Power', 'Beast Boost',\n                                'Defiant', 'Contrary', 'Simple', 'Competitive', 'Anger Point', 'Weak Armor',\n                                'Speed Boost', 'Moody', 'Hustle', 'Sheer Force', 'No Guard', 'Technician',\n                                'Tinted Lens', 'Unburden', 'Victory Star') THEN 'Stat Modifier'\n                                \n            -- Immunities (expanded)\n            WHEN ability_name IN ('Levitate', 'Immunity', 'Water Absorb', 'Volt Absorb', 'Flash Fire',\n                                'Motor Drive', 'Lightning Rod', 'Storm Drain', 'Sap Sipper', 'Dry Skin',\n                                'Earth Eater', 'Wonder Guard', 'Soundproof', 'Water Bubble', 'Fluffy',\n                                'Disguise', 'Thick Fat', 'Heatproof', 'Justified', 'Bulletproof', \n                                'Filter', 'Solid Rock', 'Prism Armor', 'Magic Bounce') THEN 'Immunity'\n                                \n            -- Speed control (expanded)\n            WHEN ability_name IN ('Speed Boost', 'Chlorophyll', 'Swift Swim', 'Sand Rush', 'Slush Rush',\n                                'Surge Surfer', 'Quick Feet', 'Unburden', 'Steadfast', 'Slow Start',\n                                'Quick Draw', 'Gale Wings') THEN 'Speed'\n                                \n            -- Weather abilities\n            WHEN ability_name IN ('Drought', 'Drizzle', 'Sand Stream', 'Snow Warning',\n                                'Desolate Land', 'Primordial Sea', 'Delta Stream', \n                                'Sand Spit', 'Ice Face') THEN 'Weather'\n                                \n            -- Damage boosters (expanded)\n            WHEN ability_name IN ('Blaze', 'Torrent', 'Overgrow', 'Swarm', 'Iron Fist',\n                                'Adaptability', 'Aerilate', 'Pixilate', 'Refrigerate', 'Galvanize',\n                                'Solar Power', 'Steelworker', 'Reckless', 'Mega Launcher',\n                                'Strong Jaw', 'Tough Claws', 'Technician', 'Analytic',\n                                'Punk Rock', 'Dragon's Maw', 'Transistor') THEN 'Damage Boost'\n                                \n            -- Opponent effects (expanded)\n            WHEN ability_name IN ('Pressure', 'Unnerve', 'Intimidate', 'Mummy', 'Gooey', 'Tangling Hair',\n                                'Shadow Tag', 'Arena Trap', 'Magnet Pull', 'Stall', 'Cute Charm',\n                                'Rivalry', 'Slow Start', 'Truant', 'Cotton Down', 'Neutralizing Gas',\n                                'Perish Body', 'Gorilla Tactics', 'Intrepid Sword') THEN 'Opponent Effect'\n                                \n            -- Contact effects (expanded)\n            WHEN ability_name IN ('Synchronize', 'Effect Spore', 'Static', 'Flame Body', 'Poison Point',\n                                'Rough Skin', 'Iron Barbs', 'Pickpocket', 'Gooey', 'Tangling Hair',\n                                'Wandering Spirit', 'Cotton Down', 'Mummy', 'Cursed Body',\n                                'Perish Body') THEN 'Contact Effect'\n                                \n            -- Healing abilities\n            WHEN ability_name IN ('Regenerator', 'Natural Cure', 'Shed Skin', 'Poison Heal', \n                                'Hydration', 'Ice Body', 'Rain Dish', 'Healer', 'Water Bubble', \n                                'Ice Face', 'Disguise') THEN 'Healing'\n                                \n            -- Entry hazard abilities\n            WHEN ability_name IN ('Spikes', 'Stealth Rock', 'Sticky Web', 'Toxic Spikes') THEN 'Entry Hazard'\n            \n            -- Form-changing\n            WHEN ability_name IN ('Protean', 'Libero', 'Color Change', 'Forecast', 'Mimicry',\n                                'Stance Change', 'Battle Bond', 'Power Construct', \n                                'Shields Down', 'Schooling') THEN 'Form Change'\n                                \n            -- Defensive abilities\n            WHEN ability_name IN ('Multiscale', 'Shadow Shield', 'Sturdy', 'Battle Armor', 'Shell Armor',\n                                'Filter', 'Solid Rock', 'Prism Armor', 'Fluffy', 'Thick Fat',\n                                'Magic Guard', 'Disguise', 'Ice Face', 'Marvel Scale',\n                                'Friend Guard', 'Dauntless Shield') THEN 'Defensive'\n                                \n            -- Item-related\n            WHEN ability_name IN ('Pickup', 'Honey Gather', 'Frisk', 'Magician', 'Pickpocket',\n                                'Sticky Hold', 'Unburden', 'Klutz', 'Harvest', 'Cheek Pouch',\n                                'Ripen', 'Ball Fetch') THEN 'Item Effect'\n                                \n            -- Status condition-related\n            WHEN ability_name IN ('Immunity', 'Limber', 'Insomnia', 'Vital Spirit', 'Water Veil',\n                                'Magma Armor', 'Oblivious', 'Own Tempo', 'Inner Focus',\n                                'Shield Dust', 'Leaf Guard', 'Pastel Veil', 'Good as Gold') THEN 'Status Prevention'\n            \n            -- Priority move effects\n            WHEN ability_name IN ('Prankster', 'Gale Wings', 'Triage', 'Queenly Majesty', \n                                'Dazzling', 'Armor Tail') THEN 'Priority'\n                                \n            ELSE 'Other'\n        END AS effect_type,\n        \n        -- Expanded competitive tier rankings\n        CASE\n            -- S-Tier: Game-changing abilities\n            WHEN ability_name IN ('Wonder Guard', 'Huge Power', 'Pure Power', 'Speed Boost', \n                               'Drought', 'Drizzle', 'Sand Stream', 'Snow Warning',\n                               'Shadow Tag', 'Intimidate', 'Beast Boost', 'Protean', 'Magic Guard',\n                               'Prankster', 'Unaware', 'Imposter', 'Desolate Land', 'Primordial Sea',\n                               'Delta Stream', 'Soul-Heart', 'Libero', 'Intrepid Sword',\n                               'Gorilla Tactics', 'As One') THEN 'S'\n                               \n            -- A-Tier: Very strong abilities\n            WHEN ability_name IN ('Moxie', 'Adaptability', 'Serene Grace', 'Guts', 'Levitate', \n                               'Multiscale', 'Regenerator', 'Unaware', 'Water Absorb',\n                               'Volt Absorb', 'Disguise', 'Slush Rush', 'Swift Swim', 'Sand Rush',\n                               'Chlorophyll', 'Queenly Majesty', 'Dazzling', 'Sturdy', 'Electric Surge',\n                               'Psychic Surge', 'Grassy Surge', 'Misty Surge', 'Power Construct',\n                               'Shields Down', 'Contrary', 'Mold Breaker', 'Parental Bond') THEN 'A'\n                               \n            -- B-Tier: Good abilities\n            WHEN ability_name IN ('Flash Fire', 'Poison Heal', 'Thick Fat', 'Technician', \n                               'Sheer Force', 'Tinted Lens', 'Fairy Aura', 'Dark Aura',\n                               'Aura Break', 'No Guard', 'Competitive', 'Simple', 'Unburden',\n                               'Mummy', 'Iron Barbs', 'Rough Skin', 'Solar Power', 'Analytic',\n                               'Steelworker', 'Aerilate', 'Pixilate', 'Refrigerate', 'Neuroforce',\n                               'Galvanize', 'Trace') THEN 'B'\n                               \n            -- C-Tier: Average abilities\n            WHEN ability_name IN ('Blaze', 'Torrent', 'Overgrow', 'Swarm', 'Natural Cure', \n                               'Clear Body', 'Sticky Hold', 'Shed Skin', 'Mold Breaker',\n                               'Pressure', 'Synchronize', 'Ice Body', 'Rain Dish', 'Hustle',\n                               'Filter', 'Solid Rock', 'Infiltrator', 'Super Luck', 'Harvest',\n                               'Big Pecks', 'Early Bird', 'Frisk', 'Rock Head', 'Steadfast',\n                               'Sniper', 'Heavy Metal', 'Light Metal', 'Hydration') THEN 'C'\n                               \n            -- D-Tier: Weak or very situational abilities\n            WHEN ability_name IN ('Run Away', 'Honey Gather', 'Illuminate', 'Stench', 'Stall',\n                               'Suction Cups', 'Shell Armor', 'Battle Armor', 'Ball Fetch',\n                               'Pickup', 'Klutz', 'Slow Start', 'Truant', 'Defeatist',\n                               'Forecast', 'Healer', 'Friend Guard', 'Minus', 'Plus', 'Anticipation',\n                               'Flower Gift', 'Forewarn', 'Rivalry', 'Victory Star',\n                               'Leaf Guard', 'Tangled Feet') THEN 'D'\n                               \n            -- F-Tier: Detrimental or extremely niche abilities\n            WHEN ability_name IN ('Defeatist', 'Slow Start', 'Truant', 'Stall', 'Klutz',\n                               'Illuminate', 'Minus', 'Plus', 'Flower Veil', 'Friend Guard') THEN 'F'\n                               \n            ELSE 'Unclassified'\n        END AS tier\n    FROM ability_ranks\n)\n\nSELECT\n    -- Primary key (using surrogate key pattern)\n    {{ dbt_utils.generate_surrogate_key(['u.ability_name']) }} AS ability_key,\n    ROW_NUMBER() OVER (ORDER BY u.ability_name) AS ability_id,\n    \n    -- Core attributes\n    u.ability_name,\n    u.num_pokemon,\n    a.effect_type,\n    a.tier,\n    \n    -- Calculate rarity - improved with percentiles\n    CASE\n        WHEN r.rarity_percentile >= 0.95 THEN 'Ultra Rare'\n        WHEN r.rarity_percentile >= 0.80 THEN 'Very Rare'\n        WHEN r.rarity_percentile >= 0.60 THEN 'Rare'\n        WHEN r.rarity_percentile >= 0.40 THEN 'Uncommon'\n        WHEN r.rarity_percentile >= 0.20 THEN 'Common'\n        ELSE 'Very Common'\n    END AS rarity,\n    \n    -- Enhanced hidden ability identification with more comprehensive list\n    CASE\n        WHEN u.ability_name IN (\n            -- Gen 5 Dream World abilities\n            'Analytic', 'Chlorophyll', 'Cloud Nine', 'Damp', 'Defiant', 'Drought', 'Drizzle',\n            'Intimidate', 'Lightningrod', 'Moody', 'Moxie', 'Multiscale', 'Overcoat', 'Poison Touch',\n            'Prankster', 'Rain Dish', 'Regenerator', 'Sand Force', 'Sand Rush', 'Sand Veil',\n            'Serene Grace', 'Sheer Force', 'Sniper', 'Snow Warning', 'Speed Boost', 'Technician',\n            'Telepathy', 'Unaware', 'Unnerve',\n            \n            -- Gen 6 notable hidden abilities\n            'Gale Wings', 'Protean', 'Magic Guard', 'Magic Bounce', 'Harvest', 'Infiltrator',\n            'Tinted Lens', 'Gooey', 'Aroma Veil', 'Bulletproof', 'Magician', 'Pickpocket',\n            \n            -- Gen 7 notable hidden abilities\n            'Power of Alchemy', 'Beast Boost', 'RKS System', 'Slush Rush', 'Surge Surfer',\n            'Water Compaction', 'Queenly Majesty', 'Stamina', 'Water Bubble', 'Steelworker',\n            \n            -- Gen 8 notable hidden abilities\n            'Libero', 'Quick Draw', 'Ice Scales', 'Punk Rock', 'Mirror Armor', 'Neutralizing Gas',\n            'Power Spot', 'Ripen', 'Steam Engine', 'Sand Spit', 'Cotton Down', 'Gorilla Tactics',\n            \n            -- Other known hidden abilities that are particularly strong\n            'Adaptability', 'Competitive', 'Contrary', 'Cursed Body', 'Guts', 'Hustle', 'Marvel Scale',\n            'No Guard', 'Poison Heal', 'Solar Power', 'Swift Swim', 'Thick Fat', 'Unburden',\n            'Water Absorb', 'Wonder Skin'\n        ) THEN TRUE\n        ELSE FALSE\n    END AS likely_hidden,\n    \n    -- Battle style classification - expanded categories\n    CASE\n        -- Offensive battle style\n        WHEN a.effect_type IN ('Damage Boost', 'Speed') OR \n             u.ability_name IN ('Moxie', 'Adaptability', 'Beast Boost', 'Huge Power', 'Pure Power',\n                             'Sheer Force', 'Tough Claws', 'Strong Jaw', 'Technician', 'Gorilla Tactics',\n                             'Intrepid Sword', 'Contrary', 'Aerilate', 'Pixilate', 'Refrigerate',\n                             'Galvanize', 'Steelworker', 'Protean', 'Libero', 'Dragon's Maw', 'Transistor',\n                             'Guts', 'No Guard', 'Solar Power', 'Tinted Lens', 'Mega Launcher', 'Sniper')\n        THEN 'Offensive'\n        \n        -- Defensive battle style\n        WHEN a.effect_type IN ('Immunity', 'Defensive', 'Status Prevention', 'Healing') OR\n             u.ability_name IN ('Multiscale', 'Shadow Shield', 'Fur Coat', 'Fluffy', 'Ice Face',\n                             'Disguise', 'Intimidate', 'Filter', 'Solid Rock', 'Prism Armor',\n                             'Sturdy', 'Magic Guard', 'Thick Fat', 'Wonder Guard', 'Levitate',\n                             'Water Absorb', 'Volt Absorb', 'Flash Fire', 'Bulletproof', 'Heatproof',\n                             'Battle Armor', 'Shell Armor', 'Dauntless Shield', 'Ice Scales')\n        THEN 'Defensive'\n        \n        -- Utility/Support battle style\n        WHEN a.effect_type IN ('Weather', 'Opponent Effect', 'Entry Hazard', 'Priority', 'Contact Effect') OR\n             u.ability_name IN ('Drought', 'Drizzle', 'Sand Stream', 'Snow Warning', 'Unaware',\n                             'Prankster', 'Queenly Majesty', 'Dazzling', 'Pressure', 'Trace',\n                             'Synchronize', 'Neutralizing Gas', 'Harvest', 'Healer', 'Regenerator',\n                             'Unnerve', 'Sticky Hold', 'Magnet Pull', 'Arena Trap', 'Shadow Tag')\n        THEN 'Utility'\n        \n        -- Setup-based battle style\n        WHEN u.ability_name IN ('Speed Boost', 'Moody', 'Simple', 'Contrary', 'Power Construct',\n                             'Shields Down', 'Battle Bond', 'Schooling', 'Stance Change',\n                             'Berserk', 'Weak Armor', 'Slush Rush', 'Swift Swim', 'Chlorophyll',\n                             'Sand Rush', 'Surge Surfer', 'Unburden', 'Compound Eyes')\n        THEN 'Setup'\n        \n        -- Default\n        ELSE 'Miscellaneous'\n    END AS battle_style,\n    \n    -- Improved generation introduced information\n    CASE\n        WHEN u.ability_name IN ('Overgrow', 'Blaze', 'Torrent', 'Swarm', 'Intimidate', 'Static', 'Levitate',\n                             'Sturdy', 'Chlorophyll', 'Wonder Guard', 'Speed Boost', 'Synchronize', 'Keen Eye',\n                             'Hyper Cutter', 'Guts', 'Sand Stream', 'Drizzle', 'Drought', 'Flash Fire',\n                             'Wonder Guard', 'Pressure', 'Thick Fat', 'Hustle', 'Truant', 'Cloud Nine',\n                             'Compound Eyes', 'Battle Armor', 'Clear Body', 'Swift Swim', 'Huge Power',\n                             'Sand Veil', 'Arena Trap', 'Water Veil', 'Liquid Ooze', 'Rock Head', 'Early Bird',\n                             'Sticky Hold', 'Shed Skin', 'Run Away', 'Serene Grace', 'Shadow Tag', 'Pure Power',\n                             'Vital Spirit', 'White Smoke', 'Shell Armor', 'Air Lock') THEN 3  -- Gen 3 (first with abilities)\n                             \n        WHEN u.ability_name IN ('Aftermath', 'Anticipation', 'Bad Dreams', 'Download', 'Dry Skin',\n                             'Filter', 'Flower Gift', 'Forewarn', 'Frisk', 'Gluttony', 'Heatproof',\n                             'Honey Gather', 'Hydration', 'Ice Body', 'Iron Fist', 'Klutz', 'Leaf Guard',\n                             'Magic Guard', 'Mold Breaker', 'Motor Drive', 'Multitype', 'No Guard',\n                             'Normalize', 'Poison Heal', 'Quick Feet', 'Reckless', 'Rivalry', 'Scrappy',\n                             'Simple', 'Skill Link', 'Slow Start', 'Sniper', 'Snow Cloak', 'Snow Warning',\n                             'Solar Power', 'Solid Rock', 'Stall', 'Steadfast', 'Storm Drain', 'Suction Cups',\n                             'Tangled Feet', 'Technician', 'Tinted Lens', 'Unaware') THEN 4  -- Gen 4\n                             \n        WHEN u.ability_name IN ('Analytic', 'Big Pecks', 'Contrary', 'Cursed Body', 'Defeatist', 'Defiant',\n                             'Flare Boost', 'Friend Guard', 'Harvest', 'Healer', 'Heavy Metal', 'Illusion',\n                             'Imposter', 'Infiltrator', 'Iron Barbs', 'Light Metal', 'Magic Bounce', 'Moody',\n                             'Moxie', 'Multiscale', 'Mummy', 'Overcoat', 'Pickpocket', 'Poison Touch',\n                             'Prankster', 'Rattled', 'Regenerator', 'Sand Force', 'Sand Rush', 'Sap Sipper',\n                             'Sheer Force', 'Telepathy', 'Teravolt', 'Toxic Boost', 'Turboblaze', 'Unnerve',\n                             'Victory Star', 'Zen Mode') THEN 5  -- Gen 5\n                             \n        WHEN u.ability_name IN ('Aroma Veil', 'Aura Break', 'Bulletproof', 'Cheek Pouch', 'Competitive',\n                             'Dark Aura', 'Fairy Aura', 'Flower Veil', 'Fur Coat', 'Gale Wings',\n                             'Gooey', 'Grass Pelt', 'Magician', 'Mega Launcher', 'Parental Bond',\n                             'Pixilate', 'Protean', 'Refrigerate', 'Strong Jaw', 'Stance Change',\n                             'Sweet Veil', 'Symbiosis', 'Tough Claws') THEN 6  -- Gen 6\n                             \n        WHEN u.ability_name IN ('Battery', 'Beast Boost', 'Comatose', 'Corrosion', 'Dazzling',\n                             'Disguise', 'Electric Surge', 'Emergency Exit', 'Fluffy', 'Full Metal Body',\n                             'Galvanize', 'Grassy Surge', 'Innards Out', 'Liquid Voice', 'Long Reach',\n                             'Merciless', 'Misty Surge', 'Neuroforce', 'Power Construct', 'Power of Alchemy',\n                             'Prism Armor', 'Psychic Surge', 'Queenly Majesty', 'RKS System', 'Receiver',\n                             'Schooling', 'Shadow Shield', 'Shields Down', 'Slush Rush', 'Soul-Heart',\n                             'Stamina', 'Stakeout', 'Steelworker', 'Surge Surfer', 'Tangling Hair',\n                             'Triage', 'Water Bubble', 'Water Compaction', 'Wimp Out') THEN 7  -- Gen 7\n                             \n        WHEN u.ability_name IN ('As One', 'Ball Fetch', 'Cotton Down', 'Curious Medicine', 'Dauntless Shield',\n                             'Dragon's Maw', 'Gorilla Tactics', 'Gulp Missile', 'Hunger Switch', 'Ice Face',\n                             'Ice Scales', 'Intrepid Sword', 'Libero', 'Mirror Armor', 'Neutralizing Gas',\n                             'Pastel Veil', 'Perish Body', 'Power Spot', 'Propeller Tail', 'Punk Rock',\n                             'Quick Draw', 'Ripen', 'Sand Spit', 'Screen Cleaner', 'Stalwart',\n                             'Steam Engine', 'Steely Spirit', 'Transistor', 'Unseen Fist', 'Wandering Spirit') THEN 8  -- Gen 8\n                             \n        WHEN u.ability_name IN ('Angular Wing', 'Armor Tail', 'Beads of Ruin', 'Commander', 'Cud Chew',\n                             'Earth Eater', 'Electromorphosis', 'Good as Gold', 'Guard Dog', 'Hadron Engine',\n                             'Lingering Aroma', 'Mycelium Might', 'Opportunist', 'Orichalcum Pulse', 'Protosynthesis',\n                             'Purifying Salt', 'Quark Drive', 'Seed Sower', 'Sharpness', 'Supreme Overlord',\n                             'Sword of Ruin', 'Tablets of Ruin', 'Thermal Exchange', 'Toxic Debris', 'Vessel of Ruin',\n                             'Well-Baked Body', 'Wind Power', 'Wind Rider', 'Zero to Hero') THEN 9  -- Gen 9\n                             \n        ELSE NULL  -- Likely errors or future abilities\n    END AS generation_introduced,\n    \n    -- Numerical power rating (1-10 scale)\n    CASE\n        WHEN a.tier = 'S' THEN 10\n        WHEN a.tier = 'A' THEN 8\n        WHEN a.tier = 'B' THEN 6\n        WHEN a.tier = 'C' THEN 4\n        WHEN a.tier = 'D' THEN 2\n        WHEN a.tier = 'F' THEN 1\n        ELSE 3\n    END AS power_rating,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM ability_usage u\nJOIN ability_ranks r ON u.ability_name = r.ability_name\nLEFT JOIN ability_attributes a ON u.ability_name = a.ability_name\nORDER BY a.tier, u.num_pokemon DESC", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_pokeapi_moves": {"database": "nerd_facts", "schema": "public", "name": "stg_pokeapi_moves", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/pokeapi/stg_pokeapi_moves.sql", "original_file_path": "models/staging/pokeapi/stg_pokeapi_moves.sql", "unique_id": "model.nerd_facts_dbt.stg_pokeapi_moves", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "stg_pokeapi_moves"], "alias": "stg_pokeapi_moves", "checksum": {"name": "sha256", "checksum": "e470599ca83e4807415034b8aac015bc0e2f8bd3fb71327a750e8590bccac8d8"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.2850528, "relation_name": "\"nerd_facts\".\"public\".\"stg_pokeapi_moves\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_pokeapi_moves\n  Description: Standardized Pok\u00e9mon move data from PokeAPI\n*/\n\nSELECT\n    id,\n    name,\n    type,\n    power,\n    pp,\n    accuracy,\n    priority,\n    damage_class,\n    effect_text,\n    effect_chance,\n    generation_id,\n    target,\n    created_at,\n    updated_at\nFROM {{ source('pokeapi', 'moves') }}", "language": "sql", "refs": [], "sources": [["pokeapi", "moves"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.pokeapi.moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.bridge_pokemon_moves": {"database": "nerd_facts", "schema": "public", "name": "bridge_pokemon_moves", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/bridge_pokemon_moves.sql", "original_file_path": "models/marts/pokemon/bridge_pokemon_moves.sql", "unique_id": "model.nerd_facts_dbt.bridge_pokemon_moves", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "bridge_pokemon_moves"], "alias": "bridge_pokemon_moves", "checksum": {"name": "sha256", "checksum": "feb008a9917945088dfdb8459f551002643bf9bf7b9899cd9433823f9a23384f"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "pokemon_move_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["move_name"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["move_name"]}], "unique_key": "pokemon_move_id"}, "created_at": 1742203914.2924733, "relation_name": "\"nerd_facts\".\"public\".\"bridge_pokemon_moves\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['pokemon_id']}, {'columns': ['move_name']}],\n    unique_key = 'pokemon_move_id'\n  )\n}}\n\n/*\n  Model: bridge_pokemon_moves\n  Description: Bridge table connecting Pok\u00e9mon to their learnable moves\n  \n  Notes:\n  - Handles the many-to-many relationship between Pok\u00e9mon and moves\n  - Extracts move references from nested JSON in the pok\u00e9mon staging model\n  - Calculates STAB (Same Type Attack Bonus) and signature move flags\n  - Provides context on move learning methods and levels\n  - Calculates move relevance for competitive analysis\n*/\n\nWITH pokemon_moves AS (\n    -- Extract move references from the pokemon data with improved error handling\n    SELECT\n        p.id AS pokemon_id,\n        p.name AS pokemon_name,\n        p.primary_type,\n        p.secondary_type,\n        p.generation_number,\n        p.total_base_stats,\n        COALESCE(move_ref->>'name', 'Unknown') AS move_name,\n        COALESCE(move_ref->>'type', 'Unknown') AS move_type,\n        COALESCE((move_ref->>'learn_method')::text, 'level-up') AS learn_method,\n        COALESCE((move_ref->>'level_learned_at')::integer, 0) AS level_learned_at\n    FROM {{ ref('stg_pokeapi_pokemon') }} p,\n    LATERAL jsonb_array_elements(\n        CASE WHEN p.moves IS NULL OR p.moves = 'null' THEN '[]'::jsonb\n        ELSE p.moves END\n    ) AS move_ref\n    WHERE p.id IS NOT NULL\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['pm.pokemon_id', 'pm.move_name', 'pm.learn_method', 'COALESCE(pm.level_learned_at, 0)']) }} AS pokemon_move_id,\n    \n    -- Foreign keys\n    {{ dbt_utils.generate_surrogate_key(['pm.pokemon_id']) }} AS pokemon_key,\n    {{ dbt_utils.generate_surrogate_key(['m.move_id']) }} AS move_key,\n    \n    -- Core identifiers\n    pm.pokemon_id,\n    pm.pokemon_name,\n    pm.move_name,\n    pm.move_type,\n    pm.learn_method,\n    pm.level_learned_at,\n    \n    -- Add move stats from the moves dimension\n    COALESCE(m.move_id, 0) AS move_id,\n    COALESCE(m.power, 0) AS move_power,\n    COALESCE(m.accuracy, 0) AS move_accuracy,\n    COALESCE(m.pp, 0) AS move_pp,\n    COALESCE(m.damage_class, 'Unknown') AS damage_class,\n    \n    -- Check if move type matches EITHER Pokemon type (improved STAB detection)\n    CASE\n        WHEN pm.move_type = pm.primary_type THEN TRUE\n        WHEN pm.move_type = pm.secondary_type AND pm.secondary_type IS NOT NULL THEN TRUE\n        ELSE FALSE\n    END AS has_stab,\n    \n    -- Calculate if this is a signature move (significantly expanded)\n    CASE\n        -- Name-based detection\n        WHEN pm.move_name LIKE CONCAT('%', pm.pokemon_name, '%') THEN TRUE\n        \n        -- Starter Pok\u00e9mon signature moves\n        WHEN (pm.pokemon_name = 'Pikachu' AND pm.move_name = 'Volt Tackle') THEN TRUE\n        WHEN (pm.pokemon_name = 'Charizard' AND pm.move_name = 'Blast Burn') THEN TRUE\n        WHEN (pm.pokemon_name = 'Blastoise' AND pm.move_name = 'Hydro Cannon') THEN TRUE\n        WHEN (pm.pokemon_name = 'Venusaur' AND pm.move_name = 'Frenzy Plant') THEN TRUE\n        \n        -- Legendary signature moves\n        WHEN (pm.pokemon_name = 'Mewtwo' AND pm.move_name = 'Psystrike') THEN TRUE\n        WHEN (pm.pokemon_name = 'Lugia' AND pm.move_name = 'Aeroblast') THEN TRUE\n        WHEN (pm.pokemon_name = 'Ho-Oh' AND pm.move_name = 'Sacred Fire') THEN TRUE\n        WHEN (pm.pokemon_name = 'Kyogre' AND pm.move_name = 'Origin Pulse') THEN TRUE\n        WHEN (pm.pokemon_name = 'Groudon' AND pm.move_name = 'Precipice Blades') THEN TRUE\n        WHEN (pm.pokemon_name = 'Rayquaza' AND pm.move_name = 'Dragon Ascent') THEN TRUE\n        WHEN (pm.pokemon_name = 'Dialga' AND pm.move_name = 'Roar of Time') THEN TRUE\n        WHEN (pm.pokemon_name = 'Palkia' AND pm.move_name = 'Spacial Rend') THEN TRUE\n        WHEN (pm.pokemon_name = 'Giratina' AND pm.move_name = 'Shadow Force') THEN TRUE\n        WHEN (pm.pokemon_name = 'Zekrom' AND pm.move_name = 'Bolt Strike') THEN TRUE\n        WHEN (pm.pokemon_name = 'Reshiram' AND pm.move_name = 'Blue Flare') THEN TRUE\n        \n        -- Other notable signature moves\n        WHEN (pm.pokemon_name = 'Snorlax' AND pm.move_name = 'Pulverizing Pancake') THEN TRUE\n        WHEN (pm.pokemon_name = 'Marshadow' AND pm.move_name = 'Spectral Thief') THEN TRUE\n        WHEN (pm.pokemon_name = 'Kommo-o' AND pm.move_name = 'Clangorous Soulblaze') THEN TRUE\n        WHEN (pm.pokemon_name = 'Necrozma' AND pm.move_name = 'Photon Geyser') THEN TRUE\n        WHEN (pm.pokemon_name = 'Solgaleo' AND pm.move_name = 'Sunsteel Strike') THEN TRUE\n        WHEN (pm.pokemon_name = 'Lunala' AND pm.move_name = 'Moongeist Beam') THEN TRUE\n        WHEN (pm.pokemon_name = 'Zeraora' AND pm.move_name = 'Plasma Fists') THEN TRUE\n        WHEN (pm.pokemon_name = 'Mew' AND pm.move_name = 'Genesis Supernova') THEN TRUE\n        \n        ELSE FALSE\n    END AS is_signature_move,\n    \n    -- Moves learned at level 1 or by evolution are typically important\n    CASE\n        WHEN pm.level_learned_at = 1 OR pm.learn_method = 'evolution' THEN TRUE\n        ELSE FALSE\n    END AS is_natural_move,\n    \n    -- Enhanced learn method classification\n    CASE\n        WHEN pm.learn_method = 'level-up' THEN 'Level Up'\n        WHEN pm.learn_method = 'machine' THEN 'TM/HM'\n        WHEN pm.learn_method = 'egg' THEN 'Egg Move'\n        WHEN pm.learn_method = 'tutor' THEN 'Move Tutor'\n        WHEN pm.learn_method = 'evolution' THEN 'Evolution'\n        WHEN pm.learn_method = 'form-change' THEN 'Form Change'\n        ELSE 'Other'\n    END AS learn_method_type,\n    \n    -- Move priority classification (improved logic)\n    CASE\n        WHEN is_signature_move THEN 'Signature'\n        WHEN pm.has_stab AND pm.level_learned_at <= 20 AND COALESCE(m.power, 0) >= 80 THEN 'High'\n        WHEN pm.has_stab AND COALESCE(m.power, 0) >= 90 THEN 'High'\n        WHEN pm.has_stab AND pm.level_learned_at <= 50 THEN 'Medium-High'\n        WHEN pm.has_stab THEN 'Medium'\n        WHEN pm.learn_method = 'machine' AND COALESCE(m.power, 0) >= 90 THEN 'TM-High'\n        WHEN pm.learn_method = 'machine' THEN 'TM-Standard'\n        WHEN pm.learn_method = 'tutor' AND COALESCE(m.power, 0) >= 80 THEN 'Tutor-High'\n        WHEN COALESCE(m.power, 0) >= 100 THEN 'High-Power'\n        ELSE 'Low'\n    END AS move_priority,\n    \n    -- Competitive relevance (new)\n    CASE\n        -- Signature and high-power STAB moves\n        WHEN is_signature_move THEN 5\n        -- Strong STAB moves with good accuracy\n        WHEN pm.has_stab AND COALESCE(m.power, 0) >= 90 AND COALESCE(m.accuracy, 0) >= 90 THEN 5\n        -- Coverage moves (strong non-STAB)\n        WHEN NOT pm.has_stab AND COALESCE(m.power, 0) >= 90 AND COALESCE(m.accuracy, 0) >= 90 THEN 4\n        -- Medium-strong STAB moves\n        WHEN pm.has_stab AND COALESCE(m.power, 0) >= 70 THEN 4\n        -- Key support moves\n        WHEN pm.move_name IN ('Stealth Rock', 'Toxic', 'Will-O-Wisp', 'Thunder Wave', 'Spikes', \n                            'Recover', 'Wish', 'Defog', 'Rapid Spin', 'Protect', 'Substitute', \n                            'Swords Dance', 'Nasty Plot', 'Dragon Dance', 'Calm Mind', 'Agility',\n                            'Quiver Dance', 'Tailwind', 'Reflect', 'Light Screen') THEN 5\n        -- Status moves are generally useful\n        WHEN COALESCE(m.damage_class, 'Unknown') = 'status' THEN 3\n        -- Weak moves\n        WHEN COALESCE(m.power, 0) <= 40 THEN 1\n        -- Everything else\n        ELSE 2\n    END AS competitive_relevance,\n    \n    -- Move generation match (new - indicates if move is from same generation as Pokemon)\n    CASE\n        WHEN pm.generation_number = COALESCE(m.generation_id, 0) THEN TRUE\n        ELSE FALSE\n    END AS is_same_generation,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM pokemon_moves pm\nLEFT JOIN {{ ref('dim_pokemon_moves') }} m ON pm.move_name = m.name\nORDER BY pm.pokemon_id, competitive_relevance DESC, pm.level_learned_at", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "dim_pokemon_moves", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.dim_pokemon_moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_netrunner_cards": {"database": "nerd_facts", "schema": "public", "name": "dim_netrunner_cards", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/netrunner/dim_netrunner_cards.sql", "original_file_path": "models/marts/netrunner/dim_netrunner_cards.sql", "unique_id": "model.nerd_facts_dbt.dim_netrunner_cards", "fqn": ["nerd_facts_dbt", "marts", "netrunner", "dim_netrunner_cards"], "alias": "dim_netrunner_cards", "checksum": {"name": "sha256", "checksum": "6faaa4b68315c21ae6cb2d404eaafcc62d7c8d82c3c2b5d93ab8d4ed0bb556da"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742203914.3001604, "relation_name": "\"nerd_facts\".\"public\".\"dim_netrunner_cards\"", "raw_code": "/*\n  Model: dim_netrunner_cards\n  Description: Comprehensive dimension table for Android: Netrunner cards\n  \n  Notes:\n  - Combines card data with faction information\n  - Creates categorizations and derived attributes for analysis\n  - Adds enhanced card typing and sub-typing\n  - Includes power level calculations and economy classification\n  - Consolidates core metadata from multiple sources\n*/\n\nWITH card_base AS (\n    SELECT\n        c.code AS card_code,\n        c.id AS card_id,\n        c.card_name,  -- Updated from 'title' based on staging model improvements\n        c.type_name,\n        c.faction_code,\n        c.faction_name, -- Already included from improved stg_netrunner_cards\n        c.side_code,\n        c.side_name,    -- Included from improved model\n        c.influence_cost,\n        c.cost,\n        c.advancement_requirement,\n        c.agenda_points,\n        c.strength,\n        c.card_text,    -- Updated from 'text' based on staging model\n        c.flavor_text,  -- Updated from 'flavor' based on staging model\n        c.keywords,\n        c.keywords_array, -- Already parsed in stg_netrunner_cards\n        c.illustrator,\n        c.pack_code,\n        c.is_unique,    -- Added from stg_netrunner_cards\n        c.deck_limit,   -- Added from stg_netrunner_cards\n        c.memory_cost,  -- Added from stg_netrunner_cards \n        c.trash_cost    -- Added from stg_netrunner_cards\n    FROM {{ ref('stg_netrunner_cards') }} c\n    -- Remove JOIN to factions as it's now included in stg_netrunner_cards\n),\n\n-- Add cycle information for release context\ncard_with_cycle AS (\n    SELECT\n        c.*,\n        p.cycle_code,\n        p.cycle_name,\n        p.pack_name,\n        p.release_date,\n        p.pack_position\n    FROM card_base c\n    LEFT JOIN {{ ref('stg_netrunner_packs') }} p ON c.pack_code = p.code\n),\n\n-- Add popularity/usage data (could come from tournament data in real implementation)\ncard_usage AS (\n    SELECT\n        card_code,\n        -- Simulated usage metrics - in a real implementation, join to actual tournament data\n        CASE\n            WHEN card_name IN ('Account Siphon', 'Desperado', 'SanSan City Grid', \n                            'Astroscript Pilot Program', 'Sure Gamble', 'Hedge Fund') THEN 80\n            WHEN cycle_code IN ('core', 'genesis', 'creation-and-control') AND influence_cost >= 3 THEN 65  \n            WHEN cycle_code IN ('core', 'genesis') AND influence_cost >= 2 THEN 50\n            WHEN cycle_code NOT IN ('core', 'genesis', 'creation-and-control') THEN 30\n            ELSE 40\n        END AS usage_percentage\n    FROM card_with_cycle\n)\n\nSELECT\n    -- Generate surrogate key\n    {{ dbt_utils.generate_surrogate_key(['c.card_code']) }} AS card_key,\n    \n    -- Primary identifiers\n    c.card_code,\n    c.card_id,\n    c.card_name,\n    \n    -- Card type and classification\n    c.type_name,\n    c.faction_code,\n    c.faction_name,\n    c.side_code,\n    c.side_name,\n    \n    -- Card attributes\n    c.influence_cost,\n    c.cost,\n    c.advancement_requirement,\n    c.agenda_points,\n    c.strength,\n    c.memory_cost,\n    c.trash_cost,\n    c.is_unique,\n    c.deck_limit,\n    \n    -- Card text and art\n    c.card_text,\n    c.flavor_text,\n    c.keywords,\n    c.keywords_array,\n    c.illustrator,\n    \n    -- Publication data\n    c.pack_code,\n    c.pack_name,\n    c.cycle_code,\n    c.cycle_name,\n    c.release_date,\n    \n    -- Card rarity (improved logic)\n    CASE\n        WHEN c.pack_code = 'core' THEN\n            CASE\n                WHEN c.influence_cost >= 4 OR c.card_name IN ('SanSan City Grid', 'Desperado') THEN '1x (Rare)'\n                WHEN c.influence_cost >= 2 OR c.card_name IN ('Hedge Fund', 'Sure Gamble') THEN '2x (Uncommon)'\n                ELSE '3x (Common)'\n            END\n        WHEN c.pack_code LIKE 'draft%' THEN 'Draft'\n        WHEN c.cycle_code = 'core2' THEN \n            CASE \n                WHEN c.card_name IN ('Sure Gamble', 'Hedge Fund') THEN '3x (Common)'\n                WHEN c.is_unique = TRUE THEN '1x (Rare)'\n                ELSE '2x (Uncommon)'\n            END\n        ELSE '3x (Common)'  -- Default for normal packs\n    END AS core_rarity,\n    \n    -- Enhanced card category with subtyping\n    CASE\n        WHEN c.type_name = 'Identity' THEN 'Identity'\n        WHEN c.type_name IN ('Event', 'Operation') THEN 'One-time'\n        WHEN c.type_name IN ('Hardware', 'Resource', 'Asset', 'Upgrade') THEN 'Permanent'\n        WHEN c.type_name = 'Program' AND c.card_text ILIKE '%Icebreaker%' THEN \n            CASE \n                WHEN c.card_text ILIKE '%Fracter%' THEN 'Icebreaker - Fracter'\n                WHEN c.card_text ILIKE '%Decoder%' THEN 'Icebreaker - Decoder'\n                WHEN c.card_text ILIKE '%Killer%' THEN 'Icebreaker - Killer'\n                WHEN c.card_text ILIKE '%AI%' THEN 'Icebreaker - AI'\n                ELSE 'Icebreaker - Other'\n            END\n        WHEN c.type_name = 'Program' THEN 'Program'\n        WHEN c.type_name = 'ICE' THEN \n            CASE\n                WHEN c.card_text ILIKE '%Barrier%' AND c.card_text ILIKE '%Code Gate%' AND c.card_text ILIKE '%Sentry%' THEN 'ICE - Mythic'\n                WHEN c.card_text ILIKE '%Barrier%' AND c.card_text ILIKE '%Code Gate%' THEN 'ICE - Barrier/Code Gate'\n                WHEN c.card_text ILIKE '%Barrier%' AND c.card_text ILIKE '%Sentry%' THEN 'ICE - Barrier/Sentry'\n                WHEN c.card_text ILIKE '%Code Gate%' AND c.card_text ILIKE '%Sentry%' THEN 'ICE - Code Gate/Sentry'\n                WHEN c.card_text ILIKE '%Barrier%' THEN 'ICE - Barrier'\n                WHEN c.card_text ILIKE '%Code Gate%' THEN 'ICE - Code Gate'\n                WHEN c.card_text ILIKE '%Sentry%' THEN 'ICE - Sentry'\n                WHEN c.card_text ILIKE '%Trap%' THEN 'ICE - Trap'\n                ELSE 'ICE - Other'\n            END\n        WHEN c.type_name = 'Agenda' THEN 'Agenda'\n        ELSE 'Other'\n    END AS card_category,\n    \n    -- Card power level (enhanced with more indicators)\n    CASE\n        -- Powerful/banned cards\n        WHEN c.card_name IN ('Adjusted Chronotype', 'Apocalypse', 'Bio-Ethics Association', \n                          'Brain Rewiring', 'Clone Chip', 'Employee Strike', 'NAPD Most Wanted',\n                          'Rumor Mill', '\u015eifr', 'Tem\u00fcjin Contract', 'Violet Level Clearance',\n                          'Tapwrm', 'Watch the World Burn', 'Aesop\\'s Pawnshop') THEN 5\n                          \n        -- Top meta cards\n        WHEN c.card_name IN ('Account Siphon', 'Corroder', 'Hedge Fund', 'Sure Gamble', \n                           'Astroscript Pilot Program', 'SanSan City Grid', 'Desperado',\n                           'Daily Casts', 'Jackson Howard', 'Breaking News', 'Eli 1.0',\n                           'Parasite', 'Gordian Blade', 'Liberated Account') THEN 5\n                           \n        -- Known good cards                   \n        WHEN (c.type_name = 'ICE' AND COALESCE(c.cost, 0) >= 4) OR \n             (c.type_name = 'Program' AND c.card_text ILIKE '%Icebreaker%' AND COALESCE(c.influence_cost, 0) >= 3) OR\n             (c.type_name = 'Agenda' AND COALESCE(c.agenda_points, 0) >= 3 AND COALESCE(c.advancement_requirement, 0) <= 5) OR\n             (u.usage_percentage >= 60) THEN 4\n             \n        -- Average useful cards\n        WHEN (COALESCE(c.cost, 0) >= 3) OR \n             (COALESCE(c.influence_cost, 0) >= 2) OR\n             (u.usage_percentage >= 40) THEN 3\n             \n        -- Basic cards\n        ELSE 2\n    END AS power_level,\n    \n    -- Economic classification with improved detection\n    CASE\n        WHEN c.card_text ILIKE '%gain %credit%' OR \n             c.card_text ILIKE '%take %credit%' OR\n             c.card_text ILIKE '%credit for each%' OR\n             c.card_text ILIKE '%credits when%' THEN \n            CASE\n                WHEN c.card_text ILIKE '%when successful%' THEN 'Conditional Economy'\n                WHEN c.card_text ILIKE '%trash%' THEN 'One-time Economy'\n                WHEN c.type_name IN ('Event', 'Operation') THEN 'Burst Economy'\n                ELSE 'Drip Economy'\n            END\n        ELSE NULL\n    END AS economy_type,\n    \n    -- Enhanced economy card detection\n    CASE\n        WHEN c.card_text ILIKE '%gain %credit%' OR \n             c.card_text ILIKE '%take %credit%' OR\n             c.card_text ILIKE '%credit for each%' OR \n             c.card_text ILIKE '%credits when%' OR\n             c.card_name IN ('Hedge Fund', 'Sure Gamble', 'Daily Casts', 'Adonis Campaign',\n                           'Magnum Opus', 'PAD Campaign', 'Liberated Account',\n                           'Professional Contacts', 'Dirty Laundry', 'Peace in Our Time') THEN TRUE\n        ELSE FALSE\n    END AS is_economy_card,\n    \n    -- Card age and usage metrics\n    DATE_PART('year', CURRENT_DATE) - DATE_PART('year', c.release_date) AS card_age_years,\n    u.usage_percentage,\n    \n    -- Data tracking\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM card_with_cycle c\nLEFT JOIN card_usage u ON c.card_code = u.card_code\nORDER BY c.side_name, c.faction_name, c.type_name, c.cost", "language": "sql", "refs": [{"name": "stg_netrunner_cards", "package": null, "version": null}, {"name": "stg_netrunner_packs", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_pokemon_matchups": {"database": "nerd_facts", "schema": "public", "name": "fct_pokemon_matchups", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/fct_pokemon_matchups.sql", "original_file_path": "models/marts/pokemon/fct_pokemon_matchups.sql", "unique_id": "model.nerd_facts_dbt.fct_pokemon_matchups", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "fct_pokemon_matchups"], "alias": "fct_pokemon_matchups", "checksum": {"name": "sha256", "checksum": "78d423d3786d00ea386d5da04b3b50d291961fcda1b6fba7e0a783678956879f"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "matchup_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["matchup_id"]}, {"columns": ["attacking_type", "defending_type"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["matchup_id"]}, {"columns": ["attacking_type", "defending_type"]}], "unique_key": "matchup_id"}, "created_at": 1742203914.3415112, "relation_name": "\"nerd_facts\".\"public\".\"fct_pokemon_matchups\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['matchup_id']}, {'columns': ['attacking_type', 'defending_type']}],\n    unique_key = 'matchup_id'\n  )\n}}\n\n/*\n  Model: fct_pokemon_matchups\n  Description: Fact table for Pok\u00e9mon type matchup effectiveness\n  \n  Notes:\n  - Contains comprehensive type matchup data for all 18 Pok\u00e9mon types\n  - Calculates effectiveness multipliers (0x, 0.5x, 1x, 2x)\n  - Provides context on how many Pok\u00e9mon are affected by each matchup\n  - Includes dual-type effectiveness calculations\n  - Creates detailed descriptions for analysis and visualization\n*/\n\nWITH type_pairs AS (\n    -- Generate all possible type combinations\n    SELECT\n        a.type_name AS attacking_type,\n        d.type_name AS defending_type\n    FROM {{ ref('dim_pokemon_types') }} a\n    CROSS JOIN {{ ref('dim_pokemon_types') }} d\n    WHERE a.type_name != 'Unknown' AND d.type_name != 'Unknown' -- Filter out Unknown type\n),\n\n-- Use the arrays from dim_pokemon_types to determine effectiveness\ntype_effectiveness AS (\n    SELECT\n        tp.attacking_type,\n        tp.defending_type,\n        \n        -- Determine effectiveness by checking immune/resistant/weak arrays\n        CASE\n            -- No effect (0x damage) if defending type is immune to attacking type\n            WHEN tp.defending_type IN (\n                SELECT unnest(immunities) \n                FROM {{ ref('dim_pokemon_types') }} \n                WHERE type_name = tp.attacking_type\n            ) THEN 0\n            \n            -- Super effective (2x damage) if defending type is weak to attacking type\n            WHEN tp.defending_type IN (\n                SELECT unnest(super_effective) \n                FROM {{ ref('dim_pokemon_types') }} \n                WHERE type_name = tp.attacking_type\n            ) THEN 2\n            \n            -- Not very effective (0.5x damage) if defending type resists attacking type\n            WHEN tp.defending_type IN (\n                SELECT unnest(resistances) \n                FROM {{ ref('dim_pokemon_types') }} \n                WHERE type_name = tp.attacking_type\n            ) THEN 0.5\n            \n            -- Normal effectiveness (1x damage) for everything else\n            ELSE 1\n        END AS effectiveness_multiplier\n    FROM type_pairs tp\n),\n\n-- Count Pok\u00e9mon with each primary and secondary type combination\npokemon_type_counts AS (\n    SELECT\n        primary_type,\n        secondary_type,\n        COUNT(*) AS pokemon_count\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    WHERE primary_type IS NOT NULL\n    GROUP BY primary_type, secondary_type\n),\n\n-- Get dual-type defending Pok\u00e9mon and calculate combined effectiveness\ndual_type_effectiveness AS (\n    SELECT\n        te1.attacking_type,\n        ptc.primary_type AS primary_defending_type,\n        ptc.secondary_type AS secondary_defending_type,\n        -- Multiply effectiveness against both types\n        te1.effectiveness_multiplier * te2.effectiveness_multiplier AS combined_effectiveness,\n        ptc.pokemon_count\n    FROM pokemon_type_counts ptc\n    JOIN type_effectiveness te1 ON ptc.primary_type = te1.defending_type\n    JOIN type_effectiveness te2 ON ptc.secondary_type = te2.defending_type\n    WHERE ptc.secondary_type IS NOT NULL\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['te.attacking_type', 'te.defending_type']) }} AS matchup_id,\n    \n    -- Core dimensions\n    te.attacking_type,\n    te.defending_type,\n    te.effectiveness_multiplier,\n    \n    -- Attacking type metadata\n    at.type_category AS attacking_type_category,\n    at.damage_category AS attacking_damage_category,\n    at.type_color AS attacking_type_color,\n    \n    -- Defending type metadata\n    dt.type_category AS defending_type_category,\n    dt.resistance_count,\n    dt.weakness_count,\n    dt.immunity_count,\n    dt.type_color AS defending_type_color,\n    \n    -- Effectiveness category with more detail\n    CASE\n        WHEN te.effectiveness_multiplier = 0 THEN 'Immune (0x)'\n        WHEN te.effectiveness_multiplier = 0.25 THEN 'Doubly resistant (0.25x)'\n        WHEN te.effectiveness_multiplier = 0.5 THEN 'Resistant (0.5x)'\n        WHEN te.effectiveness_multiplier = 1 THEN 'Normal (1x)'\n        WHEN te.effectiveness_multiplier = 2 THEN 'Super effective (2x)'\n        WHEN te.effectiveness_multiplier = 4 THEN 'Doubly super effective (4x)'\n        ELSE te.effectiveness_multiplier::TEXT || 'x'\n    END AS effectiveness_category,\n    \n    -- Count Pok\u00e9mon with each attacking and defending type\n    COALESCE((SELECT SUM(pokemon_count) FROM pokemon_type_counts \n              WHERE primary_type = te.attacking_type OR secondary_type = te.attacking_type), 0) AS attacking_type_pokemon_count,\n              \n    COALESCE((SELECT SUM(pokemon_count) FROM pokemon_type_counts \n              WHERE primary_type = te.defending_type OR secondary_type = te.defending_type), 0) AS defending_type_pokemon_count,\n    \n    -- Dual-type effectiveness stats\n    (\n        SELECT COUNT(DISTINCT primary_defending_type || secondary_defending_type) \n        FROM dual_type_effectiveness dte \n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness = 0\n    ) AS num_immune_type_combos,\n    \n    (\n        SELECT COUNT(DISTINCT primary_defending_type || secondary_defending_type) \n        FROM dual_type_effectiveness dte \n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness = 0.25\n    ) AS num_double_resistant_combos,\n    \n    (\n        SELECT COUNT(DISTINCT primary_defending_type || secondary_defending_type) \n        FROM dual_type_effectiveness dte \n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness = 0.5\n    ) AS num_resistant_combos,\n    \n    (\n        SELECT COUNT(DISTINCT primary_defending_type || secondary_defending_type) \n        FROM dual_type_effectiveness dte \n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness = 2\n    ) AS num_super_effective_combos,\n    \n    (\n        SELECT COUNT(DISTINCT primary_defending_type || secondary_defending_type) \n        FROM dual_type_effectiveness dte \n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness = 4\n    ) AS num_double_super_effective_combos,\n    \n    -- Most vulnerable dual-type to this attack\n    (\n        SELECT primary_defending_type || '/' || secondary_defending_type\n        FROM dual_type_effectiveness dte\n        WHERE dte.attacking_type = te.attacking_type\n        ORDER BY dte.combined_effectiveness DESC, dte.pokemon_count DESC\n        LIMIT 1\n    ) AS most_vulnerable_dual_type,\n    \n    -- Most resistant dual-type to this attack\n    (\n        SELECT primary_defending_type || '/' || secondary_defending_type\n        FROM dual_type_effectiveness dte\n        WHERE dte.attacking_type = te.attacking_type AND dte.combined_effectiveness > 0\n        ORDER BY dte.combined_effectiveness ASC, dte.pokemon_count DESC\n        LIMIT 1\n    ) AS most_resistant_dual_type,\n    \n    -- Enhanced matchup description with more detail\n    CASE\n        WHEN te.effectiveness_multiplier = 0 THEN \n            te.attacking_type || ' attacks have no effect on ' || te.defending_type || ' Pok\u00e9mon'\n        WHEN te.effectiveness_multiplier = 0.5 THEN \n            te.attacking_type || ' attacks are not very effective against ' || te.defending_type || ' Pok\u00e9mon (0.5x damage)'\n        WHEN te.effectiveness_multiplier = 1 THEN \n            te.attacking_type || ' attacks have normal effectiveness against ' || te.defending_type || ' Pok\u00e9mon'\n        WHEN te.effectiveness_multiplier = 2 THEN \n            te.attacking_type || ' attacks are super effective against ' || te.defending_type || ' Pok\u00e9mon (2x damage)'\n        WHEN te.effectiveness_multiplier = 4 THEN \n            te.attacking_type || ' attacks are doubly super effective against ' || te.defending_type || ' Pok\u00e9mon (4x damage)'\n        ELSE \n            te.attacking_type || ' vs ' || te.defending_type || ' = ' || te.effectiveness_multiplier || 'x damage'\n    END AS matchup_description,\n    \n    -- Coverage value: How valuable is this attacking type for coverage?\n    -- Higher = this type is super effective against more types with many Pok\u00e9mon\n    CASE\n        WHEN te.effectiveness_multiplier >= 2 THEN \n            te.effectiveness_multiplier * defending_type_pokemon_count\n        ELSE 0\n    END AS coverage_value,\n    \n    -- Competitive relevance: How important is this matchup in competitive play?\n    CASE\n        WHEN te.defending_type IN ('Fairy', 'Dragon', 'Steel') AND te.effectiveness_multiplier >= 2 THEN 'Very High'\n        WHEN te.defending_type IN ('Water', 'Flying', 'Ground', 'Ghost') AND te.effectiveness_multiplier >= 2 THEN 'High'\n        WHEN te.effectiveness_multiplier = 4 THEN 'Very High'\n        WHEN te.effectiveness_multiplier = 2 THEN 'Moderate'\n        WHEN te.effectiveness_multiplier = 0 THEN 'Situational'\n        ELSE 'Low'\n    END AS competitive_relevance,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM type_effectiveness te\nJOIN {{ ref('dim_pokemon_types') }} at ON te.attacking_type = at.type_name  -- Join for attacking type metadata\nJOIN {{ ref('dim_pokemon_types') }} dt ON te.defending_type = dt.type_name  -- Join for defending type metadata\nORDER BY te.attacking_type, te.effectiveness_multiplier DESC", "language": "sql", "refs": [{"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}, {"name": "dim_pokemon_types", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.dim_pokemon_types", "model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_pokeapi_items": {"database": "nerd_facts", "schema": "public", "name": "stg_pokeapi_items", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/pokeapi/stg_pokeapi_items.sql", "original_file_path": "models/staging/pokeapi/stg_pokeapi_items.sql", "unique_id": "model.nerd_facts_dbt.stg_pokeapi_items", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "stg_pokeapi_items"], "alias": "stg_pokeapi_items", "checksum": {"name": "sha256", "checksum": "e46bd9c827704bf7e5f25bfbc0d9aa5fb2959497a5f1289c95456753665085fd"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.3481667, "relation_name": "\"nerd_facts\".\"public\".\"stg_pokeapi_items\"", "raw_code": "/*\n  Model: stg_pokeapi_items\n  Description: Standardizes Pok\u00e9mon item data from the PokeAPI\n  Source: raw.pokeapi_items\n  \n  Notes:\n  - Effect entries are extracted with language preference for English entries\n  - Categories and attributes are parsed from nested JSON\n  - Item classifications are derived from item attributes and names\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        cost,\n        effect_entries,\n        fling_power,\n        fling_effect,\n        attributes,\n        category,\n        sprite_url\n    FROM raw.pokeapi_items\n    WHERE id IS NOT NULL\n),\n\n-- Extract English effect description when available\neffect_text AS (\n    SELECT\n        id,\n        (\n            -- First try to find an English entry\n            SELECT effect_entry->>'effect'\n            FROM jsonb_array_elements(effect_entries) AS effect_entry\n            WHERE effect_entry->>'language'->>'name' = 'en'\n            LIMIT 1\n        ) AS effect_en,\n        -- Fallback to first entry if no English entry\n        COALESCE(effect_entries->0->>'effect', '') AS effect_fallback\n    FROM raw_data\n)\n\nSELECT\n    -- Primary identifiers\n    r.id,\n    r.name AS item_name,\n    \n    -- Item attributes\n    NULLIF(r.cost, 0)::INTEGER AS purchase_cost,\n    NULLIF(r.fling_power, 0)::INTEGER AS fling_power,\n    r.fling_effect->>'name' AS fling_effect_name,\n    \n    -- Category information\n    r.category->>'name' AS category_name,\n    \n    -- Extract attributes as array for easier querying\n    ARRAY(\n        SELECT jsonb_array_elements_text(r.attributes)\n    ) AS item_attributes,\n    \n    -- Parse effect text with language preference\n    COALESCE(e.effect_en, e.effect_fallback) AS effect_description,\n    \n    -- Sprite URL for visual representation\n    r.sprite_url,\n    \n    -- Derived item classifications\n    CASE\n        WHEN r.category->>'name' = 'healing' OR r.name LIKE '%potion%' OR r.name = 'full-restore' THEN TRUE\n        ELSE FALSE\n    END AS is_healing_item,\n    \n    CASE\n        WHEN r.name LIKE '%ball%' AND r.name != 'black-belt' THEN TRUE\n        ELSE FALSE\n    END AS is_pokeball,\n    \n    CASE\n        WHEN r.category->>'name' = 'battle-items' OR \n             r.name IN ('x-attack', 'x-defense', 'x-speed', 'dire-hit', 'guard-spec') THEN TRUE\n        ELSE FALSE\n    END AS is_battle_item,\n    \n    CASE\n        WHEN r.name LIKE '%tm%' OR r.name LIKE '%technical-machine%' THEN TRUE\n        ELSE FALSE\n    END AS is_tm,\n    \n    CASE\n        WHEN EXISTS (\n            SELECT 1\n            FROM jsonb_array_elements_text(r.attributes) AS attr\n            WHERE attr = 'holdable'\n        ) THEN TRUE\n        ELSE FALSE\n    END AS is_holdable,\n    \n    -- Item tier based on cost and effects\n    CASE\n        WHEN r.cost > 10000 OR r.name LIKE '%master%ball%' THEN 'Ultra Rare'\n        WHEN r.cost > 5000 THEN 'Rare'\n        WHEN r.cost > 1000 THEN 'Uncommon'\n        ELSE 'Common'\n    END AS item_rarity,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data r\nLEFT JOIN effect_text e ON r.id = e.id", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_netrunner_cards": {"database": "nerd_facts", "schema": "public", "name": "stg_netrunner_cards", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/netrunner/stg_netrunner_cards.sql", "original_file_path": "models/staging/netrunner/stg_netrunner_cards.sql", "unique_id": "model.nerd_facts_dbt.stg_netrunner_cards", "fqn": ["nerd_facts_dbt", "staging", "netrunner", "stg_netrunner_cards"], "alias": "stg_netrunner_cards", "checksum": {"name": "sha256", "checksum": "67ca95eb88977b770c4744078cdbfcb60f7eedccd4a22bee4ad007c6ad10658a"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.350006, "relation_name": "\"nerd_facts\".\"public\".\"stg_netrunner_cards\"", "raw_code": "/*\n  Model: stg_netrunner_cards\n  Description: Standardizes Netrunner card data from the raw source with faction and type enrichment\n  Sources:\n    - raw.netrunner_cards (primary)\n    - raw.netrunner_factions (joining for faction names)\n    - raw.netrunner_types (joining for type names)\n  \n  Note: This model combines and replaces the previous stg_netrunner.sql model.\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        code,\n        title,\n        type_code,\n        faction_code,\n        pack_code,\n        position,\n        quantity,\n        unique AS is_unique, -- Renamed to avoid SQL reserved word\n        deck_limit,\n        minimum_deck_size,\n        influence_limit,\n        base_link,\n        cost,\n        faction_cost,\n        flavor,\n        illustrator,\n        influence_cost,\n        keywords,\n        memory_cost,\n        side_code,\n        strength,\n        text,\n        trash_cost,\n        advancement_cost,\n        agenda_points\n    FROM raw.netrunner_cards\n    WHERE code IS NOT NULL -- Ensure we don't include invalid entries\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    code,\n    title AS card_name, -- Standardized naming convention\n    \n    -- Card type & faction metadata with enrichment\n    type_code,\n    t.name AS type_name, -- Added from stg_netrunner.sql\n    faction_code,\n    f.name AS faction_name, -- Added from stg_netrunner.sql\n    side_code,\n    \n    -- Pack information\n    pack_code,\n    position,\n    quantity,\n    \n    -- Card characteristics\n    is_unique, -- Fixed reserved word issue\n    \n    -- Deck-building attributes\n    NULLIF(deck_limit, 0)::INTEGER AS deck_limit, -- Handle zero values\n    NULLIF(minimum_deck_size, 0)::INTEGER AS minimum_deck_size,\n    NULLIF(influence_limit, 0)::INTEGER AS influence_limit,\n    \n    -- Runner-specific attributes\n    NULLIF(base_link, '')::INTEGER AS base_link, -- Convert empty strings to NULL\n    \n    -- Costs & stats\n    CASE\n        WHEN cost = '' THEN NULL\n        WHEN cost = 'X' THEN -1 -- Special case for variable cost\n        ELSE NULLIF(cost, '')::INTEGER\n    END AS cost,\n    \n    NULLIF(faction_cost, 0)::INTEGER AS influence_cost, -- Standardized naming\n    NULLIF(memory_cost, '')::INTEGER AS memory_cost,\n    \n    -- Variable card strength (for ICE and programs)\n    CASE\n        WHEN strength = '' THEN NULL\n        WHEN strength = 'X' THEN -1 -- Special case for variable strength\n        ELSE NULLIF(strength, '')::NUMERIC\n    END AS strength,\n    \n    NULLIF(trash_cost, '')::INTEGER AS trash_cost,\n    \n    -- Agenda stats\n    CASE\n        WHEN advancement_cost IN ('', 'null', 'NaN') THEN NULL\n        ELSE NULLIF(advancement_cost, '')::INTEGER\n    END AS advancement_requirement,\n    \n    CASE\n        WHEN agenda_points IN ('', 'null', 'NaN') THEN NULL\n        ELSE NULLIF(agenda_points, '')::INTEGER\n    END AS agenda_points,\n    \n    -- Card text & art\n    text AS card_text,\n    flavor AS flavor_text,\n    illustrator,\n    \n    -- Parse keywords into array for easier analysis\n    CASE \n        WHEN keywords IS NULL OR keywords = '' THEN NULL\n        ELSE string_to_array(keywords, ' - ')\n    END AS keywords_array,\n    \n    -- Card type flags (from stg_netrunner.sql)\n    CASE WHEN type_code = 'agenda' THEN TRUE ELSE FALSE END AS is_agenda,\n    CASE WHEN type_code = 'ice' THEN TRUE ELSE FALSE END AS is_ice,\n    CASE WHEN type_code = 'identity' THEN TRUE ELSE FALSE END AS is_identity,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data r\nLEFT JOIN raw.netrunner_factions f ON r.faction_code = f.code\nLEFT JOIN raw.netrunner_types t ON r.type_code = t.code", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_netrunner_factions": {"database": "nerd_facts", "schema": "public", "name": "dim_netrunner_factions", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/netrunner/dim_netrunner_factions.sql", "original_file_path": "models/marts/netrunner/dim_netrunner_factions.sql", "unique_id": "model.nerd_facts_dbt.dim_netrunner_factions", "fqn": ["nerd_facts_dbt", "marts", "netrunner", "dim_netrunner_factions"], "alias": "dim_netrunner_factions", "checksum": {"name": "sha256", "checksum": "e7b129b8a11265374a70986ffdc5ce8fbc3afe1e67e25157d9ef05c56659c9de"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742203914.351781, "relation_name": "\"nerd_facts\".\"public\".\"dim_netrunner_factions\"", "raw_code": "/*\n  Model: dim_netrunner_factions\n  Description: Dimension table for Android: Netrunner factions\n  \n  Notes:\n  - Provides comprehensive faction information and classifications\n  - Includes card counts and distributions across types\n  - Adds gameplay style classification and meta position\n  - Contains faction metadata and visual styling attributes\n*/\n\nWITH faction_base AS (\n    SELECT DISTINCT\n        f.faction_code,\n        f.faction_name,\n        f.side_code,\n        f.side_name,\n        f.is_mini AS is_mini_faction,\n        f.color\n    FROM {{ ref('stg_netrunner_factions') }} f\n),\n\ncard_counts AS (\n    SELECT\n        faction_code,\n        COUNT(DISTINCT id) AS num_cards,\n        COUNT(DISTINCT CASE WHEN type_name = 'Identity' THEN id END) AS num_identities,\n        COUNT(DISTINCT CASE WHEN type_name = 'ICE' THEN id END) AS num_ice,\n        COUNT(DISTINCT CASE WHEN type_name = 'Program' AND card_text ILIKE '%Icebreaker%' THEN id END) AS num_icebreakers,\n        COUNT(DISTINCT CASE WHEN type_name = 'Agenda' THEN id END) AS num_agendas,\n        COUNT(DISTINCT CASE WHEN type_name IN ('Event', 'Operation') THEN id END) AS num_events_operations,\n        COUNT(DISTINCT CASE WHEN card_text ILIKE '%gain%credit%' OR \n                              card_text ILIKE '%take%credit%' OR\n                              card_text ILIKE '%credit for each%' THEN id END) AS num_economy_cards,\n        -- Add first release date\n        MIN(p.release_date) AS first_release_date,\n        -- Add most recent card release date\n        MAX(p.release_date) AS latest_release_date\n    FROM {{ ref('stg_netrunner_cards') }} c\n    LEFT JOIN {{ ref('stg_netrunner_packs') }} p ON c.pack_code = p.code\n    GROUP BY faction_code\n)\n\nSELECT\n    -- Generate surrogate key\n    {{ dbt_utils.generate_surrogate_key(['f.faction_code']) }} AS faction_key,\n    \n    -- Primary identifiers\n    f.faction_code,\n    f.faction_name,\n    f.side_code,\n    f.side_name,\n    f.is_mini_faction,\n    f.color,\n    \n    -- Card statistics\n    COALESCE(c.num_cards, 0) AS num_cards,\n    COALESCE(c.num_identities, 0) AS num_identities,\n    COALESCE(c.num_ice, 0) AS num_ice,\n    COALESCE(c.num_icebreakers, 0) AS num_icebreakers,\n    COALESCE(c.num_agendas, 0) AS num_agendas,\n    COALESCE(c.num_events_operations, 0) AS num_events_operations,\n    COALESCE(c.num_economy_cards, 0) AS num_economy_cards,\n    \n    -- Dates\n    c.first_release_date,\n    c.latest_release_date,\n    \n    -- Faction tier based on card count with improved thresholds\n    CASE\n        WHEN COALESCE(c.num_cards, 0) > 120 THEN 'Major'\n        WHEN COALESCE(c.num_cards, 0) > 70 THEN 'Standard'\n        WHEN COALESCE(c.num_cards, 0) > 20 THEN 'Minor'\n        ELSE 'Mini'\n    END AS faction_tier,\n    \n    -- Faction type based on side and characteristics with improved pattern matching\n    CASE\n        WHEN f.side_name = 'Corp' AND f.faction_name ILIKE '%jinteki%' THEN 'Trap Corp'\n        WHEN f.side_name = 'Corp' AND f.faction_name ILIKE '%haas-bioroid%' THEN 'Economy Corp'\n        WHEN f.side_name = 'Corp' AND f.faction_name ILIKE '%nbn%' THEN 'Tag Corp'\n        WHEN f.side_name = 'Corp' AND f.faction_name ILIKE '%weyland%' THEN 'Damage Corp'\n        WHEN f.side_name = 'Runner' AND f.faction_name ILIKE '%anarch%' THEN 'Disruption Runner'\n        WHEN f.side_name = 'Runner' AND f.faction_name ILIKE '%criminal%' THEN 'Economy Runner'\n        WHEN f.side_name = 'Runner' AND f.faction_name ILIKE '%shaper%' THEN 'Rig-Builder Runner'\n        ELSE 'Specialized'\n    END AS play_style,\n    \n    -- Economic strength based on economy card percentage\n    CASE\n        WHEN COALESCE(c.num_cards, 0) = 0 THEN 'Unknown'\n        WHEN COALESCE(c.num_economy_cards, 0) * 100.0 / NULLIF(c.num_cards, 0) >= 20 THEN 'Strong Economy'\n        WHEN COALESCE(c.num_economy_cards, 0) * 100.0 / NULLIF(c.num_cards, 0) >= 15 THEN 'Good Economy'\n        WHEN COALESCE(c.num_economy_cards, 0) * 100.0 / NULLIF(c.num_cards, 0) >= 10 THEN 'Moderate Economy'\n        ELSE 'Weak Economy'\n    END AS economy_strength,\n    \n    -- Iconic identity card for this faction with more comprehensive matching\n    CASE\n        WHEN f.faction_code = 'jinteki' THEN 'Personal Evolution'\n        WHEN f.faction_code = 'haas-bioroid' THEN 'Engineering the Future'\n        WHEN f.faction_code = 'nbn' THEN 'Making News'\n        WHEN f.faction_code = 'weyland-consortium' THEN 'Building a Better World'\n        WHEN f.faction_code = 'anarch' THEN 'Noise'\n        WHEN f.faction_code = 'criminal' THEN 'Gabriel Santiago'\n        WHEN f.faction_code = 'shaper' THEN 'Kate \"Mac\" McCaffrey'\n        WHEN f.faction_code = 'adam' THEN 'Adam: Compulsive Hacker'\n        WHEN f.faction_code = 'apex' THEN 'Apex: Invasive Predator'\n        WHEN f.faction_code = 'sunny-lebeau' THEN 'Sunny Lebeau: Security Specialist'\n        ELSE 'Various'\n    END AS iconic_identity,\n    \n    -- Release wave with expanded categories\n    CASE\n        WHEN f.faction_code IN ('haas-bioroid', 'jinteki', 'nbn', 'weyland-consortium', 'anarch', 'criminal', 'shaper') THEN 'Core Set'\n        WHEN f.faction_code IN ('adam', 'apex', 'sunny-lebeau') THEN 'Data and Destiny'\n        ELSE 'Expansion'\n    END AS release_category,\n    \n    -- Meta position\n    CASE\n        WHEN f.faction_code IN ('nbn', 'haas-bioroid', 'criminal', 'shaper') THEN 'Tier 1'\n        WHEN f.faction_code IN ('jinteki', 'weyland-consortium', 'anarch') THEN 'Tier 2'\n        ELSE 'Tier 3'\n    END AS meta_position,\n    \n    -- CSS classes for styling\n    'faction-' || f.faction_code AS faction_css_class,\n    \n    -- Add hex color code with # prefix if not already present\n    CASE\n        WHEN f.color IS NULL THEN '#000000'  -- Default black\n        WHEN f.color LIKE '#%' THEN f.color\n        ELSE '#' || f.color\n    END AS color_hex,\n    \n    -- Faction abbreviation\n    CASE\n        WHEN f.faction_code = 'haas-bioroid' THEN 'HB'\n        WHEN f.faction_code = 'jinteki' THEN 'J'\n        WHEN f.faction_code = 'nbn' THEN 'NBN'\n        WHEN f.faction_code = 'weyland-consortium' THEN 'W'\n        WHEN f.faction_code = 'anarch' THEN 'A'\n        WHEN f.faction_code = 'criminal' THEN 'C'\n        WHEN f.faction_code = 'shaper' THEN 'S'\n        WHEN f.faction_code = 'adam' THEN 'Adam'\n        WHEN f.faction_code = 'apex' THEN 'Apex'\n        WHEN f.faction_code = 'sunny-lebeau' THEN 'Sunny'\n        ELSE SUBSTRING(f.faction_name, 1, 1)\n    END AS faction_abbr,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM faction_base f\nLEFT JOIN card_counts c ON f.faction_code = c.faction_code\nORDER BY f.side_name, COALESCE(c.num_cards, 0) DESC", "language": "sql", "refs": [{"name": "stg_netrunner_factions", "package": null, "version": null}, {"name": "stg_netrunner_cards", "package": null, "version": null}, {"name": "stg_netrunner_packs", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_netrunner_factions", "model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fact_netrunner_cards": {"database": "nerd_facts", "schema": "public", "name": "fact_netrunner_cards", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/netrunner/fact_netrunner_cards.sql", "original_file_path": "models/marts/netrunner/fact_netrunner_cards.sql", "unique_id": "model.nerd_facts_dbt.fact_netrunner_cards", "fqn": ["nerd_facts_dbt", "marts", "netrunner", "fact_netrunner_cards"], "alias": "fact_netrunner_cards", "checksum": {"name": "sha256", "checksum": "51e22d4ad74e746a0b285227b8311590831051c237752c6b39592dddcc86ca68"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742203914.3569715, "relation_name": "\"nerd_facts\".\"public\".\"fact_netrunner_cards\"", "raw_code": "/*\n  Model: fact_netrunner_cards\n  Description: Fact table for Android: Netrunner cards with metrics and relationships\n  \n  Notes:\n  - Contains key metrics about card usage, efficiency, and value\n  - Links to dimension tables for cards, factions, packs, and types\n  - Includes derived metrics for cards such as cost efficiency and power indices\n  - Provides temporal context through release dates and rotation status\n  - Combines multiple data sources for comprehensive analysis\n*/\n\nWITH card_metrics AS (\n    -- Calculate and derive card-specific metrics\n    SELECT\n        c.code AS card_code,\n        c.id AS card_id,\n        c.card_name,\n        c.faction_code,\n        c.side_code,\n        c.type_name,\n        c.pack_code,\n        \n        -- Core card attributes\n        c.cost,\n        c.strength,\n        c.advancement_requirement,\n        c.agenda_points,\n        c.memory_cost,\n        c.trash_cost,\n        \n        -- Calculate cost efficiency metrics\n        CASE \n            -- For ICE, calculate strength-to-cost ratio\n            WHEN c.type_name = 'ICE' AND c.cost > 0 AND c.strength IS NOT NULL \n            THEN ROUND((c.strength::NUMERIC / c.cost), 2)\n            \n            -- For Agendas, calculate points-to-advancement ratio\n            WHEN c.type_name = 'Agenda' AND c.advancement_requirement > 0 AND c.agenda_points IS NOT NULL\n            THEN ROUND((c.agenda_points::NUMERIC / c.advancement_requirement), 2)\n            \n            -- For Programs/Hardware, basic cost efficiency if applicable\n            WHEN c.type_name IN ('Program', 'Hardware') AND c.cost > 0 AND c.strength IS NOT NULL\n            THEN ROUND((c.strength::NUMERIC / c.cost), 2)\n            \n            ELSE NULL\n        END AS cost_efficiency_ratio,\n        \n        -- Calculate text length (proxy for card complexity)\n        LENGTH(c.card_text) AS text_length,\n        \n        -- Calculate influence efficiency (agenda points or strength per influence)\n        CASE\n            WHEN c.influence_cost > 0 AND c.agenda_points IS NOT NULL\n            THEN ROUND((c.agenda_points::NUMERIC / c.influence_cost), 2)\n            WHEN c.influence_cost > 0 AND c.strength IS NOT NULL\n            THEN ROUND((c.strength::NUMERIC / c.influence_cost), 2)\n            ELSE NULL\n        END AS influence_efficiency,\n        \n        -- Keywords count\n        CASE WHEN c.keywords_array IS NOT NULL \n             THEN ARRAY_LENGTH(c.keywords_array, 1) \n             ELSE 0 \n        END AS keyword_count,\n        \n        -- Reference pack info\n        p.release_date,\n        p.cycle_code,\n        \n        -- Simulated usage data (in a real implementation, this would come from tournament data)\n        -- For demonstration, we'll calculate a \"popularity score\" based on various factors\n        CASE\n            WHEN c.card_name IN ('Account Siphon', 'Desperado', 'SanSan City Grid', \n                              'Astroscript Pilot Program', 'Hedge Fund', 'Sure Gamble') THEN 95\n            WHEN c.pack_code = 'core' AND c.faction_code IS NOT NULL THEN 70  \n            WHEN c.faction_code IS NULL THEN 30  -- Neutral cards often less used\n            WHEN p.cycle_code IN ('genesis', 'creation-and-control') THEN 60\n            WHEN p.release_date IS NULL THEN 20\n            WHEN DATE_PART('year', p.release_date) <= 2014 THEN 65\n            WHEN DATE_PART('year', p.release_date) <= 2016 THEN 50\n            ELSE 40\n        END AS popularity_score\n        \n    FROM {{ ref('stg_netrunner_cards') }} c\n    LEFT JOIN {{ ref('stg_netrunner_packs') }} p ON c.pack_code = p.code\n)\n\nSELECT\n    -- Primary keys and relationships\n    {{ dbt_utils.generate_surrogate_key(['cm.card_code']) }} AS card_fact_key,\n    cm.card_code,\n    cm.card_id,\n    \n    -- Foreign keys to dimension tables\n    {{ dbt_utils.generate_surrogate_key(['cm.card_code']) }} AS card_key,\n    {{ dbt_utils.generate_surrogate_key(['cm.faction_code']) }} AS faction_key,\n    {{ dbt_utils.generate_surrogate_key(['cm.pack_code']) }} AS pack_key,\n    {{ dbt_utils.generate_surrogate_key(['cm.side_code', 'cm.type_name']) }} AS card_type_key,\n    \n    -- Essential card attributes \n    cm.card_name,\n    cm.faction_code,\n    cm.side_code,\n    cm.type_name,\n    cm.pack_code,\n    \n    -- Core card metrics\n    COALESCE(cm.cost, 0) AS cost,\n    COALESCE(cm.strength, 0) AS strength,\n    COALESCE(cm.advancement_requirement, 0) AS advancement_requirement,\n    COALESCE(cm.agenda_points, 0) AS agenda_points,\n    COALESCE(cm.memory_cost, 0) AS memory_cost,\n    COALESCE(cm.trash_cost, 0) AS trash_cost,\n    \n    -- Calculated metrics\n    cm.cost_efficiency_ratio,\n    cm.text_length AS complexity_score,\n    cm.influence_efficiency,\n    cm.keyword_count,\n    \n    -- Usage and popularity metrics\n    cm.popularity_score,\n    CASE\n        WHEN cm.popularity_score >= 80 THEN 'Meta Defining'\n        WHEN cm.popularity_score >= 60 THEN 'Staple'\n        WHEN cm.popularity_score >= 40 THEN 'Playable'\n        ELSE 'Niche'\n    END AS popularity_tier,\n    \n    -- Deck construction significance\n    CASE\n        WHEN cm.card_name IN ('Hedge Fund', 'Sure Gamble', 'IPO', 'Dirty Laundry') THEN 'Auto-include'\n        WHEN cm.popularity_score >= 75 THEN 'High Impact'\n        WHEN cm.popularity_score >= 50 THEN 'Medium Impact'\n        ELSE 'Low Impact'\n    END AS deck_impact,\n    \n    -- Time dimensions\n    cm.release_date,\n    cm.cycle_code,\n    CASE \n        WHEN cm.cycle_code IN ('core', 'genesis', 'creation-and-control', 'spin') THEN 'First Rotation'\n        WHEN cm.cycle_code IN ('lunar', 'order-and-chaos', 'sansan', 'mumbad') THEN 'Second Rotation'\n        ELSE 'Current'\n    END AS rotation_group,\n    \n    -- Card pool status (current as of 2025)\n    CASE\n        WHEN cm.cycle_code IN ('core', 'genesis', 'creation-and-control', 'spin', \n                           'lunar', 'order-and-chaos', 'sansan', 'mumbad',\n                           'flashpoint', 'red-sand') THEN 'Rotated'\n        WHEN cm.cycle_code IN ('terminal-directive', 'core2', 'kitara', 'reign-and-reverie') THEN 'Standard'\n        WHEN cm.cycle_code IS NULL THEN 'Unknown'\n        ELSE 'Standard'\n    END AS card_pool_status,\n    \n    -- Card value index (composite score)\n    ROUND(\n        (COALESCE(cm.popularity_score, 0) * 0.6) + \n        (COALESCE(cm.cost_efficiency_ratio, 0) * 20) +\n        (CASE WHEN cm.type_name = 'Identity' THEN 30 ELSE 0 END) +\n        (CASE WHEN cm.card_name IN ('Account Siphon', 'Astroscript Pilot Program', 'Jackson Howard') THEN 40 ELSE 0 END)\n    ) AS card_value_index,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n\nFROM card_metrics cm", "language": "sql", "refs": [{"name": "stg_netrunner_cards", "package": null, "version": null}, {"name": "stg_netrunner_packs", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_pokemon_types": {"database": "nerd_facts", "schema": "public", "name": "dim_pokemon_types", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/dim_pokemon_types.sql", "original_file_path": "models/marts/pokemon/dim_pokemon_types.sql", "unique_id": "model.nerd_facts_dbt.dim_pokemon_types", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "dim_pokemon_types"], "alias": "dim_pokemon_types", "checksum": {"name": "sha256", "checksum": "208405dba8c0b6d4094fa29c98afdf46633a0908ee877decd126525843fc69fa"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "type_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["type_id"]}, {"columns": ["type_name"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["type_id"]}, {"columns": ["type_name"]}], "unique_key": "type_id"}, "created_at": 1742203914.3642223, "relation_name": "\"nerd_facts\".\"public\".\"dim_pokemon_types\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['type_id']}, {'columns': ['type_name']}],\n    unique_key = 'type_id'\n  )\n}}\n\n/*\n  Model: dim_pokemon_types\n  Description: Dimension table for Pok\u00e9mon types and their effectiveness relationships\n  \n  Notes:\n  - Contains comprehensive type effectiveness data (weaknesses, resistances, immunities)\n  - Includes type distribution metrics across the Pok\u00e9dex\n  - Provides visual attributes for UI presentation\n  - Calculates offensive and defensive ratings\n  - Adds type categorization and generation data\n*/\n\nWITH type_counts AS (\n    -- Get primary type usage\n    SELECT\n        COALESCE(primary_type, 'Unknown') AS type_name,\n        COUNT(*) AS num_primary\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    GROUP BY primary_type\n),\n\nsecondary_type_counts AS (\n    -- Get secondary type usage\n    SELECT \n        COALESCE(secondary_type, 'None') AS type_name,\n        COUNT(*) AS num_secondary\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    WHERE secondary_type IS NOT NULL\n    GROUP BY secondary_type\n),\n\ncombined_counts AS (\n    -- Combine primary and secondary counts\n    SELECT\n        t.type_name,\n        t.num_primary,\n        COALESCE(s.num_secondary, 0) AS num_secondary,\n        t.num_primary + COALESCE(s.num_secondary, 0) AS total_usage\n    FROM type_counts t\n    LEFT JOIN secondary_type_counts s ON t.type_name = s.type_name\n),\n\n-- Comprehensive type effectiveness data with separate immunities\ntype_attributes AS (\n    SELECT\n        type_name,\n        -- Weaknesses (takes 2x damage from these types)\n        CASE\n            WHEN type_name = 'Normal' THEN ARRAY['Fighting']\n            WHEN type_name = 'Fire' THEN ARRAY['Water', 'Ground', 'Rock']\n            WHEN type_name = 'Water' THEN ARRAY['Electric', 'Grass']\n            WHEN type_name = 'Electric' THEN ARRAY['Ground']\n            WHEN type_name = 'Grass' THEN ARRAY['Fire', 'Ice', 'Poison', 'Flying', 'Bug']\n            WHEN type_name = 'Ice' THEN ARRAY['Fire', 'Fighting', 'Rock', 'Steel']\n            WHEN type_name = 'Fighting' THEN ARRAY['Flying', 'Psychic', 'Fairy']\n            WHEN type_name = 'Poison' THEN ARRAY['Ground', 'Psychic']\n            WHEN type_name = 'Ground' THEN ARRAY['Water', 'Grass', 'Ice']\n            WHEN type_name = 'Flying' THEN ARRAY['Electric', 'Ice', 'Rock']\n            WHEN type_name = 'Psychic' THEN ARRAY['Bug', 'Ghost', 'Dark']\n            WHEN type_name = 'Bug' THEN ARRAY['Fire', 'Flying', 'Rock']\n            WHEN type_name = 'Rock' THEN ARRAY['Water', 'Grass', 'Fighting', 'Ground', 'Steel']\n            WHEN type_name = 'Ghost' THEN ARRAY['Ghost', 'Dark']\n            WHEN type_name = 'Dragon' THEN ARRAY['Ice', 'Dragon', 'Fairy']\n            WHEN type_name = 'Dark' THEN ARRAY['Fighting', 'Bug', 'Fairy']\n            WHEN type_name = 'Steel' THEN ARRAY['Fire', 'Fighting', 'Ground']\n            WHEN type_name = 'Fairy' THEN ARRAY['Poison', 'Steel']\n            ELSE ARRAY[]::VARCHAR[]\n        END AS weaknesses,\n        \n        -- Resistances (takes 0.5x damage from these types)\n        CASE\n            WHEN type_name = 'Normal' THEN ARRAY[]\n            WHEN type_name = 'Fire' THEN ARRAY['Fire', 'Grass', 'Ice', 'Bug', 'Steel', 'Fairy']\n            WHEN type_name = 'Water' THEN ARRAY['Fire', 'Water', 'Ice', 'Steel']\n            WHEN type_name = 'Electric' THEN ARRAY['Electric', 'Flying', 'Steel']\n            WHEN type_name = 'Grass' THEN ARRAY['Water', 'Electric', 'Grass', 'Ground']\n            WHEN type_name = 'Ice' THEN ARRAY['Ice']\n            WHEN type_name = 'Fighting' THEN ARRAY['Bug', 'Rock', 'Dark']\n            WHEN type_name = 'Poison' THEN ARRAY['Grass', 'Fighting', 'Poison', 'Bug', 'Fairy']\n            WHEN type_name = 'Ground' THEN ARRAY['Poison', 'Rock']\n            WHEN type_name = 'Flying' THEN ARRAY['Grass', 'Fighting', 'Bug']\n            WHEN type_name = 'Psychic' THEN ARRAY['Fighting', 'Psychic']\n            WHEN type_name = 'Bug' THEN ARRAY['Grass', 'Fighting', 'Ground']\n            WHEN type_name = 'Rock' THEN ARRAY['Normal', 'Fire', 'Poison', 'Flying']\n            WHEN type_name = 'Ghost' THEN ARRAY['Poison', 'Bug']  -- Fixed: Ghost resists Bug and Poison\n            WHEN type_name = 'Dragon' THEN ARRAY['Fire', 'Water', 'Electric', 'Grass']\n            WHEN type_name = 'Dark' THEN ARRAY['Ghost', 'Dark']\n            WHEN type_name = 'Steel' THEN ARRAY['Normal', 'Grass', 'Ice', 'Flying', 'Psychic', 'Bug', 'Rock', 'Dragon', 'Steel', 'Fairy']\n            WHEN type_name = 'Fairy' THEN ARRAY['Fighting', 'Bug', 'Dark']\n            ELSE ARRAY[]::VARCHAR[]\n        END AS resistances,\n        \n        -- Immunities (takes 0x damage from these types)\n        CASE\n            WHEN type_name = 'Normal' THEN ARRAY['Ghost']\n            WHEN type_name = 'Flying' THEN ARRAY['Ground']\n            WHEN type_name = 'Ground' THEN ARRAY['Electric']\n            WHEN type_name = 'Ghost' THEN ARRAY['Normal', 'Fighting']\n            WHEN type_name = 'Dark' THEN ARRAY['Psychic']\n            WHEN type_name = 'Fairy' THEN ARRAY['Dragon']\n            WHEN type_name = 'Steel' THEN ARRAY['Poison']\n            ELSE ARRAY[]::VARCHAR[]\n        END AS immunities,\n        \n        -- Super effective against (deals 2x damage to these types)\n        CASE\n            WHEN type_name = 'Normal' THEN ARRAY[]\n            WHEN type_name = 'Fire' THEN ARRAY['Grass', 'Ice', 'Bug', 'Steel']\n            WHEN type_name = 'Water' THEN ARRAY['Fire', 'Ground', 'Rock']\n            WHEN type_name = 'Electric' THEN ARRAY['Water', 'Flying']\n            WHEN type_name = 'Grass' THEN ARRAY['Water', 'Ground', 'Rock']\n            WHEN type_name = 'Ice' THEN ARRAY['Grass', 'Ground', 'Flying', 'Dragon']\n            WHEN type_name = 'Fighting' THEN ARRAY['Normal', 'Ice', 'Rock', 'Dark', 'Steel']\n            WHEN type_name = 'Poison' THEN ARRAY['Grass', 'Fairy']\n            WHEN type_name = 'Ground' THEN ARRAY['Fire', 'Electric', 'Poison', 'Rock', 'Steel']\n            WHEN type_name = 'Flying' THEN ARRAY['Grass', 'Fighting', 'Bug']\n            WHEN type_name = 'Psychic' THEN ARRAY['Fighting', 'Poison']\n            WHEN type_name = 'Bug' THEN ARRAY['Grass', 'Psychic', 'Dark']\n            WHEN type_name = 'Rock' THEN ARRAY['Fire', 'Ice', 'Flying', 'Bug']\n            WHEN type_name = 'Ghost' THEN ARRAY['Psychic', 'Ghost']\n            WHEN type_name = 'Dragon' THEN ARRAY['Dragon']\n            WHEN type_name = 'Dark' THEN ARRAY['Psychic', 'Ghost']\n            WHEN type_name = 'Steel' THEN ARRAY['Ice', 'Rock', 'Fairy']\n            WHEN type_name = 'Fairy' THEN ARRAY['Fighting', 'Dragon', 'Dark']\n            ELSE ARRAY[]::VARCHAR[]\n        END AS super_effective,\n        \n        -- Type compatibility (works well defensively with these types)\n        CASE\n            WHEN type_name = 'Normal' THEN ARRAY['Ghost', 'Rock', 'Steel']\n            WHEN type_name = 'Fire' THEN ARRAY['Water', 'Rock', 'Dragon']\n            WHEN type_name = 'Water' THEN ARRAY['Fire', 'Ground', 'Flying']\n            WHEN type_name = 'Electric' THEN ARRAY['Flying', 'Steel', 'Fairy']\n            WHEN type_name = 'Grass' THEN ARRAY['Poison', 'Flying', 'Bug']\n            WHEN type_name = 'Ice' THEN ARRAY['Steel', 'Fire', 'Water']\n            WHEN type_name = 'Fighting' THEN ARRAY['Flying', 'Psychic', 'Fairy']\n            WHEN type_name = 'Poison' THEN ARRAY['Ground', 'Ghost', 'Steel']\n            WHEN type_name = 'Ground' THEN ARRAY['Flying', 'Bug', 'Grass']\n            WHEN type_name = 'Flying' THEN ARRAY['Steel', 'Electric', 'Rock']\n            WHEN type_name = 'Psychic' THEN ARRAY['Steel', 'Dark', 'Normal']\n            WHEN type_name = 'Bug' THEN ARRAY['Flying', 'Steel', 'Fire']\n            WHEN type_name = 'Rock' THEN ARRAY['Fighting', 'Ground', 'Steel']\n            WHEN type_name = 'Ghost' THEN ARRAY['Dark', 'Normal', 'Poison']\n            WHEN type_name = 'Dragon' THEN ARRAY['Steel', 'Fairy']\n            WHEN type_name = 'Dark' THEN ARRAY['Fighting', 'Fairy', 'Bug']\n            WHEN type_name = 'Steel' THEN ARRAY['Fire', 'Electric', 'Water']\n            WHEN type_name = 'Fairy' THEN ARRAY['Poison', 'Steel', 'Fire']\n            ELSE ARRAY[]::VARCHAR[]\n        END AS defensive_synergy\n    FROM combined_counts\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['c.type_name']) }} AS type_key,\n    ROW_NUMBER() OVER (ORDER BY c.type_name) AS type_id,\n    \n    -- Core attributes\n    c.type_name,\n    c.num_primary,\n    c.num_secondary,\n    c.total_usage,\n    \n    -- Type effectiveness data\n    a.weaknesses,\n    a.resistances,\n    a.immunities,\n    a.super_effective,\n    \n    -- Defensive synergy types\n    a.defensive_synergy,\n    \n    -- Calculated metrics\n    COALESCE(ARRAY_LENGTH(a.weaknesses, 1), 0) AS weakness_count,\n    COALESCE(ARRAY_LENGTH(a.resistances, 1), 0) AS resistance_count,\n    COALESCE(ARRAY_LENGTH(a.immunities, 1), 0) AS immunity_count,\n    COALESCE(ARRAY_LENGTH(a.super_effective, 1), 0) AS super_effective_count,\n    \n    -- Type color (for UI)\n    CASE\n        WHEN c.type_name = 'Normal' THEN '#A8A77A'\n        WHEN c.type_name = 'Fire' THEN '#EE8130'\n        WHEN c.type_name = 'Water' THEN '#6390F0'\n        WHEN c.type_name = 'Electric' THEN '#F7D02C'\n        WHEN c.type_name = 'Grass' THEN '#7AC74C'\n        WHEN c.type_name = 'Ice' THEN '#96D9D6'\n        WHEN c.type_name = 'Fighting' THEN '#C22E28'\n        WHEN c.type_name = 'Poison' THEN '#A33EA1'\n        WHEN c.type_name = 'Ground' THEN '#E2BF65'\n        WHEN c.type_name = 'Flying' THEN '#A98FF3'\n        WHEN c.type_name = 'Psychic' THEN '#F95587'\n        WHEN c.type_name = 'Bug' THEN '#A6B91A'\n        WHEN c.type_name = 'Rock' THEN '#B6A136'\n        WHEN c.type_name = 'Ghost' THEN '#735797'\n        WHEN c.type_name = 'Dragon' THEN '#6F35FC'\n        WHEN c.type_name = 'Dark' THEN '#705746'\n        WHEN c.type_name = 'Steel' THEN '#B7B7CE'\n        WHEN c.type_name = 'Fairy' THEN '#D685AD'\n        ELSE '#CCCCCC'\n    END AS type_color,\n    \n    -- Type category - expanded with better organization\n    CASE\n        WHEN c.type_name IN ('Fire', 'Water', 'Electric') THEN 'Primary Elemental'\n        WHEN c.type_name IN ('Grass', 'Ice') THEN 'Secondary Elemental'\n        WHEN c.type_name IN ('Fighting', 'Rock', 'Ground') THEN 'Physical'\n        WHEN c.type_name IN ('Poison', 'Flying', 'Bug') THEN 'Biological'\n        WHEN c.type_name IN ('Psychic', 'Ghost', 'Dark', 'Fairy') THEN 'Special'\n        WHEN c.type_name IN ('Normal') THEN 'Normal'\n        WHEN c.type_name IN ('Dragon', 'Steel') THEN 'Advanced'\n        ELSE 'Other'\n    END AS type_category,\n    \n    -- Type attack classification\n    CASE\n        WHEN c.type_name IN ('Fire', 'Water', 'Electric', 'Grass', 'Ice', \n                           'Psychic', 'Dragon', 'Dark', 'Fairy') THEN 'Special'\n        ELSE 'Physical'\n    END AS damage_category,\n    \n    -- Generation introduced\n    CASE\n        WHEN c.type_name IN ('Normal', 'Fire', 'Water', 'Electric', 'Grass', 'Ice', \n                            'Fighting', 'Poison', 'Ground', 'Flying', 'Psychic', 'Bug', \n                            'Rock', 'Ghost', 'Dragon') THEN 1\n        WHEN c.type_name IN ('Dark', 'Steel') THEN 2\n        WHEN c.type_name IN ('Fairy') THEN 6\n        ELSE 1\n    END AS generation_introduced,\n    \n    -- Offensive usefulness rating (1-10)\n    CASE\n        WHEN c.type_name IN ('Ground', 'Fighting', 'Fire') THEN 9  -- Excellent coverage\n        WHEN c.type_name IN ('Ice', 'Electric', 'Rock', 'Flying', 'Fairy', 'Ghost', 'Dark') THEN 8  -- Great coverage\n        WHEN c.type_name IN ('Grass', 'Dragon', 'Steel', 'Water', 'Psychic') THEN 7  -- Good coverage\n        WHEN c.type_name IN ('Poison', 'Bug') THEN 5  -- Limited coverage\n        WHEN c.type_name IN ('Normal') THEN 3  -- Poor coverage\n        ELSE 6\n    END AS offensive_rating,\n    \n    -- Defensive usefulness rating (1-10)\n    CASE\n        WHEN c.type_name IN ('Steel', 'Fairy') THEN 10  -- Excellent defenses\n        WHEN c.type_name IN ('Ghost', 'Water', 'Normal', 'Dragon') THEN 8  -- Great defenses\n        WHEN c.type_name IN ('Fire', 'Flying', 'Dark', 'Poison', 'Ground') THEN 7  -- Good defenses\n        WHEN c.type_name IN ('Electric', 'Fighting', 'Psychic', 'Rock') THEN 5  -- Average defenses\n        WHEN c.type_name IN ('Grass', 'Bug', 'Ice') THEN 3  -- Poor defenses\n        ELSE 6\n    END AS defensive_rating,\n    \n    -- Type value calculated across multiple factors\n    (\n        COALESCE(ARRAY_LENGTH(a.resistances, 1), 0) * 5 +\n        COALESCE(ARRAY_LENGTH(a.immunities, 1), 0) * 10 -\n        COALESCE(ARRAY_LENGTH(a.weaknesses, 1), 0) * 5 +\n        COALESCE(ARRAY_LENGTH(a.super_effective, 1), 0) * 3\n    ) AS composite_value_score,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM combined_counts c\nJOIN type_attributes a ON c.type_name = a.type_name\nORDER BY c.type_name", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_pokemon": {"database": "nerd_facts", "schema": "public", "name": "fct_pokemon", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/fct_pokemon.sql", "original_file_path": "models/marts/pokemon/fct_pokemon.sql", "unique_id": "model.nerd_facts_dbt.fct_pokemon", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "fct_pokemon"], "alias": "fct_pokemon", "checksum": {"name": "sha256", "checksum": "d45f1adc7adbe6c4ddf6f1375c969cbcc8764cddfd366eb0ca68dbd04d05363b"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "pokemon_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["primary_type", "secondary_type"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["primary_type", "secondary_type"]}], "unique_key": "pokemon_key"}, "created_at": 1742203914.3699946, "relation_name": "\"nerd_facts\".\"public\".\"fct_pokemon\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['pokemon_id']}, {'columns': ['primary_type', 'secondary_type']}],\n    unique_key = 'pokemon_key'\n  )\n}}\n\n/*\n  Model: fct_pokemon\n  Description: Core fact table for Pok\u00e9mon data with comprehensive attributes and classifications\n  \n  Notes:\n  - Contains essential information about each Pok\u00e9mon species\n  - Links to all related dimension tables (types, abilities, moves, etc.)\n  - Provides both source fields and derived/calculated metrics\n  - Includes generation, evolutionary, and classification data\n  - Serves as the central entity for all Pok\u00e9mon analysis\n*/\n\nWITH base_pokemon AS (\n    SELECT\n        id AS pokemon_id,\n        name AS pokemon_name,\n        primary_type,\n        secondary_type,\n        generation_number,\n        is_legendary,\n        is_mythical,\n        height,\n        weight,\n        base_xp,\n        abilities,\n        moves,\n        base_stat_hp,\n        base_stat_attack,\n        base_stat_defense,\n        base_stat_special_attack,\n        base_stat_special_defense,\n        base_stat_speed,\n        total_base_stats,\n        capture_rate,\n        base_happiness,\n        evolution_chain_id,\n        species_id\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    WHERE id IS NOT NULL\n),\n\n-- Count abilities and moves for each Pok\u00e9mon\nattribute_counts AS (\n    SELECT\n        pokemon_id,\n        COALESCE(JSONB_ARRAY_LENGTH(abilities), 0) AS ability_count,\n        COALESCE(JSONB_ARRAY_LENGTH(moves), 0) AS move_count\n    FROM base_pokemon\n),\n\n-- Determine popularity tier based on known popular Pok\u00e9mon\npopularity AS (\n    SELECT\n        pokemon_id,\n        CASE\n            -- Gen 1 popular starters and mascots\n            WHEN LOWER(pokemon_name) IN ('pikachu', 'charizard', 'bulbasaur', 'squirtle', 'eevee', \n                                     'mew', 'mewtwo', 'snorlax', 'gengar', 'gyarados') THEN 'S'\n            \n            -- Other highly recognizable Pok\u00e9mon\n            WHEN LOWER(pokemon_name) IN ('lucario', 'garchomp', 'greninja', 'blaziken', 'gardevoir', \n                                     'rayquaza', 'dragonite', 'jigglypuff', 'mimikyu', 'umbreon', \n                                     'sylveon', 'metagross') THEN 'A'\n            \n            -- Well-known but less iconic\n            WHEN LOWER(pokemon_name) IN ('arcanine', 'tyranitar', 'salamence', 'infernape', 'hydreigon',\n                                     'volcarona', 'arceus', 'suicune', 'absol', 'darkrai',\n                                     'blastoise', 'venusaur') THEN 'B'\n                                     \n            -- Pok\u00e9mon featured prominently in anime/movies\n            WHEN LOWER(pokemon_name) IN ('lugia', 'ho-oh', 'celebi', 'jirachi', 'latios', 'latias',\n                                     'dialga', 'palkia', 'giratina', 'zoroark', 'victini',\n                                     'zekrom', 'reshiram', 'keldeo', 'genesect') THEN 'B'\n            \n            -- Legendary status boost\n            WHEN is_legendary = TRUE THEN 'B'\n            WHEN is_mythical = TRUE THEN 'B'\n            \n            -- Generation popularity bias\n            WHEN generation_number = 1 THEN 'C'  -- Original 151 are generally popular\n            WHEN generation_number = 2 THEN 'C'\n            WHEN generation_number = 3 THEN 'C'\n            WHEN generation_number = 4 THEN 'D'\n            WHEN generation_number = 5 THEN 'D'\n            WHEN generation_number = 6 THEN 'D'\n            WHEN generation_number >= 7 THEN 'C'  -- Newer generations get attention\n            \n            -- Default popularity tier\n            ELSE 'E'\n        END AS popularity_tier\n    FROM base_pokemon\n),\n\n-- Evolution chain data\nevolution_data AS (\n    SELECT \n        pokemon_id,\n        CASE\n            -- Special case handling for popular evolution chains\n            WHEN pokemon_name IN ('Bulbasaur', 'Charmander', 'Squirtle', 'Chikorita', 'Cyndaquil', 'Totodile',\n                                'Treecko', 'Torchic', 'Mudkip', 'Turtwig', 'Chimchar', 'Piplup', 'Rowlet', \n                                'Litten', 'Popplio', 'Grookey', 'Scorbunny', 'Sobble', 'Pichu', 'Cleffa', \n                                'Igglybuff', 'Togepi', 'Eevee') THEN 'Basic'\n                                \n            WHEN pokemon_name IN ('Ivysaur', 'Charmeleon', 'Wartortle', 'Bayleef', 'Quilava', 'Croconaw',\n                                'Grovyle', 'Combusken', 'Marshtomp', 'Grotle', 'Monferno', 'Prinplup',\n                                'Dartrix', 'Torracat', 'Brionne', 'Thwackey', 'Raboot', 'Drizzile',\n                                'Pikachu', 'Clefairy', 'Jigglypuff', 'Togetic') THEN 'Stage 1'\n                                \n            WHEN pokemon_name IN ('Venusaur', 'Charizard', 'Blastoise', 'Meganium', 'Typhlosion', 'Feraligatr',\n                                'Sceptile', 'Blaziken', 'Swampert', 'Torterra', 'Infernape', 'Empoleon',\n                                'Decidueye', 'Incineroar', 'Primarina', 'Rillaboom', 'Cinderace', 'Inteleon',\n                                'Raichu', 'Clefable', 'Wigglytuff', 'Togekiss') THEN 'Stage 2'\n                                \n            -- Legendary and mythical Pok\u00e9mon\n            WHEN is_legendary = TRUE OR is_mythical = TRUE THEN 'Legendary/Mythical'\n            \n            -- Basic determination using stats\n            WHEN total_base_stats < 350 THEN 'Basic'\n            WHEN total_base_stats < 470 THEN 'Stage 1'\n            ELSE 'Stage 2'\n        END AS evolution_stage\n    FROM base_pokemon\n)\n\nSELECT\n    -- Primary and foreign keys\n    {{ dbt_utils.generate_surrogate_key(['bp.pokemon_id']) }} AS pokemon_key,\n    bp.pokemon_id,\n    {{ dbt_utils.generate_surrogate_key(['bp.primary_type']) }} AS primary_type_key,\n    {{ dbt_utils.generate_surrogate_key(['bp.secondary_type']) }} AS secondary_type_key,\n    \n    -- Core identifiers\n    bp.pokemon_name,\n    bp.primary_type,\n    bp.secondary_type,\n    \n    -- Physical attributes with data validation\n    COALESCE(bp.height, 0) AS height_m,\n    COALESCE(bp.weight, 0) AS weight_kg,\n    CASE \n        WHEN bp.height > 0 AND bp.weight > 0 \n        THEN ROUND(bp.weight / (bp.height * bp.height), 2)\n        ELSE NULL\n    END AS weight_height_ratio,\n    \n    -- Stats with proper handling\n    COALESCE(bp.base_stat_hp, 0) AS hp,\n    COALESCE(bp.base_stat_attack, 0) AS attack,\n    COALESCE(bp.base_stat_defense, 0) AS defense,\n    COALESCE(bp.base_stat_special_attack, 0) AS special_attack,\n    COALESCE(bp.base_stat_special_defense, 0) AS special_defense,\n    COALESCE(bp.base_stat_speed, 0) AS speed,\n    COALESCE(bp.total_base_stats, 0) AS total_stats,\n    \n    -- Attribute counts\n    COALESCE(ac.ability_count, 0) AS ability_count,\n    COALESCE(ac.move_count, 0) AS move_count,\n    \n    -- Categorical classifications\n    bp.generation_number,\n    COALESCE(bp.is_legendary, FALSE) AS is_legendary,\n    COALESCE(bp.is_mythical, FALSE) AS is_mythical,\n    \n    -- Gameplay attributes\n    bp.base_xp,\n    COALESCE(bp.capture_rate, 0) AS capture_rate,\n    COALESCE(bp.base_happiness, 0) AS base_happiness,\n    bp.evolution_chain_id,\n    bp.species_id,\n    \n    -- Derived evolutionary data\n    ed.evolution_stage,\n    \n    -- Enhanced classifications\n    CASE\n        WHEN bp.is_legendary THEN 'Legendary'\n        WHEN bp.is_mythical THEN 'Mythical'\n        WHEN ed.evolution_stage = 'Stage 2' THEN 'Fully Evolved'\n        WHEN ed.evolution_stage = 'Stage 1' THEN 'Mid Evolution'\n        WHEN ed.evolution_stage = 'Basic' THEN 'Basic Form'\n        ELSE 'Unknown'\n    END AS pokemon_class,\n    \n    -- Stat-based classifications\n    CASE\n        WHEN bp.total_base_stats >= 600 THEN 'Pseudo-Legendary'\n        WHEN bp.total_base_stats >= 500 THEN 'Strong'\n        WHEN bp.total_base_stats >= 400 THEN 'Average'\n        WHEN bp.total_base_stats >= 300 THEN 'Basic'\n        ELSE 'Weak'\n    END AS strength_tier,\n    \n    -- Battle role classification\n    CASE\n        WHEN bp.base_stat_speed >= 100 AND \n             (bp.base_stat_attack >= 100 OR bp.base_stat_special_attack >= 100) THEN 'Fast Attacker'\n        WHEN bp.base_stat_hp >= 100 AND \n             (bp.base_stat_defense >= 100 OR bp.base_stat_special_defense >= 100) THEN 'Tank'\n        WHEN bp.base_stat_attack >= 120 THEN 'Physical Sweeper'\n        WHEN bp.base_stat_special_attack >= 120 THEN 'Special Sweeper'\n        WHEN bp.base_stat_defense >= 120 THEN 'Physical Wall'\n        WHEN bp.base_stat_special_defense >= 120 THEN 'Special Wall'\n        WHEN bp.base_stat_hp >= 120 THEN 'Bulky'\n        WHEN bp.base_stat_speed >= 120 THEN 'Speedy'\n        WHEN (bp.base_stat_attack + bp.base_stat_special_attack) > \n             (bp.base_stat_defense + bp.base_stat_special_defense) THEN 'Offensive'\n        WHEN (bp.base_stat_defense + bp.base_stat_special_defense) > \n             (bp.base_stat_attack + bp.base_stat_special_attack) THEN 'Defensive'\n        ELSE 'Balanced'\n    END AS battle_style,\n    \n    -- Popularity data\n    p.popularity_tier,\n    CASE \n        WHEN p.popularity_tier = 'S' THEN 'Mascot/Icon'\n        WHEN p.popularity_tier = 'A' THEN 'Fan Favorite'\n        WHEN p.popularity_tier = 'B' THEN 'Popular'\n        WHEN p.popularity_tier = 'C' THEN 'Well Known'\n        WHEN p.popularity_tier = 'D' THEN 'Recognized'\n        ELSE 'Standard'\n    END AS popularity_class,\n    \n    -- Calculated metrics\n    ROUND((bp.base_stat_attack + bp.base_stat_special_attack) / \n          NULLIF((bp.base_stat_defense + bp.base_stat_special_defense), 0), 2) AS offense_defense_ratio,\n    \n    CASE\n        WHEN bp.base_stat_attack > bp.base_stat_special_attack THEN 'Physical'\n        WHEN bp.base_stat_special_attack > bp.base_stat_attack THEN 'Special'\n        ELSE 'Mixed'\n    END AS attack_bias,\n    \n    -- Stat distribution percentages\n    ROUND(100.0 * bp.base_stat_hp / NULLIF(bp.total_base_stats, 0), 1) AS hp_percent,\n    ROUND(100.0 * (bp.base_stat_attack + bp.base_stat_special_attack) / NULLIF(bp.total_base_stats, 0), 1) AS attack_percent,\n    ROUND(100.0 * (bp.base_stat_defense + bp.base_stat_special_defense) / NULLIF(bp.total_base_stats, 0), 1) AS defense_percent,\n    ROUND(100.0 * bp.base_stat_speed / NULLIF(bp.total_base_stats, 0), 1) AS speed_percent,\n    \n    -- Data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n\nFROM base_pokemon bp\nJOIN attribute_counts ac ON bp.pokemon_id = ac.pokemon_id\nJOIN popularity p ON bp.pokemon_id = p.pokemon_id\nJOIN evolution_data ed ON bp.pokemon_id = ed.pokemon_id\nWHERE bp.pokemon_id IS NOT NULL\nORDER BY bp.total_base_stats DESC", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_starships": {"database": "nerd_facts", "schema": "public", "name": "fct_starships", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/fct_starships.sql", "original_file_path": "models/marts/star_wars/fct_starships.sql", "unique_id": "model.nerd_facts_dbt.fct_starships", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "fct_starships"], "alias": "fct_starships", "checksum": {"name": "sha256", "checksum": "ea8e51942cab061cc0677962d279d845772735c2ca0cfd1c7c4ecf402f77a2b6"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "starship_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["starship_id"]}, {"columns": ["starship_class"]}, {"columns": ["hyperspace_rating"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["starship_id"]}, {"columns": ["starship_class"]}, {"columns": ["hyperspace_rating"]}], "unique_key": "starship_key"}, "created_at": 1742203914.3766887, "relation_name": "\"nerd_facts\".\"public\".\"fct_starships\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['starship_id']}, {'columns': ['starship_class']}, {'columns': ['hyperspace_rating']}],\n    unique_key = 'starship_key'\n  )\n}}\n\n/*\n  Model: fct_starships\n  Description: Fact table for Star Wars starships with comprehensive metrics and classifications\n  \n  Notes:\n  - Contains detailed specifications and performance metrics for all starships\n  - Adds derived attributes for battle capabilities, economic analysis, and technical specifications\n  - Includes hyperdrive performance and crew efficiency calculations\n  - Connects to related dimension tables for pilots, manufacturers, and classes\n  - Provides context for starship roles within the Star Wars universe\n*/\n\nWITH starships AS (\n    SELECT\n        id AS starship_id,\n        name AS starship_name,\n        model,\n        manufacturer,\n        NULLIF(cost_in_credits, 'unknown')::NUMERIC AS cost_in_credits,\n        NULLIF(length, 'unknown')::NUMERIC AS length_m,\n        NULLIF(max_atmosphering_speed, 'unknown')::NUMERIC AS max_atmosphering_speed,\n        NULLIF(crew, 'unknown')::NUMERIC AS crew_count,\n        NULLIF(passengers, 'unknown')::NUMERIC AS passenger_count,\n        NULLIF(cargo_capacity, 'unknown')::NUMERIC AS cargo_capacity,\n        consumables,\n        NULLIF(hyperdrive_rating, 'unknown')::NUMERIC AS hyperdrive_rating,\n        NULLIF(MGLT, 'unknown')::NUMERIC AS MGLT,\n        starship_class,\n        pilots,\n        films\n    FROM {{ ref('stg_swapi_starships') }}\n    WHERE id IS NOT NULL\n),\n\n-- Calculate the number of pilots and films for each starship\nstarship_relationships AS (\n    SELECT\n        starship_id,\n        COALESCE(JSONB_ARRAY_LENGTH(pilots), 0) AS pilot_count,\n        COALESCE(JSONB_ARRAY_LENGTH(films), 0) AS film_appearance_count\n    FROM starships\n),\n\n-- Calculate derived metrics for each starship\nstarship_metrics AS (\n    SELECT\n        s.*,\n        sr.pilot_count,\n        sr.film_appearance_count,\n        \n        -- Calculate crew efficiency (passengers per crew member)\n        CASE\n            WHEN s.crew_count > 0 THEN ROUND(s.passenger_count::NUMERIC / s.crew_count, 2)\n            ELSE 0\n        END AS passengers_per_crew,\n        \n        -- Calculate cargo efficiency (cargo capacity per meter of length)\n        CASE\n            WHEN s.length_m > 0 THEN ROUND(s.cargo_capacity::NUMERIC / s.length_m, 2)\n            ELSE 0\n        END AS cargo_efficiency,\n        \n        -- Calculate hyperdrive performance score (lower is better, invert for intuitive scoring)\n        CASE\n            WHEN s.hyperdrive_rating > 0 THEN ROUND(100 / s.hyperdrive_rating, 1)\n            ELSE 0\n        END AS hyperdrive_performance_score,\n        \n        -- Calculate overall effectiveness score (0-100)\n        CASE\n            WHEN s.starship_class IS NOT NULL THEN\n                GREATEST(0, LEAST(100,\n                    -- Base score\n                    50 +\n                    -- Speed bonus\n                    CASE\n                        WHEN s.MGLT IS NOT NULL AND s.MGLT > 0 THEN LEAST(20, s.MGLT / 5)\n                        WHEN s.max_atmosphering_speed > 1000 THEN 10\n                        ELSE 0\n                    END +\n                    -- Hyperdrive bonus (lower rating is better)\n                    CASE\n                        WHEN s.hyperdrive_rating IS NOT NULL AND s.hyperdrive_rating > 0 THEN\n                            CASE\n                                WHEN s.hyperdrive_rating <= 1 THEN 20\n                                WHEN s.hyperdrive_rating <= 2 THEN 10\n                                ELSE 0\n                            END\n                        ELSE 0\n                    END +\n                    -- Size bonus for large combat ships\n                    CASE\n                        WHEN s.length_m > 1000 AND s.starship_class IN (\n                            'Star Destroyer', 'Dreadnought', 'Battlecruiser', 'Star Dreadnought'\n                        ) THEN 20\n                        WHEN s.length_m > 500 THEN 10\n                        ELSE 0\n                    END +\n                    -- Cargo capacity bonus\n                    CASE\n                        WHEN s.cargo_capacity > 1000000 THEN 10\n                        ELSE 0\n                    END +\n                    -- Famous starship bonus\n                    CASE\n                        WHEN LOWER(s.starship_name) IN (\n                            'millennium falcon', 'death star', 'executor', 'slave 1', \n                            'star destroyer', 'tantive iv', 'x-wing', 'tie fighter'\n                        ) THEN 15\n                        ELSE 0\n                    END\n                ))\n            ELSE 50\n        END AS effectiveness_score\n    FROM starships s\n    JOIN starship_relationships sr ON s.starship_id = sr.starship_id\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['sm.starship_id']) }} AS starship_key,\n    \n    -- Core identifiers\n    sm.starship_id,\n    sm.starship_name,\n    sm.model,\n    sm.manufacturer,\n    \n    -- Classification\n    sm.starship_class,\n    \n    -- Converted hyperspace rating to classification\n    CASE\n        WHEN sm.hyperdrive_rating IS NULL THEN 'Unknown'\n        WHEN sm.hyperdrive_rating <= 0.5 THEN 'Ultra Fast'\n        WHEN sm.hyperdrive_rating <= 1.0 THEN 'Very Fast'\n        WHEN sm.hyperdrive_rating <= 2.0 THEN 'Fast'\n        WHEN sm.hyperdrive_rating <= 3.0 THEN 'Average'\n        WHEN sm.hyperdrive_rating <= 4.0 THEN 'Slow'\n        ELSE 'Very Slow'\n    END AS hyperspace_rating,\n    \n    -- Faction affiliation based on model and name\n    CASE\n        WHEN LOWER(sm.starship_name) LIKE '%imperial%' OR \n             LOWER(sm.model) LIKE '%imperial%' OR \n             LOWER(sm.starship_name) LIKE '%tie%' OR\n             LOWER(sm.starship_name) = 'executor' OR\n             LOWER(sm.starship_name) = 'death star' THEN 'Imperial'\n        \n        WHEN LOWER(sm.starship_name) LIKE '%republic%' OR \n             LOWER(sm.model) LIKE '%republic%' OR \n             LOWER(sm.starship_name) LIKE '%naboo%' OR\n             LOWER(sm.manufacturer) LIKE '%republic%' OR\n             LOWER(sm.starship_name) = 'jedi starfighter' THEN 'Republic'\n        \n        WHEN LOWER(sm.starship_name) LIKE '%rebel%' OR \n             LOWER(sm.model) LIKE '%rebel%' OR\n             LOWER(sm.starship_name) LIKE '%x-wing%' OR\n             LOWER(sm.starship_name) LIKE '%y-wing%' OR\n             LOWER(sm.starship_name) LIKE '%a-wing%' OR\n             LOWER(sm.starship_name) LIKE '%b-wing%' OR\n             LOWER(sm.starship_name) = 'millennium falcon' OR\n             LOWER(sm.starship_name) = 'tantive iv' THEN 'Rebel Alliance/Resistance'\n             \n        WHEN LOWER(sm.starship_name) LIKE '%trade federation%' OR\n             LOWER(sm.model) LIKE '%federation%' OR\n             LOWER(sm.starship_name) LIKE '%separatist%' OR\n             LOWER(sm.manufacturer) LIKE '%techno union%' THEN 'Separatist/Trade Federation'\n             \n        WHEN LOWER(sm.starship_name) LIKE '%first order%' OR\n             LOWER(sm.model) LIKE '%first order%' THEN 'First Order'\n             \n        WHEN LOWER(sm.starship_name) = 'slave 1' OR\n             LOWER(sm.starship_name) LIKE '%firespray%' THEN 'Bounty Hunter'\n             \n        ELSE 'Civilian/Neutral'\n    END AS faction_affiliation,\n    \n    -- Physical specifications with proper handling\n    COALESCE(sm.length_m, 0) AS length_m,\n    COALESCE(sm.max_atmosphering_speed, 0) AS max_atmosphering_speed,\n    COALESCE(sm.MGLT, 0) AS MGLT,\n    COALESCE(sm.hyperdrive_rating, 0) AS hyperdrive_rating,\n    \n    -- Cost information\n    COALESCE(sm.cost_in_credits, 0) AS cost_in_credits,\n    \n    -- Format costs in a readable way\n    CASE\n        WHEN sm.cost_in_credits >= 1000000000 THEN TRIM(TO_CHAR(sm.cost_in_credits/1000000000.0, '999,999,990.99')) || ' billion credits'\n        WHEN sm.cost_in_credits >= 1000000 THEN TRIM(TO_CHAR(sm.cost_in_credits/1000000.0, '999,999,990.99')) || ' million credits'\n        WHEN sm.cost_in_credits >= 1000 THEN TRIM(TO_CHAR(sm.cost_in_credits/1000.0, '999,999,990.99')) || ' thousand credits'\n        WHEN sm.cost_in_credits IS NOT NULL THEN TRIM(TO_CHAR(sm.cost_in_credits, '999,999,999,999')) || ' credits'\n        ELSE 'unknown'\n    END AS cost_formatted,\n    \n    -- Value classification\n    CASE\n        WHEN sm.cost_in_credits IS NULL THEN 'Unknown'\n        WHEN sm.cost_in_credits >= 1000000000 THEN 'Capital Investment'\n        WHEN sm.cost_in_credits >= 100000000 THEN 'Military Grade'\n        WHEN sm.cost_in_credits >= 10000000 THEN 'Very Expensive'\n        WHEN sm.cost_in_credits >= 1000000 THEN 'Expensive'\n        WHEN sm.cost_in_credits >= 100000 THEN 'Moderate'\n        ELSE 'Affordable'\n    END AS cost_category,\n    \n    -- Capacity information\n    COALESCE(sm.crew_count, 0) AS crew_count,\n    COALESCE(sm.passenger_count, 0) AS passenger_count,\n    COALESCE(sm.crew_count, 0) + COALESCE(sm.passenger_count, 0) AS total_capacity,\n    COALESCE(sm.cargo_capacity, 0) AS cargo_capacity,\n    \n    -- Format cargo in a readable way\n    CASE\n        WHEN sm.cargo_capacity >= 1000000000 THEN TRIM(TO_CHAR(sm.cargo_capacity/1000000000.0, '999,999,990.99')) || ' million tons'\n        WHEN sm.cargo_capacity >= 1000000 THEN TRIM(TO_CHAR(sm.cargo_capacity/1000000.0, '999,999,990.99')) || ' tons'\n        WHEN sm.cargo_capacity >= 1000 THEN TRIM(TO_CHAR(sm.cargo_capacity/1000.0, '999,999,990.99')) || ' kg'\n        WHEN sm.cargo_capacity IS NOT NULL THEN TRIM(TO_CHAR(sm.cargo_capacity, '999,999,999,999')) || ' kg'\n        ELSE 'unknown'\n    END AS cargo_capacity_formatted,\n    \n    -- Consumables duration\n    sm.consumables,\n    \n    -- Derived metrics\n    sm.passengers_per_crew,\n    sm.cargo_efficiency,\n    sm.hyperdrive_performance_score,\n    sm.effectiveness_score,\n    \n    -- Iconic starship flag with comprehensive list\n    CASE\n        WHEN LOWER(sm.starship_name) IN (\n            'millennium falcon', 'death star', 'executor', 'slave 1', \n            'star destroyer', 'tantive iv', 'tie fighter', 'x-wing',\n            'y-wing', 'a-wing', 'b-wing', 'tie interceptor', 'tie bomber',\n            'super star destroyer', 'invisible hand', 'trade federation cruiser',\n            'jedi starfighter', 'naboo royal starship', 'radiant vii',\n            'arc-170', 'venator-class star destroyer', 'v-wing',\n            'nebulon-b frigate', 'cr90 corvette', 'mon calamari cruiser',\n            'republic attack cruiser', 'theta-class t-2c shuttle',\n            'republic cruiser', 'sith infiltrator', 'solar sailer',\n            'droid control ship', 'h-type nubian yacht'\n        ) THEN TRUE\n        ELSE FALSE\n    END AS is_iconic,\n    \n    -- Role classification\n    CASE\n        WHEN sm.starship_class LIKE '%fighter%' OR \n             sm.starship_class LIKE '%interceptor%' THEN 'Combat - Fighter'\n        WHEN sm.starship_class LIKE '%destroyer%' OR \n             sm.starship_class LIKE '%cruiser%' OR\n             sm.starship_class LIKE '%battleship%' OR\n             sm.starship_class LIKE '%dreadnought%' THEN 'Combat - Capital Ship'\n        WHEN sm.starship_class LIKE '%bomber%' THEN 'Combat - Bomber'\n        WHEN sm.starship_class LIKE '%transport%' THEN 'Transport'\n        WHEN sm.starship_class LIKE '%shuttle%' OR \n             sm.starship_class LIKE '%yacht%' OR\n             sm.starship_class LIKE '%pleasure craft%' THEN 'Personal/Diplomatic'\n        WHEN sm.starship_class LIKE '%freighter%' THEN 'Cargo'\n        WHEN sm.starship_class LIKE '%station%' OR \n             sm.starship_name LIKE '%death star%' THEN 'Battle Station'\n        ELSE 'Multi-purpose'\n    END AS starship_role,\n    \n    -- Size classification\n    CASE\n        WHEN sm.length_m IS NULL THEN 'Unknown'\n        WHEN sm.length_m > 10000 THEN 'Massive (Station)'\n        WHEN sm.length_m > 1000 THEN 'Huge (Capital Ship)'\n        WHEN sm.length_m > 500 THEN 'Very Large'\n        WHEN sm.length_m > 100 THEN 'Large'\n        WHEN sm.length_m > 50 THEN 'Medium'\n        WHEN sm.length_m > 20 THEN 'Small'\n        ELSE 'Tiny'\n    END AS size_class,\n    \n    -- Era classification\n    CASE\n        WHEN LOWER(sm.starship_name) LIKE '%republic%' OR\n             LOWER(sm.model) LIKE '%republic%' OR\n             LOWER(sm.starship_name) LIKE '%naboo%' OR\n             LOWER(sm.starship_name) LIKE '%jedi starfighter%' OR\n             LOWER(sm.starship_name) LIKE '%droid%' THEN 'Prequel Era (Clone Wars)'\n             \n        WHEN LOWER(sm.starship_name) LIKE '%imperial%' OR\n             LOWER(sm.model) LIKE '%imperial%' OR\n             LOWER(sm.starship_name) LIKE '%tie%' OR\n             LOWER(sm.starship_name) = 'executor' OR\n             LOWER(sm.starship_name) = 'death star' OR\n             LOWER(sm.starship_name) LIKE '%x-wing%' OR \n             LOWER(sm.starship_name) LIKE '%y-wing%' OR\n             LOWER(sm.starship_name) LIKE '%a-wing%' OR\n             LOWER(sm.starship_name) LIKE '%b-wing%' OR\n             LOWER(sm.starship_name) = 'millennium falcon' THEN 'Original Trilogy Era (Galactic Civil War)'\n             \n        WHEN LOWER(sm.starship_name) LIKE '%first order%' OR\n             LOWER(sm.model) LIKE '%first order%' THEN 'Sequel Era (First Order Conflict)'\n             \n        ELSE 'Multiple Eras/Unspecified'\n    END AS starship_era,\n    \n    -- Relationship counts\n    sm.pilot_count,\n    sm.film_appearance_count,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM starship_metrics sm\nORDER BY sm.effectiveness_score DESC, sm.starship_name", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_pokeapi_pokemon": {"database": "nerd_facts", "schema": "public", "name": "stg_pokeapi_pokemon", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/pokeapi/stg_pokeapi_pokemon.sql", "original_file_path": "models/staging/pokeapi/stg_pokeapi_pokemon.sql", "unique_id": "model.nerd_facts_dbt.stg_pokeapi_pokemon", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "stg_pokeapi_pokemon"], "alias": "stg_pokeapi_pokemon", "checksum": {"name": "sha256", "checksum": "30a099b8b5130e2bc59183ce70ef9974f2fb51bdf47d06dccd78ee1b9ffffdaf"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.4006937, "relation_name": "\"nerd_facts\".\"public\".\"stg_pokeapi_pokemon\"", "raw_code": "/*\n  Model: stg_pokeapi_pokemon\n  Description: Standardizes Pok\u00e9mon data from the PokeAPI\n  Source: raw.pokeapi_pokemon\n  \n  Notes:\n  - Type information is extracted from nested JSON structure\n  - Region is derived from Pok\u00e9mon ID ranges where not directly available\n  - Stats are extracted from the nested stats array\n  - Physical attributes are converted to standard units (kg, dm)\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        height,\n        weight,\n        base_experience,\n        types,\n        stats,\n        abilities,\n        moves,\n        region,  -- Assuming this field exists in your enriched data\n        is_legendary,\n        is_mythical,\n        species,\n        generation\n    FROM raw.pokeapi_pokemon\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name,\n    \n    -- Extract primary type (first type in the array)\n    CASE \n        WHEN types IS NULL OR jsonb_array_length(types) = 0 THEN 'Unknown'\n        ELSE COALESCE(types->0->>'type'->>'name', 'Unknown')\n    END AS primary_type,\n    \n    -- Extract all types as an array with error handling\n    CASE\n        WHEN types IS NULL THEN ARRAY['Unknown']::VARCHAR[]\n        ELSE ARRAY(\n            SELECT COALESCE(jsonb_array_elements(types)->>'type'->>'name', 'Unknown')\n            WHERE jsonb_typeof(types) = 'array'\n        )\n    END AS types,\n    \n    -- Extract region with more comprehensive generation mapping\n    COALESCE(region, \n             CASE \n                 WHEN id <= 151 THEN 'Kanto'      -- Gen 1\n                 WHEN id <= 251 THEN 'Johto'      -- Gen 2\n                 WHEN id <= 386 THEN 'Hoenn'      -- Gen 3\n                 WHEN id <= 493 THEN 'Sinnoh'     -- Gen 4\n                 WHEN id <= 649 THEN 'Unova'      -- Gen 5\n                 WHEN id <= 721 THEN 'Kalos'      -- Gen 6\n                 WHEN id <= 809 THEN 'Alola'      -- Gen 7\n                 WHEN id <= 898 THEN 'Galar'      -- Gen 8\n                 WHEN id <= 1008 THEN 'Paldea'    -- Gen 9\n                 ELSE 'Unknown'\n             END) AS region,\n    \n    -- Extract generation number for easier filtering\n    CASE\n        WHEN id <= 151 THEN 1\n        WHEN id <= 251 THEN 2\n        WHEN id <= 386 THEN 3\n        WHEN id <= 493 THEN 4\n        WHEN id <= 649 THEN 5\n        WHEN id <= 721 THEN 6\n        WHEN id <= 809 THEN 7\n        WHEN id <= 898 THEN 8\n        WHEN id <= 1008 THEN 9\n        ELSE NULL\n    END AS generation_number,\n    \n    -- Physical attributes with unit conversions\n    COALESCE(CAST(height AS NUMERIC), 0) AS height,           -- In decimeters\n    COALESCE(CAST(weight AS NUMERIC) / 10, 0) AS weight,      -- Convert to kg\n    \n    -- Calculate BMI (weight in kg / height in meters squared)\n    CASE\n        WHEN COALESCE(height, 0) > 0 \n        THEN ROUND((COALESCE(weight, 0) * 10) / POWER(height, 2), 1)\n        ELSE NULL\n    END AS bmi,\n    \n    -- Experience and rarity\n    COALESCE(base_experience, 0) AS base_xp,\n    COALESCE(is_legendary, FALSE) AS is_legendary,\n    COALESCE(is_mythical, FALSE) AS is_mythical,\n    \n    -- Base stats with proper null handling\n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'hp'\n              LIMIT 1), 0) AS base_stat_hp,\n    \n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'attack'\n              LIMIT 1), 0) AS base_stat_attack,\n    \n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'defense'\n              LIMIT 1), 0) AS base_stat_defense,\n    \n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'special-attack'\n              LIMIT 1), 0) AS base_stat_special_attack,\n    \n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'special-defense'\n              LIMIT 1), 0) AS base_stat_special_defense,\n    \n    COALESCE((SELECT (value->>'base_stat')::integer \n              FROM jsonb_array_elements(stats) \n              WHERE value->>'stat'->>'name' = 'speed'\n              LIMIT 1), 0) AS base_stat_speed,\n    \n    -- Total base stats - useful for power comparisons\n    (\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'hp' LIMIT 1), 0) +\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'attack' LIMIT 1), 0) +\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'defense' LIMIT 1), 0) +\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'special-attack' LIMIT 1), 0) +\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'special-defense' LIMIT 1), 0) +\n        COALESCE((SELECT (value->>'base_stat')::integer FROM jsonb_array_elements(stats) WHERE value->>'stat'->>'name' = 'speed' LIMIT 1), 0)\n    ) AS total_base_stats,\n    \n    -- Extract abilities as structured data\n    abilities,\n    \n    -- Count the number of abilities and moves\n    COALESCE(jsonb_array_length(abilities), 0) AS ability_count,\n    COALESCE(jsonb_array_length(moves), 0) AS move_count,\n    \n    -- Starter Pok\u00e9mon flag\n    CASE\n        WHEN name IN ('bulbasaur', 'charmander', 'squirtle', \n                      'chikorita', 'cyndaquil', 'totodile',\n                      'treecko', 'torchic', 'mudkip',\n                      'turtwig', 'chimchar', 'piplup',\n                      'snivy', 'tepig', 'oshawott',\n                      'chespin', 'fennekin', 'froakie',\n                      'rowlet', 'litten', 'popplio',\n                      'grookey', 'scorbunny', 'sobble') THEN TRUE\n        ELSE FALSE\n    END AS is_starter,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_pokemon_stats": {"database": "nerd_facts", "schema": "public", "name": "fct_pokemon_stats", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/pokemon/fct_pokemon_stats.sql", "original_file_path": "models/marts/pokemon/fct_pokemon_stats.sql", "unique_id": "model.nerd_facts_dbt.fct_pokemon_stats", "fqn": ["nerd_facts_dbt", "marts", "pokemon", "fct_pokemon_stats"], "alias": "fct_pokemon_stats", "checksum": {"name": "sha256", "checksum": "b26028cd2e0e69bd325bad41e114f00d3fa1d1d68f6c78125ccb02a3f12a0df6"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "pokemon_stat_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["primary_type"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["pokemon_id"]}, {"columns": ["primary_type"]}], "unique_key": "pokemon_stat_id"}, "created_at": 1742203914.405021, "relation_name": "\"nerd_facts\".\"public\".\"fct_pokemon_stats\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['pokemon_id']}, {'columns': ['primary_type']}],\n    unique_key = 'pokemon_stat_id'\n  )\n}}\n\n/*\n  Model: fct_pokemon_stats\n  Description: Fact table for Pok\u00e9mon statistics and battle metrics\n  \n  Notes:\n  - Contains comprehensive stat analysis for all Pok\u00e9mon\n  - Calculates evolutionary stage and progression metrics\n  - Includes battle effectiveness calculations and classifications\n  - Provides stat distribution analysis and percentile rankings\n  - Links to dimension tables for Pok\u00e9mon and types\n*/\n\nWITH base_pokemon AS (\n    SELECT\n        id,\n        name,\n        primary_type,\n        secondary_type,\n        generation_number,\n        is_legendary,\n        is_mythical,\n        height,\n        weight,\n        base_xp,\n        -- Include all base stats\n        base_stat_hp,\n        base_stat_attack,\n        base_stat_defense,\n        base_stat_special_attack,\n        base_stat_special_defense,\n        base_stat_speed,\n        total_base_stats,\n        capture_rate,\n        base_happiness,\n        evolution_chain_id\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    WHERE id IS NOT NULL\n),\n\n-- Calculate stat percentiles across all Pok\u00e9mon\nstat_percentiles AS (\n    SELECT\n        id,\n        PERCENT_RANK() OVER (ORDER BY base_stat_hp) AS hp_percentile,\n        PERCENT_RANK() OVER (ORDER BY base_stat_attack) AS attack_percentile,\n        PERCENT_RANK() OVER (ORDER BY base_stat_defense) AS defense_percentile,\n        PERCENT_RANK() OVER (ORDER BY base_stat_special_attack) AS sp_attack_percentile,\n        PERCENT_RANK() OVER (ORDER BY base_stat_special_defense) AS sp_defense_percentile,\n        PERCENT_RANK() OVER (ORDER BY base_stat_speed) AS speed_percentile,\n        PERCENT_RANK() OVER (ORDER BY total_base_stats) AS total_stats_percentile\n    FROM base_pokemon\n),\n\n-- Improved evolutionary stage determination\nevolution_stage AS (\n    SELECT\n        bp.id,\n        CASE\n            -- Use evolution chain data if available and reliable\n            WHEN bp.evolution_chain_id IS NOT NULL THEN\n                CASE\n                    -- Known starter Pok\u00e9mon evolution patterns\n                    WHEN bp.name IN ('Bulbasaur', 'Charmander', 'Squirtle', 'Chikorita', \n                                    'Cyndaquil', 'Totodile', 'Treecko', 'Torchic', \n                                    'Mudkip', 'Turtwig', 'Chimchar', 'Piplup') THEN 1\n                    WHEN bp.name IN ('Ivysaur', 'Charmeleon', 'Wartortle', 'Bayleef', \n                                    'Quilava', 'Croconaw', 'Grovyle', 'Combusken',\n                                    'Marshtomp', 'Grotle', 'Monferno', 'Prinplup') THEN 2\n                    WHEN bp.name IN ('Venusaur', 'Charizard', 'Blastoise', 'Meganium',\n                                    'Typhlosion', 'Feraligatr', 'Sceptile', 'Blaziken',\n                                    'Swampert', 'Torterra', 'Infernape', 'Empoleon') THEN 3\n                                    \n                    -- Legendaries and Mythicals are typically final forms\n                    WHEN bp.is_legendary = TRUE OR bp.is_mythical = TRUE THEN 3\n                    \n                    -- Use base stats as a proxy for evolution stage\n                    WHEN bp.total_base_stats < 350 THEN 1  -- Basic form\n                    WHEN bp.total_base_stats < 470 THEN 2  -- First evolution\n                    ELSE 3  -- Final evolution\n                END\n            ELSE\n                -- Fallback if no evolution chain data\n                CASE\n                    WHEN bp.total_base_stats < 350 THEN 1  -- Basic form\n                    WHEN bp.total_base_stats < 470 THEN 2  -- First evolution\n                    ELSE 3  -- Final evolution\n                END\n        END AS evolution_level\n    FROM base_pokemon bp\n),\n\n-- Enhanced battle metrics with improved calculations\nbattle_metrics AS (\n    SELECT\n        p.id,\n        -- Calculate victories with expanded logic\n        CASE \n            -- Legendaries and mythicals\n            WHEN p.is_legendary OR p.is_mythical THEN \n                20 + FLOOR(p.total_base_stats / 100)\n                \n            -- Well-known powerful Pok\u00e9mon\n            WHEN LOWER(p.name) IN ('mewtwo', 'dragonite', 'tyranitar', 'salamence', 'garchomp',\n                                'volcarona', 'hydreigon', 'dragapult', 'heatran', 'chansey',\n                                'blissey', 'snorlax', 'ferrothorn', 'toxapex', 'gliscor',\n                                'landorus', 'thundurus', 'tornadus', 'rotom-wash') THEN \n                15 + FLOOR(p.total_base_stats / 150)\n                \n            -- Popular starters and favorites\n            WHEN LOWER(p.name) IN ('charizard', 'blastoise', 'venusaur', 'gyarados', \n                                'arcanine', 'gengar', 'alakazam', 'lucario', 'togekiss',\n                                'gardevoir', 'metagross', 'scizor', 'excadrill', 'sylveon') THEN \n                10 + FLOOR(p.total_base_stats / 200)\n                \n            -- Base formula for other Pok\u00e9mon with enhanced factors\n            ELSE \n                GREATEST(\n                    FLOOR(\n                        (COALESCE(p.base_xp, 100) / 60) + \n                        (COALESCE(p.total_base_stats, 300) / 100) + \n                        e.evolution_level + \n                        (CASE WHEN p.generation_number <= 3 THEN 2 ELSE 0 END)  -- Bonus for older generations\n                    ),\n                    1  -- Minimum 1 victory\n                )\n        END AS estimated_victories,\n        \n        -- Enhanced combat classification with more nuanced roles\n        CASE\n            -- Special sweeper\n            WHEN p.base_stat_special_attack > 110 AND p.base_stat_speed >= 90 THEN 'Special Sweeper'\n            \n            -- Physical sweeper\n            WHEN p.base_stat_attack > 110 AND p.base_stat_speed >= 90 THEN 'Physical Sweeper'\n            \n            -- Special wall\n            WHEN p.base_stat_special_defense > 110 AND p.base_stat_hp >= 80 THEN 'Special Wall'\n            \n            -- Physical wall\n            WHEN p.base_stat_defense > 110 AND p.base_stat_hp >= 80 THEN 'Physical Wall'\n            \n            -- All-around tank\n            WHEN p.base_stat_defense > 90 AND p.base_stat_special_defense > 90 AND p.base_stat_hp >= 80 THEN 'Tank'\n            \n            -- Support/utility\n            WHEN p.base_stat_hp > 90 AND p.base_stat_speed > 70 AND \n                 p.base_stat_attack < 80 AND p.base_stat_special_attack < 80 THEN 'Support'\n            \n            -- Fast attacker\n            WHEN p.base_stat_speed > 100 THEN 'Fast Attacker'\n            \n            -- Physical attacker\n            WHEN p.base_stat_attack > p.base_stat_special_attack + 20 THEN 'Physical Attacker'\n            \n            -- Special attacker\n            WHEN p.base_stat_special_attack > p.base_stat_attack + 20 THEN 'Special Attacker'\n            \n            -- Bulky attacker\n            WHEN (p.base_stat_attack > 90 OR p.base_stat_special_attack > 90) AND p.base_stat_hp > 80 THEN 'Bulky Attacker'\n            \n            -- Default balanced\n            ELSE 'Balanced'\n        END AS battle_role,\n        \n        -- Offensive/defensive balance on a scale\n        CASE\n            WHEN (p.base_stat_attack + p.base_stat_special_attack) > \n                 (p.base_stat_defense + p.base_stat_special_defense + p.base_stat_hp) * 1.5 THEN 'Extremely Offensive'\n            WHEN (p.base_stat_attack + p.base_stat_special_attack) > \n                 (p.base_stat_defense + p.base_stat_special_defense + p.base_stat_hp) * 1.2 THEN 'Offensive'\n            WHEN (p.base_stat_defense + p.base_stat_special_defense + p.base_stat_hp) > \n                 (p.base_stat_attack + p.base_stat_special_attack) * 1.5 THEN 'Extremely Defensive'\n            WHEN (p.base_stat_defense + p.base_stat_special_defense + p.base_stat_hp) > \n                 (p.base_stat_attack + p.base_stat_special_attack) * 1.2 THEN 'Defensive'\n            ELSE 'Balanced'\n        END AS offensive_defensive_balance,\n        \n        -- Attack style preference\n        CASE \n            WHEN p.base_stat_attack > p.base_stat_special_attack * 1.5 THEN 'Strongly Physical'\n            WHEN p.base_stat_attack > p.base_stat_special_attack * 1.2 THEN 'Physical'\n            WHEN p.base_stat_special_attack > p.base_stat_attack * 1.5 THEN 'Strongly Special'\n            WHEN p.base_stat_special_attack > p.base_stat_attack * 1.2 THEN 'Special'\n            ELSE 'Mixed'\n        END AS attack_style\n    FROM base_pokemon p\n    JOIN evolution_stage e ON p.id = e.id\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['bp.id']) }} AS pokemon_stat_id,\n    \n    -- Foreign keys\n    {{ dbt_utils.generate_surrogate_key(['bp.id']) }} AS pokemon_key,\n    {{ dbt_utils.generate_surrogate_key(['bp.primary_type']) }} AS primary_type_key,\n    {{ dbt_utils.generate_surrogate_key(['bp.secondary_type']) }} AS secondary_type_key,\n    \n    -- Core identifiers\n    bp.id AS pokemon_id,\n    bp.name AS pokemon_name,\n    bp.primary_type,\n    bp.secondary_type,\n    \n    -- Physical attributes\n    bp.height,\n    bp.weight,\n    ROUND(bp.weight / NULLIF(POWER(bp.height, 2), 0), 2) AS bmi,  -- Body Mass Index equivalent\n    \n    -- Basic stats\n    bp.base_stat_hp,\n    bp.base_stat_attack,\n    bp.base_stat_defense,\n    bp.base_stat_special_attack,\n    bp.base_stat_special_defense,\n    bp.base_stat_speed,\n    bp.total_base_stats,\n    \n    -- Stat percentiles for comparative analysis\n    ROUND(sp.hp_percentile * 100) AS hp_percentile,\n    ROUND(sp.attack_percentile * 100) AS attack_percentile,\n    ROUND(sp.defense_percentile * 100) AS defense_percentile,\n    ROUND(sp.sp_attack_percentile * 100) AS sp_attack_percentile,\n    ROUND(sp.sp_defense_percentile * 100) AS sp_defense_percentile,\n    ROUND(sp.speed_percentile * 100) AS speed_percentile,\n    ROUND(sp.total_stats_percentile * 100) AS total_stats_percentile,\n    \n    -- Statistical tier based on total stats\n    CASE\n        WHEN sp.total_stats_percentile >= 0.95 THEN 'S+'  -- Top 5%\n        WHEN sp.total_stats_percentile >= 0.90 THEN 'S'   -- Top 10%\n        WHEN sp.total_stats_percentile >= 0.80 THEN 'A+'  -- Top 20%\n        WHEN sp.total_stats_percentile >= 0.70 THEN 'A'   -- Top 30%\n        WHEN sp.total_stats_percentile >= 0.60 THEN 'B+'  -- Top 40%\n        WHEN sp.total_stats_percentile >= 0.50 THEN 'B'   -- Top 50%\n        WHEN sp.total_stats_percentile >= 0.35 THEN 'C'   -- Top 65%\n        WHEN sp.total_stats_percentile >= 0.20 THEN 'D'   -- Top 80%\n        ELSE 'E'                                         -- Bottom 20%\n    END AS stat_tier,\n    \n    -- Evolutionary data\n    es.evolution_level,\n    bp.evolution_chain_id,\n    \n    -- Battle metrics\n    bm.estimated_victories,\n    bm.battle_role,\n    bm.offensive_defensive_balance,\n    bm.attack_style,\n    \n    -- Enhanced type effectiveness\n    CASE \n        WHEN bp.primary_type IN ('Steel', 'Ghost', 'Fairy') OR \n             bp.secondary_type IN ('Steel', 'Ghost', 'Fairy') THEN 'High'\n        WHEN bp.primary_type IN ('Dragon', 'Dark', 'Water', 'Flying') OR \n             bp.secondary_type IN ('Dragon', 'Dark', 'Water', 'Flying') THEN 'Medium'\n        ELSE 'Standard'\n    END AS defensive_typing_quality,\n    \n    -- Stat distribution\n    ROUND(bp.base_stat_hp::NUMERIC / NULLIF(bp.total_base_stats, 0) * 100, 1) AS hp_percentage,\n    ROUND((bp.base_stat_attack + bp.base_stat_special_attack)::NUMERIC / NULLIF(bp.total_base_stats, 0) * 100, 1) AS offensive_percentage,\n    ROUND((bp.base_stat_defense + bp.base_stat_special_defense)::NUMERIC / NULLIF(bp.total_base_stats, 0) * 100, 1) AS defensive_percentage,\n    ROUND(bp.base_stat_speed::NUMERIC / NULLIF(bp.total_base_stats, 0) * 100, 1) AS speed_percentage,\n    \n    -- Win rate calculation with enhanced logic\n    CASE\n        WHEN bp.is_legendary OR bp.is_mythical THEN \n            GREATEST(LEAST(0.7 + (sp.total_stats_percentile * 0.25), 0.98), 0.7)  -- 70-98%\n        WHEN bm.estimated_victories > 10 THEN\n            GREATEST(LEAST(0.5 + (bm.estimated_victories / 40.0), 0.9), 0.5)  -- 50-90%\n        WHEN sp.total_stats_percentile > 0.8 THEN \n            GREATEST(LEAST(0.6 + (sp.total_stats_percentile * 0.2), 0.85), 0.6)  -- 60-85%\n        ELSE \n            GREATEST(LEAST(0.4 + (sp.total_stats_percentile * 0.3), 0.7), 0.4)  -- 40-70%\n    END AS estimated_win_rate,\n    \n    -- Additional pokemon attributes\n    bp.base_xp,\n    bp.capture_rate,\n    bp.base_happiness,\n    bp.generation_number,\n    bp.is_legendary,\n    bp.is_mythical,\n    \n    -- Competitive viability score (1-100)\n    GREATEST(LEAST(\n        (bp.total_base_stats / 7) +  -- Up to ~85 points from stats\n        (CASE WHEN bp.is_legendary OR bp.is_mythical THEN 10 ELSE 0 END) +  -- Legendary bonus\n        (CASE WHEN bm.battle_role IN ('Special Sweeper', 'Physical Sweeper', 'Tank') THEN 5 ELSE 0 END) +  -- Role bonus\n        (CASE WHEN bp.generation_number >= 5 THEN 3 ELSE 0 END) +  -- Recent generation bonus\n        (CASE WHEN bp.primary_type IN ('Fairy', 'Steel', 'Dragon', 'Ground', 'Ghost') OR\n               bp.secondary_type IN ('Fairy', 'Steel', 'Dragon', 'Ground', 'Ghost') THEN 7 ELSE 0 END)  -- Type bonus\n    , 100), 1) AS competitive_viability_score,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM base_pokemon bp\nJOIN stat_percentiles sp ON bp.id = sp.id\nJOIN evolution_stage es ON bp.id = es.id\nJOIN battle_metrics bm ON bp.id = bm.id\nORDER BY bp.total_base_stats DESC", "language": "sql", "refs": [{"name": "stg_pokeapi_pokemon", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_netrunner_factions": {"database": "nerd_facts", "schema": "public", "name": "stg_netrunner_factions", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/netrunner/stg_netrunner_factions.sql", "original_file_path": "models/staging/netrunner/stg_netrunner_factions.sql", "unique_id": "model.nerd_facts_dbt.stg_netrunner_factions", "fqn": ["nerd_facts_dbt", "staging", "netrunner", "stg_netrunner_factions"], "alias": "stg_netrunner_factions", "checksum": {"name": "sha256", "checksum": "2012475065f9a0675d110bc59598c856c9fe032b5cae7ff6acab06968acc9cf0"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.4130802, "relation_name": "\"nerd_facts\".\"public\".\"stg_netrunner_factions\"", "raw_code": "/*\n  Model: stg_netrunner_factions\n  Description: Standardizes Netrunner faction data from the raw source\n  Source: raw.netrunner_factions\n  \n  Note: DISTINCT is used to prevent duplicate faction entries\n  that might exist in the data source due to multiple versions.\n*/\n\nWITH raw_data AS (\n    -- Select all relevant columns from source\n    SELECT DISTINCT\n        code,\n        name,\n        side_code,         -- Corporation or Runner side\n        is_mini,           -- Whether this is a mini-faction\n        color,             -- Faction color for UI visualization\n        description        -- Faction description text\n    FROM raw.netrunner_factions\n    WHERE code IS NOT NULL -- Ensure we don't include invalid entries\n)\n\nSELECT\n    -- Primary identifiers\n    code AS faction_code,\n    name AS faction_name,\n    \n    -- Side information\n    side_code,\n    CASE \n        WHEN side_code = 'corp' THEN 'Corporation'\n        WHEN side_code = 'runner' THEN 'Runner'\n        ELSE 'Unknown'\n    END AS side_name,\n    \n    -- Faction attributes\n    COALESCE(is_mini, FALSE) AS is_mini, -- Default to FALSE if NULL\n    color,\n    description AS faction_description,\n    \n    -- Additional derived attributes\n    CASE\n        WHEN code IN ('haas-bioroid', 'jinteki', 'nbn', 'weyland-consortium') THEN TRUE\n        WHEN code IN ('anarch', 'criminal', 'shaper') THEN TRUE\n        ELSE FALSE\n    END AS is_core_faction,\n    \n    -- Track record creation\n    CURRENT_TIMESTAMP AS dbt_loaded_at\nFROM raw_data", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_pokeapi_types": {"database": "nerd_facts", "schema": "public", "name": "stg_pokeapi_types", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/pokeapi/stg_pokeapi_types.sql", "original_file_path": "models/staging/pokeapi/stg_pokeapi_types.sql", "unique_id": "model.nerd_facts_dbt.stg_pokeapi_types", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "stg_pokeapi_types"], "alias": "stg_pokeapi_types", "checksum": {"name": "sha256", "checksum": "16702b02428061c3fdb3df6deeaf202779b36af964de059ebc1bf7df970af6aa"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "view"}, "created_at": 1742203914.4149358, "relation_name": "\"nerd_facts\".\"public\".\"stg_pokeapi_types\"", "raw_code": "/*\n  Model: stg_pokeapi_types\n  Description: Standardizes Pok\u00e9mon type data from the PokeAPI\n  Source: raw.pokeapi_types\n  \n  Notes:\n  - Type effectiveness relationships are extracted from nested JSON\n  - Arrays are converted from JSON to SQL arrays for easier querying\n  - Type classifications and attributes are derived\n  - Generation information is properly extracted\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        generation,\n        damage_relations,\n        move_damage_class\n    FROM raw.pokeapi_types\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS type_name,\n    \n    -- Generation information\n    COALESCE(generation->>'name', 'unknown') AS generation_name,\n    CASE\n        WHEN generation->>'name' ~ 'generation-([i|v]+)'\n        THEN REGEXP_REPLACE(generation->>'name', 'generation-([i|v]+)', '\\1')\n        ELSE NULL\n    END AS generation_number,\n    \n    -- Damage class (physical, special, etc)\n    move_damage_class->>'name' AS damage_class,\n    \n    -- Type effectiveness relationships - convert JSON arrays to SQL arrays\n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'double_damage_from')->>'name', 'unknown')\n    ) AS weaknesses,\n    \n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'double_damage_to')->>'name', 'unknown')\n    ) AS strengths,\n    \n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'half_damage_from')->>'name', 'unknown')\n    ) AS resistances,\n    \n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'half_damage_to')->>'name', 'unknown')\n    ) AS vulnerabilities,\n    \n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'no_damage_from')->>'name', 'unknown')\n    ) AS immune_from,\n    \n    ARRAY(\n        SELECT COALESCE(jsonb_array_elements(damage_relations->'no_damage_to')->>'name', 'unknown')\n    ) AS immune_to,\n    \n    -- Array lengths for quick counts\n    COALESCE(jsonb_array_length(damage_relations->'double_damage_from'), 0) AS weakness_count,\n    COALESCE(jsonb_array_length(damage_relations->'double_damage_to'), 0) AS strength_count,\n    COALESCE(jsonb_array_length(damage_relations->'no_damage_from'), 0) AS immunity_count,\n    \n    -- Derived type classifications\n    CASE\n        WHEN name IN ('fire', 'water', 'grass', 'electric', 'ice') THEN 'Elemental'\n        WHEN name IN ('normal', 'fighting', 'flying', 'ground', 'rock') THEN 'Physical'\n        WHEN name IN ('psychic', 'ghost', 'dark', 'fairy') THEN 'Special'\n        WHEN name IN ('poison', 'bug', 'dragon', 'steel') THEN 'Other'\n        ELSE 'Unknown'\n    END AS type_category,\n    \n    -- Type color for UI displays\n    CASE\n        WHEN name = 'normal' THEN '#A8A77A'\n        WHEN name = 'fire' THEN '#EE8130'\n        WHEN name = 'water' THEN '#6390F0'\n        WHEN name = 'electric' THEN '#F7D02C'\n        WHEN name = 'grass' THEN '#7AC74C'\n        WHEN name = 'ice' THEN '#96D9D6'\n        WHEN name = 'fighting' THEN '#C22E28'\n        WHEN name = 'poison' THEN '#A33EA1'\n        WHEN name = 'ground' THEN '#E2BF65'\n        WHEN name = 'flying' THEN '#A98FF3'\n        WHEN name = 'psychic' THEN '#F95587'\n        WHEN name = 'bug' THEN '#A6B91A'\n        WHEN name = 'rock' THEN '#B6A136'\n        WHEN name = 'ghost' THEN '#735797'\n        WHEN name = 'dragon' THEN '#6F35FC'\n        WHEN name = 'dark' THEN '#705746'\n        WHEN name = 'steel' THEN '#B7B7CE'\n        WHEN name = 'fairy' THEN '#D685AD'\n        ELSE '#CCCCCC'\n    END AS type_color,\n    \n    -- Calculate offensive and defensive scores (higher = better)\n    (COALESCE(jsonb_array_length(damage_relations->'double_damage_to'), 0) * 2) -\n    (COALESCE(jsonb_array_length(damage_relations->'half_damage_to'), 0)) -\n    (COALESCE(jsonb_array_length(damage_relations->'no_damage_to'), 0) * 2) AS offensive_score,\n    \n    (COALESCE(jsonb_array_length(damage_relations->'half_damage_from'), 0)) +\n    (COALESCE(jsonb_array_length(damage_relations->'no_damage_from'), 0) * 2) -\n    (COALESCE(jsonb_array_length(damage_relations->'double_damage_from'), 0)) AS defensive_score,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "test.nerd_facts_dbt.source_unique_pokeapi_moves_id.d93d417c11": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "source_unique_pokeapi_moves_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "source_unique_pokeapi_moves_id.sql", "original_file_path": "models/staging/pokeapi/pokeapi_sources.yml", "unique_id": "test.nerd_facts_dbt.source_unique_pokeapi_moves_id.d93d417c11", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "source_unique_pokeapi_moves_id"], "alias": "source_unique_pokeapi_moves_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742203914.706742, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [], "sources": [["pokeapi", "moves"]], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["source.nerd_facts_dbt.pokeapi.moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "sources.pokeapi", "attached_node": null, "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(source('pokeapi', 'moves')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.source_not_null_pokeapi_moves_id.c4a229cda9": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "source_not_null_pokeapi_moves_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "source_not_null_pokeapi_moves_id.sql", "original_file_path": "models/staging/pokeapi/pokeapi_sources.yml", "unique_id": "test.nerd_facts_dbt.source_not_null_pokeapi_moves_id.c4a229cda9", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "source_not_null_pokeapi_moves_id"], "alias": "source_not_null_pokeapi_moves_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742203914.708091, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [], "sources": [["pokeapi", "moves"]], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["source.nerd_facts_dbt.pokeapi.moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "sources.pokeapi", "attached_node": null, "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(source('pokeapi', 'moves')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.source_not_null_pokeapi_moves_name.5721c278f3": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "source_not_null_pokeapi_moves_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "source_not_null_pokeapi_moves_name.sql", "original_file_path": "models/staging/pokeapi/pokeapi_sources.yml", "unique_id": "test.nerd_facts_dbt.source_not_null_pokeapi_moves_name.5721c278f3", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "source_not_null_pokeapi_moves_name"], "alias": "source_not_null_pokeapi_moves_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742203914.709403, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [], "sources": [["pokeapi", "moves"]], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["source.nerd_facts_dbt.pokeapi.moves"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "sources.pokeapi", "attached_node": null, "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(source('pokeapi', 'moves')) }}"}, "namespace": null}}, "model.nerd_facts_dbt.stg_swapi_starships": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_starships", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_starships.sql", "original_file_path": "models/staging/swapi/stg_swapi_starships.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_starships", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_starships"], "alias": "stg_swapi_starships", "checksum": {"name": "sha256", "checksum": "bf05f192dc6c4de4421e7b58c6e9b098efc351208e7af8e318bf5140e7b0bbf6"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars starship data with cleaned values and derived classifications", "columns": {"id": {"name": "id", "description": "Primary key for starships", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Name of the starship", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "model": {"name": "model", "description": "Starship model specification", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "manufacturer": {"name": "manufacturer", "description": "Company that manufactured the starship", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "max_atmosphering_speed": {"name": "max_atmosphering_speed", "description": "Maximum atmospheric speed in km/h", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "length": {"name": "length", "description": "Length of starship in meters", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "hyperdrive_rating": {"name": "hyperdrive_rating", "description": "Hyperdrive class rating (lower is better)", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "crew": {"name": "crew", "description": "Number of crew members required", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "passengers": {"name": "passengers", "description": "Maximum passenger capacity", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "cargo_capacity": {"name": "cargo_capacity", "description": "Cargo capacity in metric tons", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "consumables": {"name": "consumables", "description": "Length of time the starship can sustain crew without resupply", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "MGLT": {"name": "MGLT", "description": "Maximum speed in megalights per hour", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "starship_class": {"name": "starship_class", "description": "Class of the starship (e.g., Star Destroyer, Light freighter)", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "pilots": {"name": "pilots", "description": "JSONB array of pilot references", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "films": {"name": "films", "description": "JSONB array of film references", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_starships.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742204631.1928902, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_starships\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_starships\n  Description: Standardizes Star Wars starship data from SWAPI\n  Source: raw.swapi_starships\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Speeds and capacities have proper error handling\n  - Pilot and film references are extracted as counts\n  - Additional derived fields help with starship classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        model,\n        manufacturer,\n        cost_in_credits,\n        length,\n        max_atmosphering_speed,\n        crew,\n        passengers,\n        cargo_capacity,\n        consumables,\n        hyperdrive_rating,\n        MGLT,\n        starship_class,\n        pilots,\n        films,\n        created,\n        edited,\n        url\n    FROM raw.swapi_starships\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS starship_name,\n    model,\n    manufacturer,\n    starship_class,\n    \n    -- Technical specifications with improved error handling\n    CASE \n        WHEN lower(cost_in_credits) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cost_in_credits, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cost_in_credits,\n    \n    CASE \n        WHEN lower(length) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(length, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS length_m,\n    \n    CASE \n        WHEN lower(max_atmosphering_speed) = 'unknown' THEN NULL\n        WHEN lower(max_atmosphering_speed) = 'n/a' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(max_atmosphering_speed, '[^0-9]+.*', '', 'g'), '')::INTEGER \n    END AS max_speed,\n    \n    CASE\n        WHEN lower(hyperdrive_rating) = 'unknown' THEN NULL\n        WHEN lower(hyperdrive_rating) = 'n/a' THEN NULL\n        ELSE NULLIF(hyperdrive_rating, '')::NUMERIC\n    END AS hyperdrive_rating,\n    \n    CASE\n        WHEN lower(MGLT) = 'unknown' THEN NULL\n        WHEN lower(MGLT) = 'n/a' THEN NULL\n        ELSE NULLIF(MGLT, '')::INTEGER\n    END AS mglt,\n    \n    -- Capacity information\n    NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER AS crew_count,\n    NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER AS passenger_capacity,\n    \n    CASE \n        WHEN lower(cargo_capacity) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cargo_capacity, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cargo_capacity,\n    \n    consumables,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(pilots), 0) AS pilot_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    CASE WHEN pilots IS NULL OR pilots = '' THEN NULL::jsonb ELSE pilots::jsonb END AS pilots,\n    CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n    \n    -- Derived ship classification\n    CASE\n        WHEN lower(starship_class) IN ('corvette', 'frigate', 'star destroyer', 'dreadnought')\n            OR lower(name) LIKE '%star destroyer%' THEN 'Military'\n        WHEN lower(starship_class) IN ('transport', 'freighter', 'yacht') \n            OR lower(name) LIKE '%transport%' THEN 'Commercial'\n        WHEN lower(starship_class) IN ('starfighter', 'bomber', 'assault ship')\n            OR lower(name) LIKE '%fighter%' THEN 'Starfighter'\n        ELSE 'Other'\n    END AS ship_purpose,\n    \n    -- Size classification\n    CASE\n        WHEN length::NUMERIC < 30 THEN 'Small'\n        WHEN length::NUMERIC < 100 THEN 'Medium'\n        WHEN length::NUMERIC < 500 THEN 'Large'\n        WHEN length::NUMERIC < 1000 THEN 'Very Large'\n        WHEN length::NUMERIC >= 1000 THEN 'Capital'\n        ELSE 'Unknown'\n    END AS ship_size,\n    \n    -- Notable ship flag\n    CASE\n        WHEN name IN ('Millennium Falcon', 'Death Star', 'Star Destroyer', \n                     'X-wing', 'TIE Advanced x1', 'Executor', 'Slave 1') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_ship,\n    \n    -- Total capacity (crew + passengers)\n    COALESCE(\n        NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) + \n    COALESCE(\n        NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) AS total_capacity,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": []}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_starships.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_starships\n  Description: Standardizes Star Wars starship data from SWAPI\n  Source: raw.swapi_starships\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Speeds and capacities have proper error handling\n  - Pilot and film references are extracted as counts\n  - Additional derived fields help with starship classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        model,\n        manufacturer,\n        cost_in_credits,\n        length,\n        max_atmosphering_speed,\n        crew,\n        passengers,\n        cargo_capacity,\n        consumables,\n        hyperdrive_rating,\n        MGLT,\n        starship_class,\n        pilots,\n        films,\n        created,\n        edited,\n        url\n    FROM raw.swapi_starships\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS starship_name,\n    model,\n    manufacturer,\n    starship_class,\n    \n    -- Technical specifications with improved error handling\n    CASE \n        WHEN lower(cost_in_credits) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cost_in_credits, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cost_in_credits,\n    \n    CASE \n        WHEN lower(length) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(length, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS length_m,\n    \n    CASE \n        WHEN lower(max_atmosphering_speed) = 'unknown' THEN NULL\n        WHEN lower(max_atmosphering_speed) = 'n/a' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(max_atmosphering_speed, '[^0-9]+.*', '', 'g'), '')::INTEGER \n    END AS max_speed,\n    \n    CASE\n        WHEN lower(hyperdrive_rating) = 'unknown' THEN NULL\n        WHEN lower(hyperdrive_rating) = 'n/a' THEN NULL\n        ELSE NULLIF(hyperdrive_rating, '')::NUMERIC\n    END AS hyperdrive_rating,\n    \n    CASE\n        WHEN lower(MGLT) = 'unknown' THEN NULL\n        WHEN lower(MGLT) = 'n/a' THEN NULL\n        ELSE NULLIF(MGLT, '')::INTEGER\n    END AS mglt,\n    \n    -- Capacity information\n    NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER AS crew_count,\n    NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER AS passenger_capacity,\n    \n    CASE \n        WHEN lower(cargo_capacity) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cargo_capacity, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cargo_capacity,\n    \n    consumables,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(pilots), 0) AS pilot_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    CASE WHEN pilots IS NULL OR pilots = '' THEN NULL::jsonb ELSE pilots::jsonb END AS pilots,\n    CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n    \n    -- Derived ship classification\n    CASE\n        WHEN lower(starship_class) IN ('corvette', 'frigate', 'star destroyer', 'dreadnought')\n            OR lower(name) LIKE '%star destroyer%' THEN 'Military'\n        WHEN lower(starship_class) IN ('transport', 'freighter', 'yacht') \n            OR lower(name) LIKE '%transport%' THEN 'Commercial'\n        WHEN lower(starship_class) IN ('starfighter', 'bomber', 'assault ship')\n            OR lower(name) LIKE '%fighter%' THEN 'Starfighter'\n        ELSE 'Other'\n    END AS ship_purpose,\n    \n    -- Size classification\n    CASE\n        WHEN length::NUMERIC < 30 THEN 'Small'\n        WHEN length::NUMERIC < 100 THEN 'Medium'\n        WHEN length::NUMERIC < 500 THEN 'Large'\n        WHEN length::NUMERIC < 1000 THEN 'Very Large'\n        WHEN length::NUMERIC >= 1000 THEN 'Capital'\n        ELSE 'Unknown'\n    END AS ship_size,\n    \n    -- Notable ship flag\n    CASE\n        WHEN name IN ('Millennium Falcon', 'Death Star', 'Star Destroyer', \n                     'X-wing', 'TIE Advanced x1', 'Executor', 'Slave 1') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_ship,\n    \n    -- Total capacity (crew + passengers)\n    COALESCE(\n        NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) + \n    COALESCE(\n        NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) AS total_capacity,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "test.nerd_facts_dbt.unique_stg_swapi_starships_id.faa87ea4e7": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_starships_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_starships_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_starships_id.faa87ea4e7", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_starships_id"], "alias": "unique_stg_swapi_starships_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742204631.3317332, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_starships_id.7ec0941917": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_starships_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_starships_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_starships_id.7ec0941917", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_starships_id"], "alias": "not_null_stg_swapi_starships_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742204631.334441, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_starships_name.0962a611d5": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_starships_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_starships_name.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_starships_name.0962a611d5", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_starships_name"], "alias": "not_null_stg_swapi_starships_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742204631.3368154, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing.2fef0b1acf": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "accepted_values_stg_swapi_star_f3359b21d1586e66ef9d2b69269f94d5.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing.2fef0b1acf", "fqn": ["nerd_facts_dbt", "staging", "swapi", "accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing"], "alias": "accepted_values_stg_swapi_star_f3359b21d1586e66ef9d2b69269f94d5", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "accepted_values_stg_swapi_star_f3359b21d1586e66ef9d2b69269f94d5", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "accepted_values_stg_swapi_star_f3359b21d1586e66ef9d2b69269f94d5"}, "created_at": 1742204631.3397632, "relation_name": null, "raw_code": "{{ test_accepted_values(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"accepted_values_stg_swapi_star_f3359b21d1586e66ef9d2b69269f94d5\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_accepted_values", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "manufacturer", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "accepted_values", "kwargs": {"values": ["Kuat Drive Yards", "Corellian Engineering Corporation", "Sienar Fleet Systems", "Cygnus Spaceworks", "Incom Corporation", "Koensayr Manufacturing"], "column_name": "manufacturer", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_starships_max_atmosphering_speed.9fc07f34cf": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_starships_max_atmosphering_speed", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_starships_max_atmosphering_speed.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_starships_max_atmosphering_speed.9fc07f34cf", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_starships_max_atmosphering_speed"], "alias": "not_null_stg_swapi_starships_max_atmosphering_speed", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "WARN", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "WARN"}, "created_at": 1742204631.3690255, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "max_atmosphering_speed", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "max_atmosphering_speed", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL.ec823ef959": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_f96fcbd14ddc641df073db37ee15bc56.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL.ec823ef959", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_f96fcbd14ddc641df073db37ee15bc56", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_f96fcbd14ddc641df073db37ee15bc56", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "error", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "error", "alias": "dbt_utils_expression_is_true_s_f96fcbd14ddc641df073db37ee15bc56"}, "created_at": 1742204631.3712132, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"error\",alias=\"dbt_utils_expression_is_true_s_f96fcbd14ddc641df073db37ee15bc56\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "max_atmosphering_speed", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": ">= 0 OR IS NULL", "column_name": "max_atmosphering_speed", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0.8f9d0183b8": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_accepted_range_stg_s_0010594815da93a571a43e6dd43c6422.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0.8f9d0183b8", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0"], "alias": "dbt_utils_accepted_range_stg_s_0010594815da93a571a43e6dd43c6422", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_accepted_range_stg_s_0010594815da93a571a43e6dd43c6422", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_accepted_range_stg_s_0010594815da93a571a43e6dd43c6422"}, "created_at": 1742204631.3786917, "relation_name": null, "raw_code": "{{ dbt_utils.test_accepted_range(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_accepted_range_stg_s_0010594815da93a571a43e6dd43c6422\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_accepted_range", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "max_atmosphering_speed", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "accepted_range", "kwargs": {"min_value": 0, "max_value": 2000, "column_name": "max_atmosphering_speed", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL.1915ec346c": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_be8f4b71c2f17ad203558d2f702bf73e.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL.1915ec346c", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_be8f4b71c2f17ad203558d2f702bf73e", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_be8f4b71c2f17ad203558d2f702bf73e", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "error", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "error", "alias": "dbt_utils_expression_is_true_s_be8f4b71c2f17ad203558d2f702bf73e"}, "created_at": 1742204631.3867838, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"error\",alias=\"dbt_utils_expression_is_true_s_be8f4b71c2f17ad203558d2f702bf73e\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "length", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": "> 0 OR IS NULL", "column_name": "length", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5.de460c4fa4": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_accepted_range_stg_s_dd0ad6923fc838f5a7ce83233328b8a5.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5.de460c4fa4", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5"], "alias": "dbt_utils_accepted_range_stg_s_dd0ad6923fc838f5a7ce83233328b8a5", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_accepted_range_stg_s_dd0ad6923fc838f5a7ce83233328b8a5", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_accepted_range_stg_s_dd0ad6923fc838f5a7ce83233328b8a5"}, "created_at": 1742204631.392513, "relation_name": null, "raw_code": "{{ dbt_utils.test_accepted_range(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_accepted_range_stg_s_dd0ad6923fc838f5a7ce83233328b8a5\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_accepted_range", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "hyperdrive_rating", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "accepted_range", "kwargs": {"min_value": 0.5, "max_value": 10, "column_name": "hyperdrive_rating", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL.c35df747e6": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_d125afcd2334724d94f609b49be6617c.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL.c35df747e6", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_d125afcd2334724d94f609b49be6617c", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_d125afcd2334724d94f609b49be6617c", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_expression_is_true_s_d125afcd2334724d94f609b49be6617c"}, "created_at": 1742204631.396978, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_expression_is_true_s_d125afcd2334724d94f609b49be6617c\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "crew", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": ">= 1 OR IS NULL", "column_name": "crew", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL.176b315457": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_af273654177cfdc91478abd436a54b83.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL.176b315457", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_af273654177cfdc91478abd436a54b83", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_af273654177cfdc91478abd436a54b83", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "error", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "error", "alias": "dbt_utils_expression_is_true_s_af273654177cfdc91478abd436a54b83"}, "created_at": 1742204631.401589, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"error\",alias=\"dbt_utils_expression_is_true_s_af273654177cfdc91478abd436a54b83\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "passengers", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": ">= 0 OR IS NULL", "column_name": "passengers", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL.8339feb5a2": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_4acb3b26b03e1d062250ec156d7d150d.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL.8339feb5a2", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_4acb3b26b03e1d062250ec156d7d150d", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_4acb3b26b03e1d062250ec156d7d150d", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "error", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "error", "alias": "dbt_utils_expression_is_true_s_4acb3b26b03e1d062250ec156d7d150d"}, "created_at": 1742204631.405827, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"error\",alias=\"dbt_utils_expression_is_true_s_4acb3b26b03e1d062250ec156d7d150d\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "cargo_capacity", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": ">= 0 OR IS NULL", "column_name": "cargo_capacity", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL.4849ab31ba": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_cfc3b86b042a82b903ed54f0c8725d53.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL.4849ab31ba", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL"], "alias": "dbt_utils_expression_is_true_s_cfc3b86b042a82b903ed54f0c8725d53", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_cfc3b86b042a82b903ed54f0c8725d53", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_expression_is_true_s_cfc3b86b042a82b903ed54f0c8725d53"}, "created_at": 1742204631.4100528, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_expression_is_true_s_cfc3b86b042a82b903ed54f0c8725d53\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "MGLT", "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": ">= 0 OR IS NULL", "column_name": "MGLT", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_.2b12d505ec": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_expression_is_true_s_b661521dc2474e27ea156eaf895ee132.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_.2b12d505ec", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_"], "alias": "dbt_utils_expression_is_true_s_b661521dc2474e27ea156eaf895ee132", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_expression_is_true_s_b661521dc2474e27ea156eaf895ee132", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_expression_is_true_s_b661521dc2474e27ea156eaf895ee132"}, "created_at": 1742204631.414076, "relation_name": null, "raw_code": "{{ dbt_utils.test_expression_is_true(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_expression_is_true_s_b661521dc2474e27ea156eaf895ee132\") }}", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_expression_is_true", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": null, "file_key_name": "models.stg_swapi_starships", "attached_node": "model.nerd_facts_dbt.stg_swapi_starships", "test_metadata": {"name": "expression_is_true", "kwargs": {"expression": "crew::numeric <= passengers::numeric + 50 OR passengers IS NULL OR crew IS NULL OR crew = 'unknown'", "model": "{{ get_where_subquery(ref('stg_swapi_starships')) }}"}, "namespace": "dbt_utils"}}, "model.nerd_facts_dbt.bridge_sw_characters_films": {"database": "nerd_facts", "schema": "public", "name": "bridge_sw_characters_films", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/bridge_sw_characters_films.sql", "original_file_path": "models/marts/star_wars/bridge_sw_characters_films.sql", "unique_id": "model.nerd_facts_dbt.bridge_sw_characters_films", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "bridge_sw_characters_films"], "alias": "bridge_sw_characters_films", "checksum": {"name": "sha256", "checksum": "cbf7f5e6e37474c2b145dcce6db3e7e11dec42ab94963b323b2987560a504a0b"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "character_film_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["character_id"]}, {"columns": ["film_id"]}, {"columns": ["character_film_id"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["character_id"]}, {"columns": ["film_id"]}, {"columns": ["character_film_id"]}], "unique_key": "character_film_id"}, "created_at": 1742205059.156939, "relation_name": "\"nerd_facts\".\"public\".\"bridge_sw_characters_films\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['character_id']}, {'columns': ['film_id']}, {'columns': ['character_film_id']}],\n    unique_key = 'character_film_id'\n  )\n}}\n\n/*\n  Model: bridge_sw_characters_films\n  Description: Bridge table connecting Star Wars characters to the films they appear in\n  \n  Notes:\n  - Handles the many-to-many relationship between characters and films\n  - Extracts film references from the nested arrays in character data\n  - Calculates character importance and appearance sequences\n  - Provides context for character arcs across the film timeline\n  - Adds derived attributes about character relationships to each film\n*/\n\nWITH character_films AS (\n    -- Extract film references from the characters data with improved error handling\n    SELECT\n        p.id AS character_id,\n        p.name AS character_name,\n        p.gender,\n        p.birth_year,\n        p.species_id,\n        film_ref->>'url' AS film_url,\n        -- Extract film ID from URL with better error handling\n        NULLIF(SPLIT_PART(COALESCE(film_ref->>'url', ''), '/', 6), '')::INTEGER AS film_id\n    FROM {{ ref('stg_swapi_people') }} p,\n    LATERAL jsonb_array_elements(\n        CASE WHEN p.films IS NULL OR p.films = 'null' THEN '[]'::jsonb\n        ELSE p.films END\n    ) AS film_ref\n    WHERE p.id IS NOT NULL\n),\n\n-- Join with film information for additional context\nfilm_details AS (\n    SELECT\n        cf.character_id,\n        cf.character_name,\n        cf.gender,\n        cf.birth_year,\n        cf.species_id,\n        cf.film_id,\n        f.title AS film_title,\n        f.episode_id,\n        f.release_date,\n        f.director\n    FROM character_films cf\n    LEFT JOIN {{ ref('stg_swapi_films') }} f ON cf.film_id = f.id\n),\n\n-- Character importance tiers with expanded classifications\ncharacter_importance AS (\n    SELECT \n        fd.*,\n        CASE\n            -- Protagonist/Antagonist tier - the most central characters\n            WHEN fd.character_name IN ('Luke Skywalker', 'Darth Vader', 'Anakin Skywalker', \n                                      'Rey', 'Kylo Ren', 'Din Djarin', 'Grogu') THEN 'Protagonist/Antagonist'\n            \n            -- Major characters - very important to the plot but not the absolute center\n            WHEN fd.character_name IN ('Han Solo', 'Leia Organa', 'Obi-Wan Kenobi', 'Emperor Palpatine',\n                                      'Finn', 'Poe Dameron', 'Padm\u00e9 Amidala', 'Count Dooku', 'Qui-Gon Jinn',\n                                      'Darth Maul', 'Jyn Erso', 'Cassian Andor', 'Boba Fett') THEN 'Major'\n            \n            -- Supporting characters - recognizable and important secondary characters\n            WHEN fd.character_name IN ('Chewbacca', 'C-3PO', 'R2-D2', 'Yoda', 'Lando Calrissian',\n                                      'Mace Windu', 'General Grievous', 'Admiral Ackbar', 'BB-8',\n                                      'General Hux', 'Rose Tico', 'Moff Gideon', 'Saw Gerrera',\n                                      'Jabba the Hutt', 'Ahsoka Tano') THEN 'Supporting'\n                                      \n            -- Determine recursively based on metadata\n            WHEN fd.character_id IN (1, 2, 3, 4, 5, 10, 11, 13) THEN 'Major' -- Additional known major characters by ID\n            \n            -- Use gender and birth_year to help detect likely important characters\n            WHEN fd.gender IS NOT NULL AND fd.birth_year IS NOT NULL THEN 'Notable'\n            \n            -- Default case\n            ELSE 'Minor'\n        END AS character_importance_tier\n    FROM film_details fd\n),\n\n-- Add film saga classification\nfilm_saga AS (\n    SELECT\n        ci.*,\n        CASE\n            WHEN ci.episode_id BETWEEN 1 AND 3 THEN 'Prequel Trilogy'\n            WHEN ci.episode_id BETWEEN 4 AND 6 THEN 'Original Trilogy'\n            WHEN ci.episode_id BETWEEN 7 AND 9 THEN 'Sequel Trilogy'\n            WHEN ci.title = 'Rogue One' THEN 'Anthology'\n            WHEN ci.title = 'Solo' THEN 'Anthology'\n            ELSE 'Other'\n        END AS film_saga\n    FROM character_importance ci\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['fs.character_id', 'fs.film_id']) }} AS character_film_id,\n    \n    -- Foreign keys to related dimensions\n    {{ dbt_utils.generate_surrogate_key(['fs.character_id']) }} AS character_key,\n    {{ dbt_utils.generate_surrogate_key(['fs.film_id']) }} AS film_key,\n    \n    -- Core identifiers\n    fs.character_id,\n    fs.character_name,\n    fs.film_id,\n    fs.film_title,\n    fs.episode_id,\n    \n    -- Enhanced character role classification with more nuance\n    fs.character_importance_tier AS character_role,\n    \n    -- Film saga categorization\n    fs.film_saga,\n    \n    -- Character's species relationship\n    fs.species_id,\n    \n    -- Calculate appearance metrics\n    ROW_NUMBER() OVER (\n        PARTITION BY fs.character_id \n        ORDER BY fs.episode_id\n    ) AS chronological_appearance_number,\n    \n    ROW_NUMBER() OVER (\n        PARTITION BY fs.character_id \n        ORDER BY fs.release_date\n    ) AS release_order_appearance_number,\n    \n    -- Timeline attributes\n    CASE WHEN ROW_NUMBER() OVER (\n        PARTITION BY fs.character_id \n        ORDER BY fs.episode_id\n    ) = 1 THEN TRUE ELSE FALSE END AS is_first_chronological_appearance,\n    \n    CASE WHEN ROW_NUMBER() OVER (\n        PARTITION BY fs.character_id \n        ORDER BY fs.release_date\n    ) = 1 THEN TRUE ELSE FALSE END AS is_first_release_appearance,\n    \n    CASE WHEN fs.character_name IN ('Darth Vader', 'Anakin Skywalker') AND \n              fs.episode_id BETWEEN 1 AND 3 THEN 'Protagonist'\n         WHEN fs.character_name IN ('Darth Vader') AND \n              fs.episode_id BETWEEN 4 AND 6 THEN 'Antagonist'\n         WHEN fs.character_name = 'Luke Skywalker' AND \n              fs.episode_id BETWEEN 4 AND 6 THEN 'Protagonist'\n         WHEN fs.character_name = 'Rey' AND \n              fs.episode_id BETWEEN 7 AND 9 THEN 'Protagonist'\n         WHEN fs.character_name = 'Kylo Ren' AND \n              fs.episode_id BETWEEN 7 AND 8 THEN 'Antagonist'\n         WHEN fs.character_name = 'Kylo Ren' AND \n              fs.episode_id = 9 THEN 'Protagonist'\n         WHEN fs.character_importance_tier = 'Protagonist/Antagonist' THEN 'Key Character'\n         WHEN fs.character_importance_tier = 'Major' THEN 'Major Character'\n         ELSE 'Supporting Character'\n    END AS narrative_role,\n    \n    -- Light side/dark side alignment\n    CASE \n        WHEN fs.character_name IN ('Darth Vader', 'Emperor Palpatine', 'Darth Maul',\n                                'Count Dooku', 'General Grievous', 'Kylo Ren',\n                                'Captain Phasma', 'General Hux', 'Moff Tarkin',\n                                'Jabba the Hutt', 'Boba Fett', 'Jango Fett') THEN 'Villain'\n        WHEN fs.character_name IN ('Luke Skywalker', 'Leia Organa', 'Han Solo',\n                                'Obi-Wan Kenobi', 'Yoda', 'Rey', 'Finn', 'Poe Dameron',\n                                'Padm\u00e9 Amidala', 'Qui-Gon Jinn', 'Mace Windu') THEN 'Hero'\n        WHEN fs.character_name IN ('Lando Calrissian', 'Anakin Skywalker') THEN 'Ambiguous'\n        ELSE 'Neutral'\n    END AS character_alignment,\n    \n    -- Film significance - how crucial the character is to this specific film\n    CASE\n        WHEN fs.character_importance_tier = 'Protagonist/Antagonist' AND\n             ((fs.character_name = 'Luke Skywalker' AND fs.episode_id IN (4, 5, 6)) OR\n              (fs.character_name = 'Anakin Skywalker' AND fs.episode_id IN (1, 2, 3)) OR\n              (fs.character_name = 'Darth Vader' AND fs.episode_id IN (4, 5, 6)) OR\n              (fs.character_name = 'Rey' AND fs.episode_id IN (7, 8, 9)) OR\n              (fs.character_name = 'Kylo Ren' AND fs.episode_id IN (7, 8, 9))) THEN 'Pivotal'\n        WHEN fs.character_importance_tier = 'Protagonist/Antagonist' THEN 'Crucial'\n        WHEN fs.character_importance_tier = 'Major' THEN 'Significant'\n        WHEN fs.character_importance_tier = 'Supporting' THEN 'Important'\n        ELSE 'Background'\n    END AS film_significance,\n    \n    -- Meta information\n    fs.release_date,\n    fs.director,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM film_saga fs\nORDER BY fs.episode_id, character_role, fs.character_name", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}, {"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_sw_films": {"database": "nerd_facts", "schema": "public", "name": "dim_sw_films", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/dim_sw_films.sql", "original_file_path": "models/marts/star_wars/dim_sw_films.sql", "unique_id": "model.nerd_facts_dbt.dim_sw_films", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "dim_sw_films"], "alias": "dim_sw_films", "checksum": {"name": "sha256", "checksum": "f63c0b7d270f54963c9396bcf54917c37eddb334c9d6f10e31a795d97819e189"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "film_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["film_id"]}, {"columns": ["episode_id"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["film_id"]}, {"columns": ["episode_id"]}], "unique_key": "film_key"}, "created_at": 1742205059.1850307, "relation_name": "\"nerd_facts\".\"public\".\"dim_sw_films\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['film_id']}, {'columns': ['episode_id']}],\n    unique_key = 'film_key'\n  )\n}}\n\n/*\n  Model: dim_sw_films\n  Description: Dimension table for Star Wars films\n  \n  Notes:\n  - Contains canonical Star Wars films (Episodes I-IX)\n  - Provides timeline, release, and production context\n  - Includes film classifications and metrics\n  - Enriches SWAPI data with additional attributes and metadata\n  - Serves as a core dimension for Star Wars universe analysis\n*/\n\nWITH films AS (\n    SELECT\n        id AS film_id,\n        title,\n        episode_id,\n        opening_crawl,\n        director,\n        producer,\n        release_date,\n        created,\n        edited\n    FROM {{ ref('stg_swapi_films') }}\n),\n\n-- Box office and critical reception (manually added since not in SWAPI)\nfilm_performance AS (\n    SELECT\n        film_id,\n        CASE\n            WHEN episode_id = 1 THEN 1027.0  -- The Phantom Menace\n            WHEN episode_id = 2 THEN 649.4   -- Attack of the Clones\n            WHEN episode_id = 3 THEN 850.0   -- Revenge of the Sith\n            WHEN episode_id = 4 THEN 775.4   -- A New Hope (adjusted)\n            WHEN episode_id = 5 THEN 547.9   -- The Empire Strikes Back (adjusted)\n            WHEN episode_id = 6 THEN 475.1   -- Return of the Jedi (adjusted)\n            WHEN episode_id = 7 THEN 2068.0  -- The Force Awakens\n            WHEN episode_id = 8 THEN 1333.0  -- The Last Jedi\n            WHEN episode_id = 9 THEN 1077.0  -- The Rise of Skywalker\n            ELSE NULL\n        END AS worldwide_box_office_millions,\n        \n        CASE\n            WHEN episode_id = 1 THEN 51  -- The Phantom Menace\n            WHEN episode_id = 2 THEN 65  -- Attack of the Clones\n            WHEN episode_id = 3 THEN 80  -- Revenge of the Sith\n            WHEN episode_id = 4 THEN 93  -- A New Hope\n            WHEN episode_id = 5 THEN 94  -- The Empire Strikes Back\n            WHEN episode_id = 6 THEN 83  -- Return of the Jedi\n            WHEN episode_id = 7 THEN 93  -- The Force Awakens\n            WHEN episode_id = 8 THEN 91  -- The Last Jedi\n            WHEN episode_id = 9 THEN 52  -- The Rise of Skywalker\n            ELSE NULL\n        END AS rotten_tomatoes_score\n    FROM films\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['f.film_id']) }} AS film_key,\n    \n    -- Core identifiers\n    f.film_id,\n    f.title,\n    f.episode_id,\n    \n    -- Release information\n    f.release_date,\n    EXTRACT(YEAR FROM f.release_date) AS release_year,\n    EXTRACT(DECADE FROM f.release_date) AS release_decade,\n    \n    -- Film details\n    f.director,\n    f.producer,\n    \n    -- Opening crawl (shortened to first 100 chars for preview)\n    f.opening_crawl,\n    SUBSTRING(f.opening_crawl FROM 1 FOR 100) || '...' AS opening_crawl_preview,\n    \n    -- Runtime with improved coverage and validation\n    CASE\n        WHEN f.episode_id = 1 THEN 136  -- The Phantom Menace\n        WHEN f.episode_id = 2 THEN 142  -- Attack of the Clones\n        WHEN f.episode_id = 3 THEN 140  -- Revenge of the Sith\n        WHEN f.episode_id = 4 THEN 121  -- A New Hope\n        WHEN f.episode_id = 5 THEN 124  -- The Empire Strikes Back\n        WHEN f.episode_id = 6 THEN 131  -- Return of the Jedi\n        WHEN f.episode_id = 7 THEN 138  -- The Force Awakens\n        WHEN f.episode_id = 8 THEN 152  -- The Last Jedi\n        WHEN f.episode_id = 9 THEN 142  -- The Rise of Skywalker\n        ELSE 135  -- Default\n    END AS runtime_minutes,\n    \n    -- Film saga classification\n    CASE\n        WHEN f.episode_id BETWEEN 1 AND 3 THEN 'Prequel Trilogy'\n        WHEN f.episode_id BETWEEN 4 AND 6 THEN 'Original Trilogy'\n        WHEN f.episode_id BETWEEN 7 AND 9 THEN 'Sequel Trilogy'\n        ELSE 'Anthology'\n    END AS trilogy,\n    \n    -- Film era in timeline with expanded detail\n    CASE\n        WHEN f.episode_id = 1 THEN 'Republic Era - Trade Federation Crisis'\n        WHEN f.episode_id = 2 THEN 'Republic Era - Clone Wars Beginning'\n        WHEN f.episode_id = 3 THEN 'Republic Era - Rise of the Empire'\n        WHEN f.episode_id = 4 THEN 'Imperial Era - Rebellion Rising'\n        WHEN f.episode_id = 5 THEN 'Imperial Era - Rebellion on the Run'\n        WHEN f.episode_id = 6 THEN 'Imperial Era - Fall of the Empire'\n        WHEN f.episode_id = 7 THEN 'New Republic Era - First Order Emergence'\n        WHEN f.episode_id = 8 THEN 'New Republic Era - Resistance Survival'\n        WHEN f.episode_id = 9 THEN 'New Republic Era - Final Order Conflict'\n        ELSE 'Unknown Era'\n    END AS detailed_timeline_era,\n    \n    -- Broader timeline era\n    CASE\n        WHEN f.episode_id BETWEEN 1 AND 3 THEN 'Republic Era'\n        WHEN f.episode_id BETWEEN 4 AND 6 THEN 'Imperial Era'\n        WHEN f.episode_id BETWEEN 7 AND 9 THEN 'New Republic Era'\n        ELSE 'Various'\n    END AS timeline_era,\n    \n    -- Production studio\n    CASE\n        WHEN f.episode_id BETWEEN 1 AND 6 THEN 'Lucasfilm'\n        WHEN f.episode_id BETWEEN 7 AND 9 THEN 'Lucasfilm/Disney'\n        ELSE 'Other'\n    END AS production_studio,\n    \n    -- Primary antagonist\n    CASE\n        WHEN f.episode_id = 1 THEN 'Darth Sidious/Trade Federation'\n        WHEN f.episode_id = 2 THEN 'Count Dooku/Separatists'\n        WHEN f.episode_id = 3 THEN 'Darth Sidious/General Grievous'\n        WHEN f.episode_id = 4 THEN 'Darth Vader/Grand Moff Tarkin'\n        WHEN f.episode_id = 5 THEN 'Darth Vader/Emperor Palpatine'\n        WHEN f.episode_id = 6 THEN 'Emperor Palpatine/Darth Vader'\n        WHEN f.episode_id = 7 THEN 'Kylo Ren/First Order'\n        WHEN f.episode_id = 8 THEN 'Kylo Ren/Supreme Leader Snoke'\n        WHEN f.episode_id = 9 THEN 'Emperor Palpatine/First Order'\n        ELSE 'Unknown'\n    END AS primary_antagonist,\n    \n    -- Primary protagonist\n    CASE\n        WHEN f.episode_id = 1 THEN 'Qui-Gon Jinn/Obi-Wan Kenobi'\n        WHEN f.episode_id = 2 THEN 'Anakin Skywalker/Obi-Wan Kenobi'\n        WHEN f.episode_id = 3 THEN 'Anakin Skywalker/Obi-Wan Kenobi'\n        WHEN f.episode_id = 4 THEN 'Luke Skywalker'\n        WHEN f.episode_id = 5 THEN 'Luke Skywalker'\n        WHEN f.episode_id = 6 THEN 'Luke Skywalker'\n        WHEN f.episode_id = 7 THEN 'Rey/Finn'\n        WHEN f.episode_id = 8 THEN 'Rey'\n        WHEN f.episode_id = 9 THEN 'Rey'\n        ELSE 'Unknown'\n    END AS primary_protagonist,\n    \n    -- Primary location\n    CASE\n        WHEN f.episode_id = 1 THEN 'Naboo/Tatooine/Coruscant'\n        WHEN f.episode_id = 2 THEN 'Coruscant/Kamino/Geonosis'\n        WHEN f.episode_id = 3 THEN 'Coruscant/Mustafar/Kashyyyk'\n        WHEN f.episode_id = 4 THEN 'Tatooine/Death Star/Yavin IV'\n        WHEN f.episode_id = 5 THEN 'Hoth/Dagobah/Cloud City'\n        WHEN f.episode_id = 6 THEN 'Tatooine/Death Star II/Endor'\n        WHEN f.episode_id = 7 THEN 'Jakku/Takodana/Starkiller Base'\n        WHEN f.episode_id = 8 THEN 'Ahch-To/Canto Bight/Crait'\n        WHEN f.episode_id = 9 THEN 'Exegol/Pasaana/Kijimi'\n        ELSE 'Unknown'\n    END AS primary_locations,\n    \n    -- Film performance metrics\n    fp.worldwide_box_office_millions,\n    fp.rotten_tomatoes_score,\n    \n    -- Critical reception classification\n    CASE\n        WHEN fp.rotten_tomatoes_score >= 90 THEN 'Critically Acclaimed'\n        WHEN fp.rotten_tomatoes_score >= 75 THEN 'Well Received'\n        WHEN fp.rotten_tomatoes_score >= 60 THEN 'Mixed to Positive'\n        WHEN fp.rotten_tomatoes_score >= 40 THEN 'Mixed'\n        ELSE 'Critically Panned'\n    END AS critical_reception,\n    \n    -- Commercial success classification\n    CASE\n        WHEN fp.worldwide_box_office_millions >= 1500 THEN 'Blockbuster'\n        WHEN fp.worldwide_box_office_millions >= 1000 THEN 'Very Successful'\n        WHEN fp.worldwide_box_office_millions >= 750 THEN 'Successful'\n        WHEN fp.worldwide_box_office_millions >= 500 THEN 'Profitable'\n        WHEN fp.worldwide_box_office_millions >= 0 THEN 'Modest'\n        ELSE 'Unknown'\n    END AS commercial_success,\n    \n    -- Major themes\n    CASE\n        WHEN f.episode_id = 1 THEN 'Trade disputes, Chosen one prophecy'\n        WHEN f.episode_id = 2 THEN 'Political manipulation, Clone army'\n        WHEN f.episode_id = 3 THEN 'Corruption, Fall to dark side, Order 66'\n        WHEN f.episode_id = 4 THEN 'Rebellion, Force awakening, Death Star'\n        WHEN f.episode_id = 5 THEN 'Jedi training, Family revelation, Rebellion setback'\n        WHEN f.episode_id = 6 THEN 'Redemption, Empire defeat, Jedi return'\n        WHEN f.episode_id = 7 THEN 'New heroes, Legacy, Force awakening'\n        WHEN f.episode_id = 8 THEN 'Legacy, Letting go of the past, Failure'\n        WHEN f.episode_id = 9 THEN 'Identity, Lineage, Final confrontation'\n        ELSE 'Various themes'\n    END AS major_themes,\n    \n    -- Source data metadata\n    f.created AS source_created_at,\n    f.edited AS source_edited_at,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM films f\nLEFT JOIN film_performance fp ON f.film_id = fp.film_id\nORDER BY f.episode_id", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.bridge_sw_starships_pilots": {"database": "nerd_facts", "schema": "public", "name": "bridge_sw_starships_pilots", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/bridge_sw_starships_pilots.sql", "original_file_path": "models/marts/star_wars/bridge_sw_starships_pilots.sql", "unique_id": "model.nerd_facts_dbt.bridge_sw_starships_pilots", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "bridge_sw_starships_pilots"], "alias": "bridge_sw_starships_pilots", "checksum": {"name": "sha256", "checksum": "c2740c5a2dca5d5c456825992e8849ea74aa77ff3ed354250a77ae6c010ab24f"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "starship_pilot_id", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["starship_id"]}, {"columns": ["pilot_id"]}, {"columns": ["starship_pilot_id"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["starship_id"]}, {"columns": ["pilot_id"]}, {"columns": ["starship_pilot_id"]}], "unique_key": "starship_pilot_id"}, "created_at": 1742205059.192945, "relation_name": "\"nerd_facts\".\"public\".\"bridge_sw_starships_pilots\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['starship_id']}, {'columns': ['pilot_id']}, {'columns': ['starship_pilot_id']}],\n    unique_key = 'starship_pilot_id'\n  )\n}}\n\n/*\n  Model: bridge_sw_starships_pilots\n  Description: Bridge table connecting Star Wars starships to their pilots\n  \n  Notes:\n  - Handles the many-to-many relationship between starships and pilots\n  - Extracts pilot references from the nested arrays in starship data\n  - Calculates pilot skill classifications and experience metrics\n  - Identifies iconic starship-pilot combinations from the series\n  - Provides context for starship functionality and operational roles\n*/\n\nWITH starship_pilots AS (\n    -- Extract pilot references from the starships data with better error handling\n    SELECT\n        s.id AS starship_id,\n        s.name AS starship_name,\n        s.model,\n        s.manufacturer,\n        s.starship_class,\n        s.cost_in_credits::NUMERIC AS cost,\n        pilot_ref->>'url' AS pilot_url,\n        -- Extract pilot ID from URL with error handling\n        NULLIF(SPLIT_PART(COALESCE(pilot_ref->>'url', ''), '/', 6), '')::INTEGER AS pilot_id\n    FROM {{ ref('stg_swapi_starships') }} s,  -- Corrected reference\n    LATERAL jsonb_array_elements(\n        CASE WHEN s.pilots IS NULL OR s.pilots = 'null' OR jsonb_array_length(s.pilots) = 0 \n        THEN '[]'::jsonb ELSE s.pilots END\n    ) AS pilot_ref\n    WHERE s.id IS NOT NULL\n),\n\n-- Join with character information for context\npilot_details AS (\n    SELECT\n        sp.starship_id,\n        sp.starship_name,\n        sp.model,\n        sp.manufacturer,\n        sp.starship_class,\n        sp.cost,\n        sp.pilot_id,\n        p.name AS pilot_name,\n        p.species_id,\n        p.gender,\n        p.birth_year,\n        -- Determine if force sensitive based on known Jedi/Sith\n        CASE WHEN p.name IN (\n            'Luke Skywalker', 'Darth Vader', 'Obi-Wan Kenobi', 'Anakin Skywalker', \n            'Yoda', 'Palpatine', 'Rey', 'Kylo Ren', 'Mace Windu', 'Qui-Gon Jinn',\n            'Kit Fisto', 'Plo Koon', 'Luminara Unduli', 'Count Dooku', 'Darth Maul'\n        ) THEN TRUE ELSE FALSE END AS force_sensitive,\n        -- Calculate pilot's approximate age (if birth_year is available)\n        CASE \n            WHEN p.birth_year ~ '^[0-9]+(\\.[0-9]+)?$' THEN \n                CASE\n                    WHEN p.name = 'Yoda' THEN 900  -- Special case for Yoda\n                    ELSE COALESCE(p.birth_year::NUMERIC, 0)\n                END\n            ELSE 0\n        END AS pilot_age\n    FROM starship_pilots sp\n    LEFT JOIN {{ ref('stg_swapi_people') }} p ON sp.pilot_id = p.id\n),\n\n-- Get species information to enhance pilot context\npilot_species AS (\n    SELECT\n        pd.*,\n        s.name AS species_name,\n        s.classification AS species_classification,\n        s.average_lifespan\n    FROM pilot_details pd\n    LEFT JOIN {{ ref('stg_swapi_species') }} s ON pd.species_id = s.id\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['ps.starship_id', 'ps.pilot_id']) }} AS starship_pilot_id,\n    \n    -- Foreign keys to related dimensions\n    {{ dbt_utils.generate_surrogate_key(['ps.starship_id']) }} AS starship_key,\n    {{ dbt_utils.generate_surrogate_key(['ps.pilot_id']) }} AS pilot_key,\n    \n    -- Core identifiers\n    ps.starship_id,\n    ps.starship_name,\n    ps.pilot_id,\n    ps.pilot_name,\n    \n    -- Starship attributes\n    ps.model,\n    ps.manufacturer,\n    ps.starship_class,\n    ps.cost,\n    \n    -- Pilot attributes\n    ps.species_name,\n    ps.gender,\n    ps.birth_year,\n    ps.force_sensitive,\n    ps.pilot_age,\n    \n    -- Enhanced pilot skill classification with more nuance\n    CASE\n        -- Legendary pilots explicitly mentioned in lore\n        WHEN ps.pilot_name IN ('Han Solo', 'Luke Skywalker', 'Anakin Skywalker', \n                             'Poe Dameron', 'Wedge Antilles', 'Lando Calrissian') THEN 'Legendary'\n        \n        -- Known excellent pilots from expanded lore\n        WHEN ps.pilot_name IN ('Darth Vader', 'Jango Fett', 'Boba Fett', 'Hera Syndulla', \n                             'Rey', 'Chewbacca', 'Din Djarin', 'Cassian Andor') THEN 'Expert'\n        \n        -- Force users generally have enhanced piloting abilities\n        WHEN ps.force_sensitive THEN 'Force Enhanced'\n        \n        -- Pilots of military craft likely have formal training\n        WHEN ps.starship_class IN ('Starfighter', 'Assault Starfighter', 'Bomber', \n                                 'Interceptor', 'Light Cruiser') THEN 'Military Trained'\n        \n        -- Default for other cases\n        ELSE 'Standard'\n    END AS pilot_skill,\n    \n    -- Pilot experience level based on lore\n    CASE\n        WHEN ps.pilot_name IN ('Han Solo', 'Chewbacca', 'Lando Calrissian', 'Wedge Antilles') THEN 'Veteran'\n        WHEN ps.pilot_name IN ('Luke Skywalker', 'Poe Dameron', 'Darth Vader', 'Anakin Skywalker') THEN 'Advanced'\n        WHEN ps.pilot_name IN ('Rey', 'Finn', 'Din Djarin') THEN 'Intermediate'\n        ELSE 'Basic'\n    END AS pilot_experience,\n    \n    -- Calculate the number of known starships piloted by this character\n    COUNT(*) OVER (PARTITION BY ps.pilot_id) AS ships_piloted_count,\n    \n    -- Calculate pilot versatility based on how many different classes they pilot\n    COUNT(DISTINCT ps.starship_class) OVER (PARTITION BY ps.pilot_id) AS ship_class_versatility,\n    \n    -- Flag notable starship-pilot combinations with expanded list\n    CASE\n        WHEN (ps.pilot_name = 'Han Solo' AND ps.starship_name LIKE '%Millennium Falcon%') THEN TRUE\n        WHEN (ps.pilot_name = 'Luke Skywalker' AND ps.starship_name LIKE '%X-wing%') THEN TRUE\n        WHEN (ps.pilot_name = 'Darth Vader' AND ps.starship_name LIKE '%TIE Advanced%') THEN TRUE\n        WHEN (ps.pilot_name = 'Boba Fett' AND ps.starship_name LIKE '%Slave I%') THEN TRUE\n        WHEN (ps.pilot_name = 'Anakin Skywalker' AND ps.starship_name LIKE '%Jedi Starfighter%') THEN TRUE\n        WHEN (ps.pilot_name = 'Poe Dameron' AND ps.starship_name LIKE '%T-70 X-wing%') THEN TRUE\n        WHEN (ps.pilot_name = 'Rey' AND ps.starship_name LIKE '%Millennium Falcon%') THEN TRUE\n        WHEN (ps.pilot_name = 'Din Djarin' AND ps.starship_name LIKE '%Razor Crest%') THEN TRUE\n        WHEN (ps.pilot_name = 'Lando Calrissian' AND ps.starship_name LIKE '%Millennium Falcon%') THEN TRUE\n        WHEN (ps.pilot_name = 'Jango Fett' AND ps.starship_name LIKE '%Slave I%') THEN TRUE\n        ELSE FALSE\n    END AS is_iconic_pairing,\n    \n    -- Affiliation based on pilot\n    CASE\n        WHEN ps.pilot_name IN ('Luke Skywalker', 'Leia Organa', 'Han Solo', 'Chewbacca', \n                             'Lando Calrissian', 'Wedge Antilles', 'Poe Dameron', \n                             'Finn', 'Rey') THEN 'Rebellion/Resistance'\n        WHEN ps.pilot_name IN ('Darth Vader', 'Emperor Palpatine', 'General Grievous',\n                             'Darth Maul', 'Count Dooku', 'Kylo Ren') THEN 'Empire/First Order/Sith'\n        WHEN ps.pilot_name IN ('Anakin Skywalker', 'Obi-Wan Kenobi', 'Mace Windu', \n                             'Yoda', 'Qui-Gon Jinn', 'Padm\u00e9 Amidala') THEN 'Republic/Jedi'\n        WHEN ps.pilot_name IN ('Jango Fett', 'Boba Fett', 'Din Djarin') THEN 'Bounty Hunter/Independent'\n        ELSE 'Unknown'\n    END AS pilot_affiliation,\n    \n    -- Starship role classification\n    CASE\n        WHEN ps.starship_class IN ('Starfighter', 'Interceptor', 'Bomber', 'Assault Starfighter') THEN 'Combat'\n        WHEN ps.starship_class IN ('Light freighter', 'Medium freighter', 'Heavy freighter') THEN 'Transport'\n        WHEN ps.starship_class IN ('Yacht', 'Patrol craft', 'Sail barge', 'Speeder') THEN 'Personal'\n        WHEN ps.starship_class IN ('Star Destroyer', 'Battlecruiser', 'Cruiser', 'Star Dreadnought') THEN 'Capital Ship'\n        ELSE 'Utility'\n    END AS starship_role,\n    \n    -- Era classification\n    CASE\n        WHEN ps.pilot_name IN ('Anakin Skywalker', 'Obi-Wan Kenobi', 'Padm\u00e9 Amidala', \n                             'Qui-Gon Jinn', 'Mace Windu', 'Count Dooku', 'General Grievous') THEN 'Prequel Era'\n        WHEN ps.pilot_name IN ('Luke Skywalker', 'Han Solo', 'Leia Organa', 'Darth Vader', \n                             'Chewbacca', 'Lando Calrissian') THEN 'Original Trilogy Era'\n        WHEN ps.pilot_name IN ('Rey', 'Finn', 'Poe Dameron', 'Kylo Ren') THEN 'Sequel Era'\n        WHEN ps.pilot_name IN ('Din Djarin') THEN 'Mandalorian Era'\n        ELSE 'Unknown Era'\n    END AS story_era,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM pilot_species ps\nWHERE ps.pilot_id IS NOT NULL AND ps.starship_id IS NOT NULL\nORDER BY ps.starship_name, pilot_skill DESC, ps.pilot_name", "language": "sql", "refs": [{"name": "stg_swapi_starships", "package": null, "version": null}, {"name": "stg_swapi_people", "package": null, "version": null}, {"name": "stg_swapi_species", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_starships", "model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_swapi_species"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_characters": {"database": "nerd_facts", "schema": "public", "name": "dim_characters", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/core/dim_characters.sql", "original_file_path": "models/marts/core/dim_characters.sql", "unique_id": "model.nerd_facts_dbt.dim_characters", "fqn": ["nerd_facts_dbt", "marts", "core", "dim_characters"], "alias": "dim_characters", "checksum": {"name": "sha256", "checksum": "b220d03139491a4c762f083169f0873e82cc839c2ce5e65857b785b858b37f3a"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742205059.2005808, "relation_name": "\"nerd_facts\".\"public\".\"dim_characters\"", "raw_code": "/*\n  Model: dim_characters\n  Description: Combined dimension table for characters across fictional universes\n  \n  Notes:\n  - Combines Star Wars characters, Pok\u00e9mon, and Netrunner identities\n  - Standardizes attributes across universes for consistent analysis\n  - Adds surrogate keys and proper type handling\n  - Includes universe-specific attributes and shared classifications\n*/\n\nWITH sw_characters AS (\n    SELECT\n        'star_wars' AS universe,\n        'sw_' || id AS character_source_id,\n        name AS character_name,\n        species AS species,\n        homeworld_id AS home_location_id,\n        \n        -- Physical attributes\n        CASE \n            WHEN height_cm IS NULL THEN NULL\n            ELSE height_cm\n        END AS height_cm,\n        \n        CASE \n            WHEN mass_kg IS NULL THEN NULL\n            ELSE mass_kg\n        END AS weight_kg,\n        \n        -- Demographics\n        gender,\n        birth_year,\n        \n        -- Character attributes\n        force_sensitive AS has_special_powers,\n        force_rating AS power_level,\n        'Force' AS power_type,\n        \n        -- Additional SW-specific attributes\n        hair_color,\n        eye_color,\n        skin_color,\n        \n        -- Grouping fields\n        film_appearances AS appearance_count,\n        character_era AS primary_era,\n        \n        CURRENT_TIMESTAMP AS dbt_loaded_at\n    FROM {{ ref('stg_swapi_people') }}\n),\n\npokemon AS (\n    SELECT\n        'pokemon' AS universe,\n        'pkmn_' || id AS character_source_id,\n        name AS character_name,\n        primary_type AS species,\n        region AS home_location_id,\n        \n        -- Physical attributes (convert from decimeters to cm)\n        height * 10 AS height_cm, \n        weight AS weight_kg,\n        \n        -- Demographics (not applicable for Pok\u00e9mon)\n        NULL AS gender,\n        NULL AS birth_year,\n        \n        -- Character attributes (all Pok\u00e9mon have special powers)\n        TRUE AS has_special_powers,\n        CASE \n            WHEN is_legendary THEN 5\n            WHEN is_mythical THEN 5\n            WHEN total_base_stats > 580 THEN 4\n            WHEN total_base_stats > 500 THEN 3\n            WHEN total_base_stats > 400 THEN 2\n            ELSE 1\n        END AS power_level,\n        primary_type AS power_type,\n        \n        -- Additional Pok\u00e9mon-specific attributes\n        NULL AS hair_color,\n        NULL AS eye_color,\n        NULL AS skin_color,\n        \n        -- Grouping fields\n        1 AS appearance_count, -- Default for now\n        'Generation ' || generation_number AS primary_era,\n        \n        CURRENT_TIMESTAMP AS dbt_loaded_at\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n),\n\nnetrunner_identities AS (\n    SELECT\n        'netrunner' AS universe,\n        'nr_' || code AS character_source_id,\n        card_name AS character_name,\n        faction_name AS species,\n        NULL AS home_location_id,\n        \n        -- Physical attributes (not applicable for Netrunner)\n        NULL AS height_cm,\n        NULL AS weight_kg,\n        \n        -- Demographics (special handling for Netrunner)\n        CASE \n            WHEN side_name = 'Runner' THEN 'unknown'\n            ELSE 'Corporation'\n        END AS gender,\n        NULL AS birth_year,\n        \n        -- Character attributes\n        TRUE AS has_special_powers,\n        CASE\n            WHEN influence_limit > 15 THEN 4\n            WHEN influence_limit > 12 THEN 3\n            ELSE 2\n        END AS power_level,\n        card_type AS power_type,\n        \n        -- Additional Netrunner-specific attributes\n        NULL AS hair_color,\n        NULL AS eye_color,\n        NULL AS skin_color,\n        \n        -- Grouping fields\n        1 AS appearance_count, -- Default for now\n        NULL AS primary_era,\n        \n        CURRENT_TIMESTAMP AS dbt_loaded_at\n    FROM {{ ref('stg_netrunner_cards') }}\n    WHERE is_identity -- Only include identity cards as \"characters\"\n),\n\ncombined_characters AS (\n    SELECT * FROM sw_characters\n    UNION ALL\n    SELECT * FROM pokemon\n    UNION ALL\n    SELECT * FROM netrunner_identities\n)\n\n-- Create final dimension table with surrogate key\nSELECT\n    {{ dbt_utils.generate_surrogate_key(['universe', 'character_source_id']) }} AS character_key,\n    *,\n    \n    -- Add character classifications\n    CASE\n        WHEN has_special_powers AND power_level >= 4 THEN 'Legendary'\n        WHEN has_special_powers AND power_level >= 3 THEN 'Powerful'\n        WHEN has_special_powers THEN 'Gifted'\n        ELSE 'Ordinary'\n    END AS character_class,\n    \n    -- Height classification\n    CASE\n        WHEN height_cm IS NULL THEN 'Unknown'\n        WHEN height_cm < 30 THEN 'Tiny'\n        WHEN height_cm < 100 THEN 'Small'  \n        WHEN height_cm < 180 THEN 'Medium'\n        WHEN height_cm < 250 THEN 'Tall'\n        ELSE 'Giant'\n    END AS height_class\n\nFROM combined_characters", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "stg_netrunner_cards", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.stg_netrunner_cards"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_power_ratings": {"database": "nerd_facts", "schema": "public", "name": "fct_power_ratings", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/core/fct_power_ratings.sql", "original_file_path": "models/marts/core/fct_power_ratings.sql", "unique_id": "model.nerd_facts_dbt.fct_power_ratings", "fqn": ["nerd_facts_dbt", "marts", "core", "fct_power_ratings"], "alias": "fct_power_ratings", "checksum": {"name": "sha256", "checksum": "ebbb379ae3dcc36d191a308f8070466d2f5354d56f29cb98f6d46061eefe785e"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742205059.2078905, "relation_name": "\"nerd_facts\".\"public\".\"fct_power_ratings\"", "raw_code": "/*\n  Model: fct_power_ratings\n  Description: Cross-universe fact table for character power metrics and comparisons\n  \n  Notes:\n  - Combines power metrics from Star Wars, Pok\u00e9mon, and Netrunner universes\n  - Standardizes metrics across universes using common dimensions\n  - Creates normalized power scores for cross-universe comparisons\n  - Includes universe-specific attributes while maintaining consistent schema\n  \n  Power Score Calculation:\n  - base_power (60%): Raw power/strength of the character\n  - mobility (20%): Speed and movement capabilities\n  - battle_experience (20%): Combat experience and victories\n  \n  The final score is scaled to 0-100 for easy comparison\n*/\n\nWITH sw_power AS (\n    SELECT\n        {{ dbt_utils.generate_surrogate_key(['\\'star_wars\\'', 'c.character_source_id']) }} AS character_key,\n        'star_wars' AS universe,\n        p.id AS character_source_id,\n        p.name AS character_name,\n        CASE\n            WHEN COALESCE(p.force_sensitive, false) THEN \n                5 * COALESCE(p.force_rating, 1)\n            ELSE 1\n        END AS base_power,\n        COALESCE(p.ships_piloted, 0) AS mobility,\n        COALESCE(p.film_appearances, 0) * 2 AS battle_experience,\n        p.force_sensitive AS has_special_abilities\n    FROM {{ ref('stg_swapi_people') }} p\n),\n\npokemon_power AS (\n    SELECT\n        {{ dbt_utils.generate_surrogate_key(['\\'pokemon\\'', 'p.id::VARCHAR']) }} AS character_key,\n        'pokemon' AS universe,\n        p.id::VARCHAR AS character_source_id,\n        p.name AS character_name,\n        -- Use average of attack and special attack for balanced rating\n        (COALESCE(p.base_stat_attack, 0) + COALESCE(p.base_stat_special_attack, 0)) / 2 AS base_power,\n        COALESCE(p.base_stat_speed, 0) AS mobility,\n        -- Use generation as a proxy for battle experience (older = more experienced)\n        COALESCE(10 - p.generation_number, 0) * 5 AS battle_experience,\n        TRUE AS has_special_abilities -- All Pok\u00e9mon have abilities\n    FROM {{ ref('stg_pokeapi_pokemon') }} p\n),\n\nnetrunner_power AS (\n    SELECT\n        {{ dbt_utils.generate_surrogate_key(['\\'netrunner\\'', 'c.code']) }} AS character_key,\n        'netrunner' AS universe,\n        c.code AS character_source_id,\n        c.card_name AS character_name,\n        -- For Netrunner: base power is influence limit for identities\n        COALESCE(c.influence_limit, 0) * 2 AS base_power,\n        CASE\n            WHEN c.memory_cost IS NOT NULL THEN COALESCE(c.memory_cost, 0) * 5\n            ELSE 10 -- Default mobility\n        END AS mobility,\n        -- Use card cycle as proxy for battle experience\n        CASE\n            WHEN p.cycle_code IN ('core', 'genesis') THEN 40\n            WHEN p.cycle_code IN ('creation-and-control', 'spin') THEN 30\n            WHEN p.cycle_code IN ('lunar', 'sansan', 'mumbad') THEN 20\n            ELSE 10\n        END AS battle_experience,\n        c.is_unique AS has_special_abilities\n    FROM {{ ref('stg_netrunner_cards') }} c\n    LEFT JOIN {{ ref('stg_netrunner_packs') }} p ON c.pack_code = p.code\n    WHERE c.type_code = 'identity' -- Only include identity cards\n),\n\ncombined_power AS (\n    SELECT * FROM sw_power\n    UNION ALL\n    SELECT * FROM pokemon_power\n    UNION ALL\n    SELECT * FROM netrunner_power\n)\n\nSELECT\n    character_key,\n    universe,\n    character_source_id,\n    character_name,\n    base_power,\n    mobility,\n    battle_experience,\n    has_special_abilities,\n    \n    -- Normalized power score (0-100 scale)\n    GREATEST(0, LEAST(100, \n        ROUND((base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2))\n    )) AS normalized_power_score,\n    \n    -- Power tier classification\n    CASE\n        WHEN (base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2) >= 80 THEN 'S-Tier'\n        WHEN (base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2) >= 60 THEN 'A-Tier'\n        WHEN (base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2) >= 40 THEN 'B-Tier'\n        WHEN (base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2) >= 20 THEN 'C-Tier'\n        ELSE 'D-Tier'\n    END AS power_tier,\n    \n    -- Calculate universe-relative percentile (how powerful within their own universe)\n    PERCENT_RANK() OVER(PARTITION BY universe ORDER BY \n        (base_power * 0.6) + (mobility * 0.2) + (battle_experience * 0.2)\n    ) AS universe_power_percentile,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n\nFROM combined_power", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}, {"name": "stg_netrunner_cards", "package": null, "version": null}, {"name": "stg_netrunner_packs", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.fct_sw_characters": {"database": "nerd_facts", "schema": "public", "name": "fct_sw_characters", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/fct_sw_characters.sql", "original_file_path": "models/marts/star_wars/fct_sw_characters.sql", "unique_id": "model.nerd_facts_dbt.fct_sw_characters", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "fct_sw_characters"], "alias": "fct_sw_characters", "checksum": {"name": "sha256", "checksum": "be769e7e81021945e231698f7eb2f34d659de9fcd226696d7283660ad234936b"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "character_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["character_id"]}, {"columns": ["species_id"]}, {"columns": ["homeworld_id"]}, {"columns": ["character_tier"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["character_id"]}, {"columns": ["species_id"]}, {"columns": ["homeworld_id"]}, {"columns": ["character_tier"]}], "unique_key": "character_key"}, "created_at": 1742205059.2143004, "relation_name": "\"nerd_facts\".\"public\".\"fct_sw_characters\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['character_id']}, {'columns': ['species_id']}, {'columns': ['homeworld_id']}, {'columns': ['character_tier']}],\n    unique_key = 'character_key'\n  )\n}}\n\n/*\n  Model: fct_sw_characters\n  Description: Fact table for Star Wars characters with comprehensive attributes and metrics\n  \n  Notes:\n  - Contains detailed character information and derived attributes\n  - Provides character classifications by role, affiliation, and significance\n  - Calculates Force sensitivity and combat effectiveness ratings\n  - Enriches character context with Star Wars universe specifics\n  - Serves as the primary analytical table for character analysis\n*/\n\nWITH base_characters AS (\n    SELECT\n        id AS character_id,\n        name,\n        NULLIF(height, 'unknown')::NUMERIC AS height,\n        NULLIF(mass, 'unknown')::NUMERIC AS mass,\n        hair_color,\n        skin_color,\n        eye_color,\n        birth_year,\n        gender,\n        homeworld AS homeworld_id,\n        species_id,\n        -- Count vehicles and starships\n        COALESCE(JSONB_ARRAY_LENGTH(vehicles), 0) AS vehicles_count,\n        COALESCE(JSONB_ARRAY_LENGTH(starships), 0) AS starships_count,\n        -- Count total films\n        COALESCE(JSONB_ARRAY_LENGTH(films), 0) AS film_count\n    FROM {{ ref('stg_swapi_people') }}\n    WHERE id IS NOT NULL\n),\n\n-- Join with species information\ncharacter_species AS (\n    SELECT\n        c.*,\n        s.name AS species_name,\n        s.classification AS species_classification,\n        s.average_lifespan,\n        s.language\n    FROM base_characters c\n    LEFT JOIN {{ ref('stg_swapi_species') }} s ON c.species_id = s.id\n),\n\n-- Join with homeworld information\ncharacter_homeworld AS (\n    SELECT\n        cs.*,\n        p.name AS homeworld_name,\n        p.terrain AS homeworld_terrain,\n        p.climate AS homeworld_climate\n    FROM character_species cs\n    LEFT JOIN {{ ref('stg_swapi_planets') }} p ON cs.homeworld_id = p.id\n),\n\n-- Calculate force sensitivity and ratings with expanded logic\nforce_ratings AS (\n    SELECT\n        character_id,\n        -- Determine force sensitivity with more comprehensive list\n        CASE\n            WHEN LOWER(name) IN (\n                'luke skywalker', 'darth vader', 'leia organa', 'yoda', 'emperor palpatine', \n                'obi-wan kenobi', 'qui-gon jinn', 'mace windu', 'count dooku', 'darth maul',\n                'rey', 'kylo ren', 'anakin skywalker', 'ahsoka tano', 'plo koon',\n                'kit fisto', 'aayla secura', 'luminara unduli', 'barriss offee',\n                'asajj ventress', 'shaak ti', 'ki-adi-mundi', 'yaddle', 'ezra bridger',\n                'kanan jarrus', 'grogu', 'ben solo', 'sheev palpatine', 'snoke'\n            ) THEN TRUE\n            ELSE FALSE\n        END AS force_sensitive,\n        \n        -- Force rating on 1-10 scale with more comprehensive categorization\n        CASE\n            -- Legendary Force users\n            WHEN LOWER(name) IN ('yoda', 'emperor palpatine', 'darth vader', 'luke skywalker') THEN 10\n            \n            -- Very powerful Force users\n            WHEN LOWER(name) IN ('mace windu', 'count dooku', 'rey', 'kylo ren') THEN 9\n            \n            -- Powerful Jedi Masters / Sith Lords\n            WHEN LOWER(name) IN ('obi-wan kenobi', 'qui-gon jinn', 'darth maul') THEN 8\n            \n            -- Advanced Jedi / Dark Side users\n            WHEN LOWER(name) IN ('ahsoka tano', 'kit fisto', 'plo koon', 'ki-adi-mundi') THEN 7\n            \n            -- Trained Jedi / Force users\n            WHEN LOWER(name) IN ('luminara unduli', 'barriss offee', 'aayla secura') THEN 6\n            \n            -- Powerful but untrained\n            WHEN LOWER(name) IN ('grogu', 'leia organa') THEN 5\n            \n            -- All other known Force sensitives\n            WHEN LOWER(name) IN (\n                'ezra bridger', 'kanan jarrus', 'yaddle', 'shaak ti', 'asajj ventress'\n            ) THEN 4\n            \n            -- Default for force sensitives not explicitly rated\n            WHEN force_sensitive THEN 3\n            \n            -- Non-Force sensitive\n            ELSE 0\n        END AS force_rating,\n        \n        -- Force alignment\n        CASE\n            -- Light side users\n            WHEN LOWER(name) IN (\n                'luke skywalker', 'yoda', 'obi-wan kenobi', 'qui-gon jinn', 'mace windu',\n                'ahsoka tano', 'plo koon', 'kit fisto', 'aayla secura', 'luminara unduli',\n                'barriss offee', 'shaak ti', 'ki-adi-mundi', 'yaddle', 'kanan jarrus'\n            ) THEN 'Light Side'\n            \n            -- Dark side users\n            WHEN LOWER(name) IN (\n                'darth vader', 'emperor palpatine', 'count dooku', 'darth maul',\n                'kylo ren', 'asajj ventress', 'snoke'\n            ) THEN 'Dark Side'\n            \n            -- Characters who walked both paths\n            WHEN LOWER(name) IN ('rey', 'anakin skywalker', 'ben solo') THEN 'Both Light/Dark'\n            \n            -- Force sensitive but neutral/unknown alignment\n            WHEN force_sensitive THEN 'Neutral/Unknown'\n            \n            -- Not Force sensitive\n            ELSE 'Not Force Sensitive'\n        END AS force_alignment\n    FROM base_characters\n),\n\n-- Estimate combat experience and abilities with expanded classifications\nbattle_experience AS (\n    SELECT\n        ch.character_id,\n        ch.name,\n        ch.film_count,\n        ch.vehicles_count,\n        ch.starships_count,\n        fr.force_sensitive,\n        fr.force_rating,\n        \n        -- Enhanced battles won with more character context\n        CASE\n            -- Major heroes with known victories (higher counts)\n            WHEN LOWER(ch.name) IN ('luke skywalker', 'leia organa', 'han solo', 'darth vader') THEN \n                10 + ch.film_count + ch.starships_count\n                \n            -- Important fighters and warriors\n            WHEN LOWER(ch.name) IN ('boba fett', 'jango fett', 'chewbacca', 'lando calrissian',\n                               'finn', 'poe dameron', 'rey', 'kylo ren', 'cassian andor') THEN \n                8 + ch.film_count\n                \n            -- Established Jedi and Sith\n            WHEN LOWER(ch.name) IN ('obi-wan kenobi', 'qui-gon jinn', 'mace windu', \n                               'darth maul', 'count dooku', 'yoda', 'emperor palpatine') THEN \n                7 + fr.force_rating\n                \n            -- Military/combat characters\n            WHEN LOWER(ch.name) LIKE '%captain%' OR \n                 LOWER(ch.name) LIKE '%commander%' OR \n                 LOWER(ch.name) LIKE '%general%' THEN 6\n                 \n            -- Characters who likely have combat experience\n            WHEN ch.starships_count > 0 THEN 3 + ch.starships_count -- Pilots typically see combat\n            WHEN ch.vehicles_count > 0 THEN 2 + ch.vehicles_count -- Vehicle operators likely have some combat\n            WHEN fr.force_sensitive THEN 3 + fr.force_rating -- Force users typically engage in combat\n            \n            -- Everyone else gets minimal combat experience based on films\n            ELSE GREATEST(1, ch.film_count)\n        END AS battles_won,\n        \n        -- Derive more detailed combat role\n        CASE\n            -- Force users by type\n            WHEN fr.force_alignment = 'Light Side' AND fr.force_rating >= 7 THEN 'Jedi Master'\n            WHEN fr.force_alignment = 'Light Side' AND fr.force_rating >= 3 THEN 'Jedi Knight'\n            WHEN fr.force_alignment = 'Dark Side' AND fr.force_rating >= 7 THEN 'Sith Lord'\n            WHEN fr.force_alignment = 'Dark Side' AND fr.force_rating >= 3 THEN 'Dark Side User'\n            \n            -- Specific roles based on character knowledge\n            WHEN LOWER(ch.name) IN ('han solo', 'lando calrissian', 'poe dameron') THEN 'Ace Pilot'\n            WHEN LOWER(ch.name) IN ('boba fett', 'jango fett', 'cad bane') THEN 'Bounty Hunter'\n            WHEN LOWER(ch.name) IN ('padm\u00e9 amidala', 'mon mothma', 'bail organa') THEN 'Political Leader'\n            WHEN LOWER(ch.name) IN ('c-3po', 'r2-d2', 'bb-8') THEN 'Droid'\n            WHEN LOWER(ch.name) IN ('general grievous') THEN 'Cyborg Commander'\n            \n            -- Derive roles from attributes\n            WHEN LOWER(ch.name) LIKE '%general%' OR LOWER(ch.name) LIKE '%admiral%' THEN 'Military Commander'\n            WHEN LOWER(ch.name) LIKE '%captain%' OR LOWER(ch.name) LIKE '%commander%' THEN 'Military Officer'\n            \n            -- Role based on vehicles/starships\n            WHEN ch.starships_count > 1 THEN 'Pilot'\n            WHEN ch.vehicles_count > 1 THEN 'Vehicle Operator'\n            WHEN fr.force_sensitive THEN 'Force Sensitive'\n            ELSE 'Support/Other'\n        END AS combat_role,\n        \n        -- Battle effectiveness on 1-10 scale\n        CASE\n            -- Legendary warriors\n            WHEN LOWER(ch.name) IN ('darth vader', 'yoda', 'luke skywalker', 'emperor palpatine') THEN 10\n            \n            -- Elite fighters\n            WHEN LOWER(ch.name) IN ('boba fett', 'jango fett', 'mace windu', 'general grievous',\n                               'obi-wan kenobi', 'count dooku', 'darth maul') THEN 9\n                               \n            -- Accomplished fighters\n            WHEN LOWER(ch.name) IN ('han solo', 'leia organa', 'kylo ren', 'rey', 'poe dameron', \n                               'finn', 'qui-gon jinn', 'chewbacca') THEN 8\n                               \n            -- Skilled combatants\n            WHEN LOWER(ch.name) IN ('lando calrissian', 'padm\u00e9 amidala', 'cassian andor',\n                               'jyn erso', 'din djarin', 'cara dune', 'ahsoka tano') THEN 7\n                               \n            -- Force users get a base effectiveness plus their force rating\n            WHEN fr.force_sensitive THEN LEAST(9, 4 + (fr.force_rating / 2))\n            \n            -- Pilots get decent effectiveness\n            WHEN ch.starships_count > 0 THEN LEAST(7, 4 + ch.starships_count)\n            \n            -- Everyone else scaled by films and vehicles\n            ELSE GREATEST(2, LEAST(6, 2 + ch.film_count + ch.vehicles_count))\n        END AS battle_effectiveness\n    FROM character_homeworld ch\n    JOIN force_ratings fr ON ch.character_id = fr.character_id\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['be.character_id']) }} AS character_key,\n    \n    -- Core identifiers\n    be.character_id,\n    be.name AS character_name,\n    \n    -- Dimension references with proper keys\n    be.homeworld_id,\n    ch.homeworld_name,\n    be.species_id,\n    ch.species_name,\n    \n    -- Physical attributes with better formatting\n    CASE WHEN ch.height IS NOT NULL THEN ch.height ELSE NULL END AS height_cm,\n    CASE \n        WHEN ch.height IS NOT NULL \n        THEN FLOOR(ch.height / 100) || 'm ' || MOD(FLOOR(ch.height), 100) || 'cm'\n        ELSE 'Unknown'\n    END AS height_formatted,\n    \n    CASE WHEN ch.mass IS NOT NULL THEN ch.mass ELSE NULL END AS mass_kg,\n    CASE \n        WHEN ch.mass IS NOT NULL \n        THEN ch.mass || ' kg'\n        ELSE 'Unknown'\n    END AS mass_formatted,\n    \n    -- Improved BMI calculation with better error handling\n    CASE \n        WHEN ch.height IS NOT NULL AND ch.mass IS NOT NULL AND ch.height > 0 \n        THEN ROUND(ch.mass / POWER(ch.height/100, 2), 1)\n        ELSE NULL\n    END AS bmi,\n    \n    -- Character classification\n    CASE \n        WHEN ch.gender IS NOT NULL THEN ch.gender \n        WHEN LOWER(ch.species_name) LIKE '%droid%' THEN 'Droid' \n        ELSE 'Unknown'\n    END AS gender,\n    \n    ch.birth_year,\n    ch.hair_color,\n    ch.eye_color,\n    ch.skin_color,\n    \n    -- Species attributes\n    ch.species_classification,\n    ch.average_lifespan,\n    ch.language,\n    \n    -- Homeworld attributes\n    ch.homeworld_climate,\n    ch.homeworld_terrain,\n    \n    -- Force powers and alignment\n    be.force_sensitive,\n    be.force_rating,\n    fr.force_alignment,\n    \n    -- Combat metrics\n    be.combat_role,\n    be.battles_won,\n    be.battle_effectiveness,\n    \n    -- Vehicle and film stats\n    be.starships_count,\n    be.vehicles_count,\n    be.film_count,\n    \n    -- Character importance and affiliation\n    -- Character affiliation with extensive mapping\n    CASE\n        -- Rebel/Resistance affiliated\n        WHEN LOWER(be.name) IN ('luke skywalker', 'leia organa', 'han solo', 'chewbacca',\n                            'lando calrissian', 'mon mothma', 'admiral ackbar',\n                            'wedge antilles', 'poe dameron', 'finn', 'rey') THEN 'Rebel Alliance/Resistance'\n        \n        -- Empire/First Order affiliated\n        WHEN LOWER(be.name) IN ('darth vader', 'emperor palpatine', 'grand moff tarkin', \n                            'general hux', 'captain phasma', 'kylo ren', 'director krennic',\n                            'moff gideon') THEN 'Empire/First Order'\n        \n        -- Republic affiliated\n        WHEN LOWER(be.name) IN ('padm\u00e9 amidala', 'bail organa', 'captain panaka',\n                            'jar jar binks', 'clone troopers') THEN 'Galactic Republic'\n        \n        -- Jedi Order\n        WHEN LOWER(be.name) IN ('yoda', 'mace windu', 'qui-gon jinn', 'obi-wan kenobi',\n                            'ki-adi-mundi', 'plo koon', 'kit fisto', 'shaak ti',\n                            'luminara unduli', 'barriss offee', 'aayla secura') THEN 'Jedi Order'\n        \n        -- Sith/Dark Side\n        WHEN LOWER(be.name) IN ('count dooku', 'darth maul', 'asajj ventress', 'savage opress', 'snoke') THEN 'Sith/Dark Side'\n        \n        -- Criminal/Underworld\n        WHEN LOWER(be.name) IN ('jabba the hutt', 'boba fett', 'jango fett', 'greedo', 'dengar',\n                            'bossk', 'zam wesell', 'aurra sing') THEN 'Criminal/Bounty Hunter'\n        \n        -- Neutral/Independent\n        WHEN LOWER(be.name) IN ('maz kanata', 'unkar plutt', 'watto', 'dex', 'dr. evazan') THEN 'Neutral/Independent'\n        \n        -- Separatist\n        WHEN LOWER(be.name) IN ('general grievous', 'nute gunray', 'wat tambor', 'poggle the lesser') THEN 'Separatist Alliance'\n        \n        -- Droids typically follow their masters\n        WHEN LOWER(be.name) IN ('r2-d2', 'c-3po', 'bb-8') THEN 'Rebel Alliance/Resistance'\n        WHEN LOWER(be.name) IN ('battle droids', 'super battle droids') THEN 'Separatist Alliance'\n        \n        ELSE 'Unaffiliated/Unknown'\n    END AS character_affiliation,\n    \n    -- Character significance tier\n    CASE\n        -- Main protagonists/antagonists\n        WHEN LOWER(be.name) IN ('luke skywalker', 'darth vader', 'leia organa', 'han solo',\n                            'rey', 'kylo ren', 'anakin skywalker', 'obi-wan kenobi',\n                            'emperor palpatine', 'yoda') THEN 'S'\n        \n        -- Major supporting characters\n        WHEN LOWER(be.name) IN ('chewbacca', 'r2-d2', 'c-3po', 'lando calrissian',\n                            'padm\u00e9 amidala', 'qui-gon jinn', 'mace windu', 'bb-8',\n                            'poe dameron', 'finn', 'count dooku', 'darth maul', \n                            'boba fett', 'jango fett', 'grand moff tarkin') THEN 'A'\n        \n        -- Important secondary characters\n        WHEN LOWER(be.name) IN ('admiral ackbar', 'mon mothma', 'wedge antilles',\n                            'general grievous', 'jabba the hutt', 'watto',\n                            'ki-adi-mundi', 'bail organa', 'jar jar binks',\n                            'captain phasma', 'general hux', 'greedo', \n                            'uncle owen', 'aunt beru') THEN 'B'\n        \n        -- Minor characters with multiple appearances\n        WHEN be.film_count > 1 THEN 'C'\n        \n        -- One-off characters\n        ELSE 'D'\n    END AS character_tier,\n    \n    -- Era appearance classification\n    CASE\n        WHEN LOWER(be.name) IN ('qui-gon jinn', 'darth maul', 'watto', 'jar jar binks',\n                            'young anakin', 'shmi skywalker', 'padm\u00e9 amidala',\n                            'nute gunray', 'captain panaka', 'sebulba', 'kitster',\n                            'ric oli\u00e9', 'boss nass', 'rune haako') THEN 'Prequel Era Only'\n                            \n        WHEN LOWER(be.name) IN ('count dooku', 'jango fett', 'zam wesell', 'dexter jettster',\n                            'bail organa', 'cliegg lars', 'san hill', 'taun we', 'wat tambor',\n                            'shaak ti', 'barriss offee', 'clone troopers') THEN 'Prequel Era Only'\n                            \n        WHEN LOWER(be.name) IN ('grand moff tarkin', 'jabba the hutt', 'greedo', 'biggs darklighter',\n                            'wedge antilles', 'admiral ackbar', 'mon mothma', 'wicket w. warrick',\n                            'admiral piett', 'general veers', 'boba fett', 'bossk',\n                            'lobot') THEN 'Original Trilogy Only'\n                            \n        -- Correctly implemented:\n        WHEN LOWER(be.name) IN ('rey', 'finn', 'poe dameron', 'bb-8', 'kylo ren',\n                            'general hux', 'supreme leader snoke', 'captain phasma',\n                            'maz kanata', 'lor san tekka', 'unkar plutt') THEN 'Sequel Era Only'\n                            \n        WHEN LOWER(be.name) IN ('luke skywalker', 'leia organa', 'han solo', 'chewbacca',\n                            'r2-d2', 'c-3po', 'darth vader', 'emperor palpatine',\n                            'yoda', 'obi-wan kenobi', 'lando calrissian') THEN 'Multiple Eras'\n                            \n        ELSE 'Unknown Era'\n    END AS era_appearance,\n    \n    -- Popularity score on 1-100 scale\n    GREATEST(1, LEAST(100, \n        CASE\n            -- S-tier characters\n            WHEN LOWER(be.name) IN ('luke skywalker', 'darth vader') THEN 95\n            WHEN LOWER(be.name) IN ('leia organa', 'han solo', 'yoda') THEN 90\n            WHEN LOWER(be.name) IN ('r2-d2', 'c-3po', 'chewbacca', 'obi-wan kenobi') THEN 85\n            \n            -- A-tier characters\n            WHEN LOWER(be.name) IN ('boba fett', 'emperor palpatine', 'lando calrissian') THEN 80\n            WHEN LOWER(be.name) IN ('rey', 'kylo ren', 'bb-8', 'qui-gon jinn') THEN 75\n            \n            -- B-tier characters\n            WHEN LOWER(be.name) IN ('mace windu', 'padm\u00e9 amidala', 'anakin skywalker') THEN 70\n            WHEN LOWER(be.name) IN ('count dooku', 'darth maul', 'jabba the hutt', 'jango fett') THEN 65\n            \n            -- Based on appearances and role\n            ELSE (\n                (COALESCE(be.film_count, 0) * 10) +  -- Films are important\n                (CASE WHEN be.force_sensitive THEN 15 ELSE 0 END) +  -- Force users are popular\n                (CASE WHEN be.starships_count > 0 THEN 10 ELSE 0 END) +  -- Pilots are cool\n                (CASE \n                    WHEN be.combat_role IN ('Jedi Master', 'Sith Lord', 'Bounty Hunter', 'Ace Pilot') THEN 15\n                    WHEN be.combat_role IN ('Jedi Knight', 'Dark Side User', 'Military Commander') THEN 10\n                    ELSE 0 \n                END)\n            )\n        END\n    )) AS popularity_score,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM battle_experience be\nJOIN character_homeworld ch ON be.character_id = ch.character_id\nJOIN force_ratings fr ON be.character_id = fr.character_id\nORDER BY character_tier, popularity_score DESC", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}, {"name": "stg_swapi_species", "package": null, "version": null}, {"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_swapi_species", "model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_swapi_people": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_people", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_people.sql", "original_file_path": "models/staging/swapi/stg_swapi_people.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_people", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_people"], "alias": "stg_swapi_people", "checksum": {"name": "sha256", "checksum": "6ffc2ba8dc12989098358ef3519a4e5a2a6dcced3d8f18ffc1ab27c55b50382b"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars character data with derived attributes and force sensitivity", "columns": {"id": {"name": "id", "description": "Primary key for characters", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Character name", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "height": {"name": "height", "description": "Height in centimeters", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "mass": {"name": "mass", "description": "Mass in kilograms", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "hair_color": {"name": "hair_color", "description": "Hair color", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "skin_color": {"name": "skin_color", "description": "Skin color", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "eye_color": {"name": "eye_color", "description": "Eye color", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "birth_year": {"name": "birth_year", "description": "Birth year using in-universe BBY/ABY dating system", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "gender": {"name": "gender", "description": "Character gender", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "homeworld": {"name": "homeworld", "description": "ID of character's homeworld", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "species_id": {"name": "species_id", "description": "ID of character's species", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "vehicles": {"name": "vehicles", "description": "JSONB array of vehicles piloted", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "starships": {"name": "starships", "description": "JSONB array of starships piloted", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "films": {"name": "films", "description": "JSONB array of film appearances", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_people.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742205059.3463988, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_people\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_people\n  Description: Standardizes Star Wars character data from SWAPI\n  Source: raw.swapi_people\n  \n  Notes:\n  - Species and homeworld are extracted from JSON references\n  - Force sensitivity is derived from character appearances and names\n  - Physical attributes are cleaned and converted to proper numeric types\n  - Additional derived fields are added for character analysis\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        height,\n        mass,\n        hair_color,\n        skin_color,\n        eye_color,\n        birth_year,\n        gender,\n        homeworld,\n        films,\n        species,\n        vehicles,\n        starships,\n        created,\n        edited,\n        url\n    FROM {{ source('swapi', 'people') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name,\n    \n    -- Extract species information with improved error handling\n    CASE \n        WHEN species IS NULL OR jsonb_array_length(species) = 0 THEN 'Human'  -- Default to Human if no species\n        WHEN jsonb_typeof(species) != 'array' THEN 'Unknown'  -- Handle unexpected JSON type\n        ELSE COALESCE(SPLIT_PART(species->0->>'url', '/', 6), 'Unknown')  -- Extract ID from URL\n    END AS species,\n    \n    -- Extract homeworld ID with error handling\n    CASE\n        WHEN homeworld IS NULL THEN NULL\n        WHEN jsonb_typeof(homeworld) != 'object' THEN NULL\n        ELSE NULLIF(SPLIT_PART(homeworld->>'url', '/', 6), '')\n    END AS homeworld_id,\n    \n    -- Clean numeric values with comprehensive error handling\n    CASE \n        WHEN height IS NULL OR lower(height) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS height_cm,\n    \n    CASE \n        WHEN mass IS NULL OR lower(mass) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS mass_kg,\n    \n    -- Calculate BMI if both height and mass are available\n    CASE\n        WHEN height IS NOT NULL AND mass IS NOT NULL \n             AND NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '') != ''\n             AND NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '') != ''\n             AND height::NUMERIC > 0\n        THEN (NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '')::NUMERIC) / \n             POWER((NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '')::NUMERIC / 100), 2)\n        ELSE NULL\n    END AS bmi,\n    \n    -- Character physical attributes with standardized colors\n    LOWER(COALESCE(hair_color, 'unknown')) AS hair_color,\n    LOWER(COALESCE(skin_color, 'unknown')) AS skin_color,\n    LOWER(COALESCE(eye_color, 'unknown')) AS eye_color,\n    birth_year,\n    LOWER(COALESCE(gender, 'unknown')) AS gender,\n    \n    -- Force-user related fields with expanded detection\n    CASE\n        -- Check film appearances\n        WHEN films @> '[{\"title\": \"Return of the Jedi\"}]' \n             OR films @> '[{\"title\": \"The Empire Strikes Back\"}]'\n             OR films @> '[{\"title\": \"Revenge of the Sith\"}]'\n        -- Explicit Jedi/Sith list\n        OR LOWER(name) IN ('luke skywalker', 'darth vader', 'obi-wan kenobi', 'yoda', \n                          'emperor palpatine', 'count dooku', 'qui-gon jinn', 'mace windu',\n                          'rey', 'kylo ren')\n        THEN TRUE\n        ELSE FALSE\n    END AS force_sensitive,\n    \n    -- Force rating for known powerful force users\n    CASE\n        WHEN LOWER(name) IN ('yoda', 'emperor palpatine', 'darth vader', 'luke skywalker') THEN 5\n        WHEN LOWER(name) IN ('obi-wan kenobi', 'mace windu', 'kylo ren', 'rey') THEN 4\n        WHEN LOWER(name) IN ('qui-gon jinn', 'count dooku') THEN 3\n        WHEN force_sensitive THEN 2\n        ELSE NULL\n    END AS force_rating,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(starships), 0) AS ships_piloted,\n    COALESCE(jsonb_array_length(vehicles), 0) AS vehicles_operated,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    films,\n    starships,\n    vehicles,\n    \n    -- Era classification\n    CASE\n        WHEN films @> '[{\"title\": \"The Phantom Menace\"}]' \n             OR films @> '[{\"title\": \"Attack of the Clones\"}]'\n             OR films @> '[{\"title\": \"Revenge of the Sith\"}]'\n        THEN 'Prequel Era'\n        WHEN films @> '[{\"title\": \"A New Hope\"}]'\n             OR films @> '[{\"title\": \"The Empire Strikes Back\"}]'\n             OR films @> '[{\"title\": \"Return of the Jedi\"}]'\n        THEN 'Original Trilogy Era'\n        WHEN films @> '[{\"title\": \"The Force Awakens\"}]'\n             OR films @> '[{\"title\": \"The Last Jedi\"}]'\n        THEN 'Sequel Era'\n        ELSE 'Unknown Era'\n    END AS character_era,\n    \n    -- API metadata with proper handling\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [["swapi", "people"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.swapi.people"]}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_people.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_people\n  Description: Standardizes Star Wars character data from SWAPI\n  Source: raw.swapi_people\n  \n  Notes:\n  - Species and homeworld are extracted from JSON references\n  - Force sensitivity is derived from character appearances and names\n  - Physical attributes are cleaned and converted to proper numeric types\n  - Additional derived fields are added for character analysis\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        height,\n        mass,\n        hair_color,\n        skin_color,\n        eye_color,\n        birth_year,\n        gender,\n        homeworld,\n        films,\n        species,\n        vehicles,\n        starships,\n        created,\n        edited,\n        url\n    FROM \"nerd_facts\".\"raw\".\"swapi_people\"\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name,\n    \n    -- Extract species information with improved error handling\n    CASE \n        WHEN species IS NULL OR jsonb_array_length(species) = 0 THEN 'Human'  -- Default to Human if no species\n        WHEN jsonb_typeof(species) != 'array' THEN 'Unknown'  -- Handle unexpected JSON type\n        ELSE COALESCE(SPLIT_PART(species->0->>'url', '/', 6), 'Unknown')  -- Extract ID from URL\n    END AS species,\n    \n    -- Extract homeworld ID with error handling\n    CASE\n        WHEN homeworld IS NULL THEN NULL\n        WHEN jsonb_typeof(homeworld) != 'object' THEN NULL\n        ELSE NULLIF(SPLIT_PART(homeworld->>'url', '/', 6), '')\n    END AS homeworld_id,\n    \n    -- Clean numeric values with comprehensive error handling\n    CASE \n        WHEN height IS NULL OR lower(height) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS height_cm,\n    \n    CASE \n        WHEN mass IS NULL OR lower(mass) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS mass_kg,\n    \n    -- Calculate BMI if both height and mass are available\n    CASE\n        WHEN height IS NOT NULL AND mass IS NOT NULL \n             AND NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '') != ''\n             AND NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '') != ''\n             AND height::NUMERIC > 0\n        THEN (NULLIF(REGEXP_REPLACE(mass, '[^0-9\\.]', '', 'g'), '')::NUMERIC) / \n             POWER((NULLIF(REGEXP_REPLACE(height, '[^0-9\\.]', '', 'g'), '')::NUMERIC / 100), 2)\n        ELSE NULL\n    END AS bmi,\n    \n    -- Character physical attributes with standardized colors\n    LOWER(COALESCE(hair_color, 'unknown')) AS hair_color,\n    LOWER(COALESCE(skin_color, 'unknown')) AS skin_color,\n    LOWER(COALESCE(eye_color, 'unknown')) AS eye_color,\n    birth_year,\n    LOWER(COALESCE(gender, 'unknown')) AS gender,\n    \n    -- Force-user related fields with expanded detection\n    CASE\n        -- Check film appearances\n        WHEN films @> '[{\"title\": \"Return of the Jedi\"}]' \n             OR films @> '[{\"title\": \"The Empire Strikes Back\"}]'\n             OR films @> '[{\"title\": \"Revenge of the Sith\"}]'\n        -- Explicit Jedi/Sith list\n        OR LOWER(name) IN ('luke skywalker', 'darth vader', 'obi-wan kenobi', 'yoda', \n                          'emperor palpatine', 'count dooku', 'qui-gon jinn', 'mace windu',\n                          'rey', 'kylo ren')\n        THEN TRUE\n        ELSE FALSE\n    END AS force_sensitive,\n    \n    -- Force rating for known powerful force users\n    CASE\n        WHEN LOWER(name) IN ('yoda', 'emperor palpatine', 'darth vader', 'luke skywalker') THEN 5\n        WHEN LOWER(name) IN ('obi-wan kenobi', 'mace windu', 'kylo ren', 'rey') THEN 4\n        WHEN LOWER(name) IN ('qui-gon jinn', 'count dooku') THEN 3\n        WHEN force_sensitive THEN 2\n        ELSE NULL\n    END AS force_rating,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(starships), 0) AS ships_piloted,\n    COALESCE(jsonb_array_length(vehicles), 0) AS vehicles_operated,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    films,\n    starships,\n    vehicles,\n    \n    -- Era classification\n    CASE\n        WHEN films @> '[{\"title\": \"The Phantom Menace\"}]' \n             OR films @> '[{\"title\": \"Attack of the Clones\"}]'\n             OR films @> '[{\"title\": \"Revenge of the Sith\"}]'\n        THEN 'Prequel Era'\n        WHEN films @> '[{\"title\": \"A New Hope\"}]'\n             OR films @> '[{\"title\": \"The Empire Strikes Back\"}]'\n             OR films @> '[{\"title\": \"Return of the Jedi\"}]'\n        THEN 'Original Trilogy Era'\n        WHEN films @> '[{\"title\": \"The Force Awakens\"}]'\n             OR films @> '[{\"title\": \"The Last Jedi\"}]'\n        THEN 'Sequel Era'\n        ELSE 'Unknown Era'\n    END AS character_era,\n    \n    -- API metadata with proper handling\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "model.nerd_facts_dbt.dim_locations": {"database": "nerd_facts", "schema": "public", "name": "dim_locations", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/core/dim_locations.sql", "original_file_path": "models/marts/core/dim_locations.sql", "unique_id": "model.nerd_facts_dbt.dim_locations", "fqn": ["nerd_facts_dbt", "marts", "core", "dim_locations"], "alias": "dim_locations", "checksum": {"name": "sha256", "checksum": "8bc91c96f5b3373e2fa2e58ec4a6c90df1d53db76f2921503499b1e2a04294ed"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table"}, "created_at": 1742205059.2232335, "relation_name": "\"nerd_facts\".\"public\".\"dim_locations\"", "raw_code": "/*\n  Model: dim_locations\n  Description: Consolidated dimension table for locations across fictional universes\n  \n  Notes:\n  - Combines Star Wars planets, Pok\u00e9mon regions, and Netrunner locations\n  - Standardizes physical attributes across universes\n  - Adds derived classification fields for habitability and environment\n  - Includes universe-specific attributes while maintaining consistent schema\n*/\n\nWITH sw_planets AS (\n    SELECT\n        'sw_' || id AS source_id,\n        'star_wars' AS universe,\n        planet_name AS location_name,  -- Updated to match improved staging model naming\n        'Planet' AS location_type,\n        diameter,\n        rotation_period,\n        orbital_period,\n        gravity,\n        population,\n        climate,\n        terrain,\n        surface_water\n    FROM {{ ref('stg_swapi_planets') }}\n),\n\npokemon_regions AS (\n    -- Extract distinct regions from Pok\u00e9mon data\n    SELECT DISTINCT\n        -- Generate source_id from region name\n        'pkm_' || {{ dbt_utils.generate_surrogate_key(['region']) }} AS source_id,\n        'pokemon' AS universe,\n        region AS location_name,\n        'Region' AS location_type,\n        NULL AS diameter,\n        NULL AS rotation_period,\n        NULL AS orbital_period,\n        '1 standard' AS gravity,  -- Earth-like gravity\n        CASE  -- Approximate population based on region\n            WHEN region = 'Kanto' THEN 10000000\n            WHEN region = 'Johto' THEN 9000000\n            WHEN region = 'Hoenn' THEN 7500000\n            WHEN region = 'Sinnoh' THEN 8500000\n            WHEN region = 'Unova' THEN 12000000\n            WHEN region = 'Kalos' THEN 11000000\n            WHEN region = 'Alola' THEN 1000000\n            WHEN region = 'Galar' THEN 15000000\n            WHEN region = 'Paldea' THEN 14000000  -- Added new region\n            ELSE 5000000\n        END AS population,\n        CASE  -- Climate based on region\n            WHEN region = 'Kanto' THEN 'temperate'\n            WHEN region = 'Johto' THEN 'temperate'\n            WHEN region = 'Hoenn' THEN 'tropical'\n            WHEN region = 'Sinnoh' THEN 'cold, temperate'\n            WHEN region = 'Unova' THEN 'varied, metropolitan'\n            WHEN region = 'Kalos' THEN 'temperate, varied'\n            WHEN region = 'Alola' THEN 'tropical'\n            WHEN region = 'Galar' THEN 'temperate, cold'\n            WHEN region = 'Paldea' THEN 'mediterranean, varied'  -- Added new region\n            ELSE 'varied'\n        END AS climate,\n        CASE  -- Terrain based on region\n            WHEN region = 'Kanto' THEN 'mountains, forests, urban'\n            WHEN region = 'Johto' THEN 'mountains, forests, rural'\n            WHEN region = 'Hoenn' THEN 'islands, volcanoes, forests'\n            WHEN region = 'Sinnoh' THEN 'mountains, lakes, snow'\n            WHEN region = 'Unova' THEN 'urban, bridges, desert'\n            WHEN region = 'Kalos' THEN 'mountains, urban, coastal'\n            WHEN region = 'Alola' THEN 'islands, beaches, volcanoes'\n            WHEN region = 'Galar' THEN 'countryside, industrial, hills'\n            WHEN region = 'Paldea' THEN 'mountains, lakes, coastal, olive groves'  -- Added new region\n            ELSE 'varied'\n        END AS terrain,\n        CASE  -- Surface water percentage based on region\n            WHEN region = 'Hoenn' THEN 70\n            WHEN region = 'Alola' THEN 80\n            WHEN region = 'Sinnoh' THEN 40\n            WHEN region = 'Kanto' THEN 30\n            WHEN region = 'Johto' THEN 25\n            WHEN region = 'Unova' THEN 35\n            WHEN region = 'Kalos' THEN 30\n            WHEN region = 'Galar' THEN 20\n            WHEN region = 'Paldea' THEN 45  -- Added new region\n            ELSE 30\n        END AS surface_water\n    FROM {{ ref('stg_pokeapi_pokemon') }}\n    WHERE region IS NOT NULL\n),\n\nnetrunner_locations AS (\n    -- Create major Netrunner universe locations based on lore\n    SELECT * FROM (VALUES\n        ('nr_1001', 'netrunner', 'New Angeles', 'Megacity', NULL, NULL, NULL, 'high', 500000000, 'temperate, controlled', 'urban, corporate', 10),\n        ('nr_1002', 'netrunner', 'The Moon', 'Colony', 3474, 27.3, 27.3, 'low', 5000000, 'artificial', 'lunar, domes', 0),\n        ('nr_1003', 'netrunner', 'ChiLo', 'District', NULL, NULL, NULL, 'standard', 80000000, 'temperate', 'urban sprawl', 15),\n        ('nr_1004', 'netrunner', 'Mars', 'Colony', 6779, 24.6, 687, 'low', 2000000, 'arid, cold', 'desert, domes', 0),\n        ('nr_1005', 'netrunner', 'Heinlein', 'Orbital', NULL, NULL, NULL, 'artificial', 50000, 'artificial', 'station, corporate', 0),\n        ('nr_1006', 'netrunner', 'Mumbad', 'Megacity', NULL, NULL, NULL, 'standard', 450000000, 'tropical, monsoon', 'urban, slums', 20),\n        ('nr_1007', 'netrunner', 'Jinteki Biotech Labs', 'Facility', NULL, NULL, NULL, 'standard', 15000, 'controlled', 'research, corporate', 5)  -- Added new location\n    ) AS v(source_id, universe, location_name, location_type, diameter, rotation_period, orbital_period, gravity, population, climate, terrain, surface_water)\n),\n\n-- Combine all locations\nall_locations AS (\n    SELECT * FROM sw_planets\n    UNION ALL\n    SELECT * FROM pokemon_regions\n    UNION ALL\n    SELECT * FROM netrunner_locations\n)\n\nSELECT\n    {{ dbt_utils.generate_surrogate_key(['universe', 'source_id']) }} AS location_key,\n    source_id,\n    universe,\n    location_name,\n    location_type,\n    \n    -- Physical attributes with proper NULL handling\n    diameter,\n    rotation_period,\n    orbital_period,\n    COALESCE(gravity, 'unknown') AS gravity,\n    population,\n    COALESCE(climate, 'unknown') AS climate,\n    COALESCE(terrain, 'unknown') AS terrain,\n    surface_water,\n    \n    -- Derived classifications\n    CASE\n        WHEN population IS NULL THEN 'Unknown'\n        WHEN population = 0 THEN 'Uninhabited'\n        WHEN population < 1000000 THEN 'Low Population'\n        WHEN population < 100000000 THEN 'Medium Population'\n        WHEN population < 1000000000 THEN 'High Population'\n        ELSE 'Densely Populated'\n    END AS population_class,\n    \n    -- Biome classification with improved NULL handling\n    CASE\n        WHEN climate IS NULL THEN 'Unknown'\n        WHEN LOWER(climate) LIKE '%arid%' OR LOWER(climate) LIKE '%desert%' THEN 'Arid'\n        WHEN LOWER(climate) LIKE '%tropical%' THEN 'Tropical'\n        WHEN LOWER(climate) LIKE '%temperate%' THEN 'Temperate'\n        WHEN LOWER(climate) LIKE '%cold%' OR LOWER(climate) LIKE '%frozen%' OR LOWER(climate) LIKE '%ice%' THEN 'Cold'\n        WHEN LOWER(climate) LIKE '%artificial%' THEN 'Artificial'\n        ELSE 'Mixed'\n    END AS biome_class,\n    \n    -- Water feature classification with NULL handling\n    CASE\n        WHEN surface_water IS NULL THEN 'Unknown'\n        WHEN surface_water = 0 THEN 'Arid'\n        WHEN surface_water < 30 THEN 'Limited Waters'\n        WHEN surface_water < 70 THEN 'Moderate Waters'\n        ELSE 'Water-Rich'\n    END AS water_class,\n    \n    -- Habitability score (0-100) with improved logic\n    CASE\n        WHEN universe = 'star_wars' THEN\n            CASE\n                WHEN climate IS NULL THEN 50  -- Default for unknown\n                WHEN population = 0 OR LOWER(climate) LIKE '%frozen%' THEN 10\n                WHEN LOWER(climate) LIKE '%temperate%' AND COALESCE(surface_water, 0) > 0 THEN \n                    LEAST(100, 50 + (COALESCE(surface_water, 0) / 2))\n                ELSE 50\n            END\n        WHEN universe = 'pokemon' THEN\n            CASE  -- Pok\u00e9mon regions are generally habitable\n                WHEN location_name IN ('Kanto', 'Johto', 'Kalos') THEN 95\n                WHEN location_name = 'Alola' THEN 98  -- Paradise\n                WHEN location_name = 'Sinnoh' THEN 85  -- Colder\n                WHEN location_name = 'Paldea' THEN 92  -- Newer region\n                ELSE 90\n            END\n        WHEN universe = 'netrunner' THEN\n            CASE\n                WHEN location_name IN ('Mars', 'The Moon', 'Heinlein') THEN 40  -- Artificial habitats\n                WHEN location_name = 'New Angeles' THEN 70  -- Controlled but crowded\n                WHEN location_name = 'Jinteki Biotech Labs' THEN 75  -- Controlled environment\n                ELSE 60\n            END\n        ELSE 50\n    END AS habitability_score,\n    \n    -- Notable lore locations flag\n    CASE\n        WHEN universe = 'star_wars' AND \n             location_name IN ('Tatooine', 'Coruscant', 'Hoth', 'Endor', 'Naboo', 'Alderaan', 'Dagobah', 'Mustafar', 'Kashyyyk') THEN TRUE\n        WHEN universe = 'pokemon' AND \n             location_name IN ('Kanto', 'Johto', 'Hoenn', 'Sinnoh', 'Unova', 'Kalos', 'Alola') THEN TRUE\n        WHEN universe = 'netrunner' AND \n             location_name IN ('New Angeles', 'ChiLo', 'Heinlein') THEN TRUE\n        ELSE FALSE\n    END AS is_iconic_location,\n    \n    -- Add urbanization level\n    CASE\n        WHEN terrain IS NULL THEN 'Unknown'\n        WHEN LOWER(terrain) LIKE '%urban%' OR LOWER(terrain) LIKE '%city%' OR LOWER(terrain) LIKE '%metropol%' THEN\n            CASE\n                WHEN population > 500000000 THEN 'Megalopolis'\n                WHEN population > 100000000 THEN 'Major Urban'\n                ELSE 'Urban'\n            END\n        WHEN LOWER(terrain) LIKE '%rural%' OR LOWER(terrain) LIKE '%village%' THEN 'Rural'\n        WHEN LOWER(terrain) LIKE '%uninhabited%' OR population = 0 THEN 'Uninhabited'\n        ELSE 'Mixed/Wilderness'\n    END AS urbanization_level,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM all_locations\nORDER BY universe, location_name", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}, {"name": "stg_pokeapi_pokemon", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets", "model.nerd_facts_dbt.stg_pokeapi_pokemon"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.dim_sw_planets": {"database": "nerd_facts", "schema": "public", "name": "dim_sw_planets", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/dim_sw_planets.sql", "original_file_path": "models/marts/star_wars/dim_sw_planets.sql", "unique_id": "model.nerd_facts_dbt.dim_sw_planets", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "dim_sw_planets"], "alias": "dim_sw_planets", "checksum": {"name": "sha256", "checksum": "a2ba0110c66643098c8a4a7a1631aec82db1369de164965dc7a744a64b2f41e2"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "planet_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["planet_id"]}, {"columns": ["planet_name"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["planet_id"]}, {"columns": ["planet_name"]}], "unique_key": "planet_key"}, "created_at": 1742205059.2285278, "relation_name": "\"nerd_facts\".\"public\".\"dim_sw_planets\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['planet_id']}, {'columns': ['planet_name']}],\n    unique_key = 'planet_key'\n  )\n}}\n\n/*\n  Model: dim_sw_planets\n  Description: Dimension table for Star Wars planets and celestial bodies\n  \n  Notes:\n  - Contains all planets from the Star Wars universe in SWAPI\n  - Provides physical characteristics and environmental classifications\n  - Calculates habitability metrics and significance rankings\n  - Adds contextual information about each planet's role in the saga\n  - Includes galactic region mapping and political affiliations\n*/\n\nWITH planets AS (\n    SELECT\n        id AS planet_id,\n        name AS planet_name,\n        NULLIF(rotation_period, 'unknown')::NUMERIC AS rotation_period,\n        NULLIF(orbital_period, 'unknown')::NUMERIC AS orbital_period,\n        NULLIF(diameter, 'unknown')::NUMERIC AS diameter,\n        climate,\n        gravity,\n        terrain,\n        NULLIF(surface_water, 'unknown')::NUMERIC AS surface_water,\n        NULLIF(REPLACE(population, ',', ''), 'unknown')::NUMERIC AS population\n    FROM {{ ref('stg_swapi_planets') }}\n),\n\n-- Add derived classification attributes with enhanced logic\nplanet_attributes AS (\n    SELECT \n        *,\n        -- Planet size classification with better ranges\n        CASE\n            WHEN diameter IS NULL THEN 'Unknown'\n            WHEN diameter <= 5000 THEN 'Tiny'\n            WHEN diameter <= 10000 THEN 'Small'\n            WHEN diameter <= 15000 THEN 'Medium'\n            WHEN diameter <= 25000 THEN 'Large'\n            ELSE 'Massive'\n        END AS size_class,\n        \n        -- Enhanced climate classification with better pattern matching\n        CASE\n            WHEN climate IS NULL THEN 'Unknown'\n            WHEN climate LIKE '%temperate%' AND climate LIKE '%tropical%' THEN 'Temperate/Tropical Mix'\n            WHEN climate LIKE '%temperate%' THEN 'Temperate'\n            WHEN climate LIKE '%tropical%' THEN 'Tropical'\n            WHEN climate LIKE '%arid%' OR climate LIKE '%hot%' OR climate LIKE '%desert%' THEN 'Hot/Arid'\n            WHEN climate LIKE '%frozen%' OR climate LIKE '%frigid%' OR climate LIKE '%cold%' OR climate LIKE '%ice%' THEN 'Cold/Frozen'\n            WHEN climate LIKE '%polluted%' OR climate LIKE '%toxic%' THEN 'Polluted/Toxic'\n            WHEN climate LIKE '%artificial%' OR climate LIKE '%controlled%' THEN 'Artificial/Controlled'\n            WHEN climate LIKE '%moist%' OR climate LIKE '%humid%' OR climate LIKE '%wet%' THEN 'Humid/Moist'\n            WHEN climate LIKE '%superheated%' OR climate LIKE '%fiery%' OR climate LIKE '%volcanic%' THEN 'Extreme Heat'\n            ELSE 'Mixed/Other'\n        END AS climate_class,\n        \n        -- Terrain type classification (primary terrain type)\n        CASE\n            WHEN terrain IS NULL THEN 'Unknown'\n            WHEN terrain LIKE '%desert%' THEN 'Desert'\n            WHEN terrain LIKE '%forest%' AND terrain LIKE '%jungle%' THEN 'Forest/Jungle'\n            WHEN terrain LIKE '%forest%' THEN 'Forest'\n            WHEN terrain LIKE '%jungle%' THEN 'Jungle'\n            WHEN terrain LIKE '%mountain%' THEN 'Mountainous'\n            WHEN terrain LIKE '%ocean%' OR terrain LIKE '%water%' OR terrain LIKE '%lake%' THEN 'Oceanic'\n            WHEN terrain LIKE '%swamp%' OR terrain LIKE '%bog%' THEN 'Swamp/Bog'\n            WHEN terrain LIKE '%urban%' OR terrain LIKE '%cityscape%' OR terrain LIKE '%city%' THEN 'Urban'\n            WHEN terrain LIKE '%grass%' OR terrain LIKE '%plain%' OR terrain LIKE '%prairie%' THEN 'Grassland'\n            WHEN terrain LIKE '%rock%' OR terrain LIKE '%cliff%' OR terrain LIKE '%canyon%' THEN 'Rocky'\n            WHEN terrain LIKE '%ice%' OR terrain LIKE '%glacier%' OR terrain LIKE '%frozen%' THEN 'Ice/Frozen'\n            WHEN terrain LIKE '%gas%' THEN 'Gas Giant'\n            ELSE 'Mixed/Other'\n        END AS terrain_class,\n        \n        -- Improved habitability score (0-100) with more factors\n        CASE\n            WHEN population IS NULL AND climate IS NULL THEN 50\n            ELSE\n                LEAST(100, GREATEST(0, \n                    -- Base score\n                    40 + \n                    -- Climate factors\n                    CASE \n                        WHEN climate LIKE '%temperate%' THEN 20 \n                        WHEN climate LIKE '%tropical%' THEN 15\n                        WHEN climate LIKE '%polluted%' OR climate LIKE '%toxic%' THEN -30\n                        WHEN climate LIKE '%frigid%' OR climate LIKE '%frozen%' THEN -20\n                        WHEN climate LIKE '%arid%' OR climate LIKE '%desert%' THEN -15\n                        ELSE 0 \n                    END +\n                    -- Water factors (crucial for life)\n                    CASE \n                        WHEN surface_water > 50 THEN 15\n                        WHEN surface_water > 30 THEN 10\n                        WHEN surface_water > 10 THEN 5\n                        WHEN surface_water = 0 THEN -10\n                        WHEN surface_water IS NULL THEN 0\n                        ELSE 0 \n                    END +\n                    -- Population factors (evidence of habitability)\n                    CASE \n                        WHEN population > 1000000000 THEN 25\n                        WHEN population > 100000000 THEN 20\n                        WHEN population > 10000000 THEN 15\n                        WHEN population > 1000000 THEN 10\n                        WHEN population > 0 THEN 5\n                        WHEN population = 0 THEN -10\n                        WHEN population IS NULL THEN 0\n                        ELSE 0 \n                    END +\n                    -- Gravity factors\n                    CASE \n                        WHEN gravity LIKE '%standard%' THEN 10\n                        WHEN gravity LIKE '%high%' OR gravity LIKE '%heavy%' THEN -5\n                        ELSE 0 \n                    END\n                ))\n        END AS habitability_score,\n        \n        -- Planet's galactic region based on known planets\n        CASE\n            WHEN planet_name IN ('Coruscant', 'Alderaan', 'Corellia', 'Chandrila', 'Hosnian Prime') THEN 'Core Worlds'\n            WHEN planet_name IN ('Kashyyyk', 'Duro', 'Abregado-rae', 'Cato Neimoidia', 'Fondor') THEN 'Colonies/Inner Rim'\n            WHEN planet_name IN ('Naboo', 'Bothawui', 'Mon Cala', 'Onderon', 'Malastare') THEN 'Mid Rim'\n            WHEN planet_name IN ('Tatooine', 'Geonosis', 'Ryloth', 'Dantooine', 'Lothal', 'Kessel') THEN 'Outer Rim'\n            WHEN planet_name IN ('Kamino', 'Mustafar', 'Hoth', 'Bespin', 'Dagobah', 'Endor', 'Yavin IV') THEN 'Outer Rim/Unknown Regions'\n            WHEN planet_name IN ('Exegol', 'Ilum', 'Csilla', 'Rakata Prime') THEN 'Unknown Regions'\n            ELSE 'Unspecified Region'\n        END AS galactic_region\n    FROM planets\n),\n\n-- Additional planet significance data\nplanet_significance AS (\n    SELECT \n        *,\n        -- Major battles/events on planet\n        CASE\n            WHEN planet_name = 'Naboo' THEN 'Trade Federation Invasion, Battle of Naboo'\n            WHEN planet_name = 'Geonosis' THEN 'First Battle of Geonosis, Start of Clone Wars'\n            WHEN planet_name = 'Coruscant' THEN 'Senate location, Battle of Coruscant, Order 66'\n            WHEN planet_name = 'Mustafar' THEN 'Anakin vs Obi-Wan duel, Sith stronghold'\n            WHEN planet_name = 'Utapau' THEN 'Battle of Utapau, General Grievous death'\n            WHEN planet_name = 'Kashyyyk' THEN 'Battle of Kashyyyk, Order 66'\n            WHEN planet_name = 'Tatooine' THEN 'Skywalker homeworld, Jabba Palace, Podracing'\n            WHEN planet_name = 'Alderaan' THEN 'Death Star destruction'\n            WHEN planet_name = 'Yavin IV' THEN 'Battle of Yavin, Death Star destruction'\n            WHEN planet_name = 'Hoth' THEN 'Battle of Hoth, Echo Base'\n            WHEN planet_name = 'Dagobah' THEN 'Yoda exile, Luke training'\n            WHEN planet_name = 'Bespin' THEN 'Cloud City, \"I am your father\" revelation'\n            WHEN planet_name = 'Endor' THEN 'Battle of Endor, Death Star II destruction'\n            WHEN planet_name = 'Jakku' THEN 'Battle of Jakku, Empire defeat, Rey homeworld'\n            WHEN planet_name = 'Starkiller Base' THEN 'Hosnian system destruction, Han Solo death'\n            WHEN planet_name = 'Ahch-To' THEN 'First Jedi temple, Luke exile'\n            WHEN planet_name = 'Crait' THEN 'Battle of Crait, Luke projection'\n            WHEN planet_name = 'Exegol' THEN 'Sith throne, Final Order fleet, Palpatine defeat'\n            ELSE NULL\n        END AS major_events,\n        \n        -- Expanded political affiliation\n        CASE\n            -- Republic/Empire affiliated\n            WHEN planet_name IN ('Coruscant', 'Hosnian Prime', 'Chandrila', 'Corellia', 'Kamino') THEN 'Republic/Empire'\n            -- Separatist affiliated\n            WHEN planet_name IN ('Geonosis', 'Cato Neimoidia', 'Serenno', 'Skako', 'Raxus') THEN 'Separatist Alliance'\n            -- Rebel/Resistance affiliated\n            WHEN planet_name IN ('Yavin IV', 'Hoth', 'Dantooine', 'D''Qar', 'Ajan Kloss', 'Crait') THEN 'Rebel Alliance/Resistance'\n            -- Neutral/Independent\n            WHEN planet_name IN ('Tatooine', 'Mandalore', 'Naboo', 'Dagobah', 'Ahch-To', 'Bespin') THEN 'Neutral/Independent'\n            -- Hutt/Criminal affiliated\n            WHEN planet_name IN ('Nal Hutta', 'Nar Shaddaa', 'Kessel', 'Cantonica') THEN 'Hutt Space/Criminal Networks'\n            -- First Order/Sith affiliated\n            WHEN planet_name IN ('Exegol', 'Starkiller Base', 'Mustafar', 'Moraband', 'Malachor') THEN 'Sith/First Order'\n            ELSE 'Unspecified Affiliation'\n        END AS political_affiliation,\n        \n        -- Galactic significance rating (1-10 scale)\n        CASE\n            WHEN planet_name IN ('Coruscant', 'Exegol', 'Mustafar', 'Naboo', 'Tatooine', \n                             'Alderaan', 'Yavin IV', 'Hoth', 'Endor') THEN 10\n            WHEN planet_name IN ('Geonosis', 'Kamino', 'Bespin', 'Dagobah', 'Utapau', \n                             'Jakku', 'Ahch-To', 'Starkiller Base', 'Crait') THEN 8\n            WHEN planet_name IN ('Kashyyyk', 'Mon Cala', 'Mandalore', 'Ryloth', 'Dathomir',\n                             'Corellia', 'Felucia', 'Scarif', 'Jedha') THEN 6\n            WHEN planet_name IN ('Dantooine', 'Onderon', 'Bothawui', 'Lothal', 'Cantonica',\n                             'Batuu', 'Mimban', 'Nevarro', 'Malachor') THEN 4\n            ELSE 2\n        END AS galactic_significance\n    FROM planet_attributes\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['ps.planet_id']) }} AS planet_key,\n    \n    -- Core identifiers\n    ps.planet_id,\n    ps.planet_name,\n    \n    -- Physical attributes with better error handling\n    CASE WHEN ps.diameter IS NOT NULL THEN ps.diameter ELSE NULL END AS diameter_km,\n    CASE WHEN ps.rotation_period IS NOT NULL THEN ps.rotation_period ELSE NULL END AS rotation_period_hours,\n    CASE WHEN ps.orbital_period IS NOT NULL THEN ps.orbital_period ELSE NULL END AS orbital_period_days,\n    \n    -- Environmental attributes\n    ps.climate,\n    ps.climate_class,\n    ps.gravity,\n    ps.terrain,\n    ps.terrain_class,\n    CASE WHEN ps.surface_water IS NOT NULL THEN ps.surface_water ELSE NULL END AS surface_water_percentage,\n    \n    -- Size and habitability\n    ps.size_class,\n    ps.habitability_score,\n    \n    -- Population data with better formatting and error handling\n    CASE\n        WHEN ps.population >= 1000000000 THEN TRIM(TO_CHAR(ps.population/1000000000.0, '999,999,990.9')) || ' billion'\n        WHEN ps.population >= 1000000 THEN TRIM(TO_CHAR(ps.population/1000000.0, '999,999,990.9')) || ' million'\n        WHEN ps.population >= 1000 THEN TRIM(TO_CHAR(ps.population/1000.0, '999,999,990.9')) || ' thousand'\n        WHEN ps.population IS NOT NULL THEN TRIM(TO_CHAR(ps.population, '999,999,999,999'))\n        ELSE 'unknown'\n    END AS population_formatted,\n    ps.population AS population_count,\n    \n    -- Population density if both values are available\n    CASE \n        WHEN ps.population IS NOT NULL AND ps.diameter IS NOT NULL AND ps.diameter > 0 THEN\n            ROUND(ps.population / (3.14159 * POWER(ps.diameter/2, 2)), 2)\n        ELSE NULL\n    END AS population_density_per_km2,\n    \n    -- Habitability classification\n    CASE\n        WHEN ps.habitability_score >= 80 THEN 'Ideal'\n        WHEN ps.habitability_score >= 60 THEN 'Highly Habitable'\n        WHEN ps.habitability_score >= 40 THEN 'Moderately Habitable'\n        WHEN ps.habitability_score >= 20 THEN 'Marginally Habitable'\n        ELSE 'Barely Habitable/Hostile'\n    END AS habitability_class,\n    \n    -- Galactic location and significance\n    ps.galactic_region,\n    ps.political_affiliation,\n    ps.major_events,\n    ps.galactic_significance,\n    \n    -- Enhanced key location flag with tiered importance\n    CASE\n        WHEN ps.planet_name IN ('Tatooine', 'Coruscant', 'Naboo', 'Mustafar', 'Alderaan', \n                             'Hoth', 'Endor', 'Dagobah', 'Yavin IV', 'Exegol') \n            THEN 'Primary Saga Location'\n        WHEN ps.planet_name IN ('Geonosis', 'Kamino', 'Utapau', 'Kashyyyk', 'Bespin', 'Jakku',\n                             'Ahch-To', 'Crait', 'Starkiller Base', 'Scarif', 'Jedha') \n            THEN 'Major Location'\n        WHEN ps.planet_name IN ('Dantooine', 'Mon Cala', 'Ryloth', 'Mandalore', 'Corellia', 'Cantonica')\n            THEN 'Notable Location'\n        WHEN ps.galactic_significance >= 6\n            THEN 'Significant Location'\n        ELSE 'Standard Location'\n    END AS location_importance,\n    \n    -- Films appearance mapping (manually added)\n    CASE\n        WHEN ps.planet_name = 'Tatooine' THEN ARRAY[1, 2, 3, 4, 6]\n        WHEN ps.planet_name = 'Naboo' THEN ARRAY[1, 2, 3]\n        WHEN ps.planet_name = 'Coruscant' THEN ARRAY[1, 2, 3, 6]\n        WHEN ps.planet_name = 'Geonosis' THEN ARRAY[2]\n        WHEN ps.planet_name = 'Kamino' THEN ARRAY[2]\n        WHEN ps.planet_name = 'Mustafar' THEN ARRAY[3]\n        WHEN ps.planet_name = 'Utapau' THEN ARRAY[3]\n        WHEN ps.planet_name = 'Kashyyyk' THEN ARRAY[3]\n        WHEN ps.planet_name = 'Alderaan' THEN ARRAY[4]\n        WHEN ps.planet_name = 'Yavin IV' THEN ARRAY[4]\n        WHEN ps.planet_name = 'Hoth' THEN ARRAY[5]\n        WHEN ps.planet_name = 'Dagobah' THEN ARRAY[5, 6]\n        WHEN ps.planet_name = 'Bespin' THEN ARRAY[5]\n        WHEN ps.planet_name = 'Endor' THEN ARRAY[6]\n        WHEN ps.planet_name = 'Jakku' THEN ARRAY[7]\n        WHEN ps.planet_name = 'Takodana' THEN ARRAY[7]\n        WHEN ps.planet_name = 'D''Qar' THEN ARRAY[7, 8]\n        WHEN ps.planet_name = 'Ahch-To' THEN ARRAY[7, 8]\n        WHEN ps.planet_name = 'Cantonica' THEN ARRAY[8]\n        WHEN ps.planet_name = 'Crait' THEN ARRAY[8]\n        WHEN ps.planet_name = 'Pasaana' THEN ARRAY[9]\n        WHEN ps.planet_name = 'Kijimi' THEN ARRAY[9]\n        WHEN ps.planet_name = 'Exegol' THEN ARRAY[9]\n        ELSE NULL\n    END AS film_appearances,\n    \n    -- Count of film appearances\n    CASE\n        WHEN ps.planet_name IN ('Tatooine', 'Naboo', 'Coruscant', 'Geonosis', 'Kamino', 'Mustafar',\n                             'Utapau', 'Kashyyyk', 'Alderaan', 'Yavin IV', 'Hoth', 'Dagobah', \n                             'Bespin', 'Endor', 'Jakku', 'Takodana', 'D''Qar', 'Ahch-To', \n                             'Cantonica', 'Crait', 'Pasaana', 'Kijimi', 'Exegol') \n            THEN ARRAY_LENGTH(\n                CASE\n                    WHEN ps.planet_name = 'Tatooine' THEN ARRAY[1, 2, 3, 4, 6]\n                    WHEN ps.planet_name = 'Naboo' THEN ARRAY[1, 2, 3]\n                    WHEN ps.planet_name = 'Coruscant' THEN ARRAY[1, 2, 3, 6]\n                    WHEN ps.planet_name = 'Geonosis' THEN ARRAY[2]\n                    WHEN ps.planet_name = 'Kamino' THEN ARRAY[2]\n                    WHEN ps.planet_name = 'Mustafar' THEN ARRAY[3]\n                    WHEN ps.planet_name = 'Utapau' THEN ARRAY[3]\n                    WHEN ps.planet_name = 'Kashyyyk' THEN ARRAY[3]\n                    WHEN ps.planet_name = 'Alderaan' THEN ARRAY[4]\n                    WHEN ps.planet_name = 'Yavin IV' THEN ARRAY[4]\n                    WHEN ps.planet_name = 'Hoth' THEN ARRAY[5]\n                    WHEN ps.planet_name = 'Dagobah' THEN ARRAY[5, 6]\n                    WHEN ps.planet_name = 'Bespin' THEN ARRAY[5]\n                    WHEN ps.planet_name = 'Endor' THEN ARRAY[6]\n                    WHEN ps.planet_name = 'Jakku' THEN ARRAY[7]\n                    WHEN ps.planet_name = 'Takodana' THEN ARRAY[7]\n                    WHEN ps.planet_name = 'D''Qar' THEN ARRAY[7, 8]\n                    WHEN ps.planet_name = 'Ahch-To' THEN ARRAY[7, 8]\n                    WHEN ps.planet_name = 'Cantonica' THEN ARRAY[8]\n                    WHEN ps.planet_name = 'Crait' THEN ARRAY[8]\n                    WHEN ps.planet_name = 'Pasaana' THEN ARRAY[9]\n                    WHEN ps.planet_name = 'Kijimi' THEN ARRAY[9]\n                    WHEN ps.planet_name = 'Exegol' THEN ARRAY[9]\n                    ELSE NULL\n                END, 1\n            )\n        ELSE 0\n    END AS film_appearance_count,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM planet_significance ps\nORDER BY ps.galactic_significance DESC, ps.habitability_score DESC", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_swapi_species": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_species", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_species.sql", "original_file_path": "models/staging/swapi/stg_swapi_species.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_species", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_species"], "alias": "stg_swapi_species", "checksum": {"name": "sha256", "checksum": "657dab831ad77ebc02657b0a3dedb760481da123ff8e8d73dde7065ca06505a6"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars species data with intelligence levels and classifications", "columns": {"id": {"name": "id", "description": "Primary key for species", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Species name", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "classification": {"name": "classification", "description": "Biological classification", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "designation": {"name": "designation", "description": "Designation (sentient, non-sentient, etc.)", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "average_height": {"name": "average_height", "description": "Average height in centimeters", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "skin_colors": {"name": "skin_colors", "description": "Possible skin colors for this species", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "hair_colors": {"name": "hair_colors", "description": "Possible hair colors for this species", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "eye_colors": {"name": "eye_colors", "description": "Possible eye colors for this species", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "average_lifespan": {"name": "average_lifespan", "description": "Average lifespan in years", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "homeworld": {"name": "homeworld", "description": "ID of species homeworld", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "language": {"name": "language", "description": "Primary language spoken", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_species.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742205059.3517632, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_species\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_species\n  Description: Standardizes Star Wars species data from SWAPI\n  Source: raw.swapi_species\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Color fields are parsed for analysis\n  - Homeworld references are extracted\n  - Additional derived fields help with species classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        classification,\n        designation,\n        average_height,\n        average_lifespan,\n        eye_colors,\n        hair_colors,\n        skin_colors,\n        homeworld,\n        language,\n        CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb ELSE people::jsonb END AS people,\n        CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM {{ source('swapi', 'species') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS species_name,\n    \n    -- Species classification\n    LOWER(COALESCE(classification, 'unknown')) AS classification,\n    LOWER(COALESCE(designation, 'unknown')) AS designation,\n    \n    -- Physical characteristics with proper typing\n    CASE \n        WHEN average_height IS NULL OR LOWER(average_height) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(average_height, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS average_height_cm,\n    \n    CASE \n        WHEN average_lifespan IS NULL OR LOWER(average_lifespan) = 'unknown' \n            OR LOWER(average_lifespan) = 'indefinite' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(average_lifespan, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS average_lifespan_years,\n    \n    -- Special case for indefinite lifespan\n    CASE \n        WHEN LOWER(average_lifespan) = 'indefinite' THEN TRUE\n        ELSE FALSE\n    END AS has_indefinite_lifespan,\n    \n    -- Language\n    LOWER(COALESCE(language, 'unknown')) AS language,\n    \n    -- Color attributes - standardized to arrays\n    CASE \n        WHEN eye_colors IS NULL OR eye_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(eye_colors), ', ') \n    END AS eye_colors_array,\n    \n    CASE \n        WHEN hair_colors IS NULL OR hair_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(hair_colors), ', ') \n    END AS hair_colors_array,\n    \n    CASE \n        WHEN skin_colors IS NULL OR skin_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(skin_colors), ', ') \n    END AS skin_colors_array,\n    \n    -- Extract homeworld with error handling\n    CASE\n        WHEN homeworld IS NULL THEN NULL\n        WHEN homeworld = 'null' THEN NULL\n        ELSE NULLIF(SPLIT_PART(homeworld->>'url', '/', 6), '')\n    END AS homeworld_id,\n    \n    -- Entity counts\n    COALESCE(jsonb_array_length(people), 0) AS character_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    people,\n    films,\n    \n    -- Derived species classifications\n    CASE\n        WHEN LOWER(classification) IN ('mammal', 'amphibian', 'reptile', 'bird') THEN TRUE\n        ELSE FALSE\n    END AS is_organic,\n    \n    CASE\n        WHEN LOWER(classification) = 'artificial' OR LOWER(name) = 'droid' THEN TRUE\n        ELSE FALSE\n    END AS is_artificial,\n    \n    -- Intelligence estimation (approximate)\n    CASE\n        WHEN LOWER(designation) = 'sentient' THEN 'High'\n        WHEN LOWER(designation) = 'semi-sentient' THEN 'Moderate'\n        ELSE 'Unknown'\n    END AS intelligence_level,\n    \n    -- Longevity classification\n    CASE\n        WHEN LOWER(average_lifespan) = 'indefinite' THEN 'Immortal'\n        WHEN average_lifespan::NUMERIC > 500 THEN 'Very Long-Lived'\n        WHEN average_lifespan::NUMERIC > 100 THEN 'Long-Lived'\n        WHEN average_lifespan::NUMERIC > 70 THEN 'Standard'\n        WHEN average_lifespan::NUMERIC > 0 THEN 'Short-Lived'\n        ELSE 'Unknown'\n    END AS longevity_class,\n    \n    -- Notable species flag\n    CASE\n        WHEN name IN ('Human', 'Wookiee', 'Droid', 'Hutt', 'Ewok', 'Gungan', \n                     'Jawa', 'Mon Calamari', 'Twi\\'lek', 'Yoda\\'s species') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_species,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [["swapi", "species"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.swapi.species"]}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_species.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_species\n  Description: Standardizes Star Wars species data from SWAPI\n  Source: raw.swapi_species\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Color fields are parsed for analysis\n  - Homeworld references are extracted\n  - Additional derived fields help with species classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        classification,\n        designation,\n        average_height,\n        average_lifespan,\n        eye_colors,\n        hair_colors,\n        skin_colors,\n        homeworld,\n        language,\n        CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb ELSE people::jsonb END AS people,\n        CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM \"nerd_facts\".\"raw\".\"swapi_species\"\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS species_name,\n    \n    -- Species classification\n    LOWER(COALESCE(classification, 'unknown')) AS classification,\n    LOWER(COALESCE(designation, 'unknown')) AS designation,\n    \n    -- Physical characteristics with proper typing\n    CASE \n        WHEN average_height IS NULL OR LOWER(average_height) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(average_height, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS average_height_cm,\n    \n    CASE \n        WHEN average_lifespan IS NULL OR LOWER(average_lifespan) = 'unknown' \n            OR LOWER(average_lifespan) = 'indefinite' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(average_lifespan, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS average_lifespan_years,\n    \n    -- Special case for indefinite lifespan\n    CASE \n        WHEN LOWER(average_lifespan) = 'indefinite' THEN TRUE\n        ELSE FALSE\n    END AS has_indefinite_lifespan,\n    \n    -- Language\n    LOWER(COALESCE(language, 'unknown')) AS language,\n    \n    -- Color attributes - standardized to arrays\n    CASE \n        WHEN eye_colors IS NULL OR eye_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(eye_colors), ', ') \n    END AS eye_colors_array,\n    \n    CASE \n        WHEN hair_colors IS NULL OR hair_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(hair_colors), ', ') \n    END AS hair_colors_array,\n    \n    CASE \n        WHEN skin_colors IS NULL OR skin_colors = '' THEN NULL\n        ELSE STRING_TO_ARRAY(LOWER(skin_colors), ', ') \n    END AS skin_colors_array,\n    \n    -- Extract homeworld with error handling\n    CASE\n        WHEN homeworld IS NULL THEN NULL\n        WHEN homeworld = 'null' THEN NULL\n        ELSE NULLIF(SPLIT_PART(homeworld->>'url', '/', 6), '')\n    END AS homeworld_id,\n    \n    -- Entity counts\n    COALESCE(jsonb_array_length(people), 0) AS character_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    people,\n    films,\n    \n    -- Derived species classifications\n    CASE\n        WHEN LOWER(classification) IN ('mammal', 'amphibian', 'reptile', 'bird') THEN TRUE\n        ELSE FALSE\n    END AS is_organic,\n    \n    CASE\n        WHEN LOWER(classification) = 'artificial' OR LOWER(name) = 'droid' THEN TRUE\n        ELSE FALSE\n    END AS is_artificial,\n    \n    -- Intelligence estimation (approximate)\n    CASE\n        WHEN LOWER(designation) = 'sentient' THEN 'High'\n        WHEN LOWER(designation) = 'semi-sentient' THEN 'Moderate'\n        ELSE 'Unknown'\n    END AS intelligence_level,\n    \n    -- Longevity classification\n    CASE\n        WHEN LOWER(average_lifespan) = 'indefinite' THEN 'Immortal'\n        WHEN average_lifespan::NUMERIC > 500 THEN 'Very Long-Lived'\n        WHEN average_lifespan::NUMERIC > 100 THEN 'Long-Lived'\n        WHEN average_lifespan::NUMERIC > 70 THEN 'Standard'\n        WHEN average_lifespan::NUMERIC > 0 THEN 'Short-Lived'\n        ELSE 'Unknown'\n    END AS longevity_class,\n    \n    -- Notable species flag\n    CASE\n        WHEN name IN ('Human', 'Wookiee', 'Droid', 'Hutt', 'Ewok', 'Gungan', \n                     'Jawa', 'Mon Calamari', 'Twi\\'lek', 'Yoda\\'s species') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_species,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "model.nerd_facts_dbt.dim_sw_vehicles": {"database": "nerd_facts", "schema": "public", "name": "dim_sw_vehicles", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "marts/star_wars/dim_sw_vehicles.sql", "original_file_path": "models/marts/star_wars/dim_sw_vehicles.sql", "unique_id": "model.nerd_facts_dbt.dim_sw_vehicles", "fqn": ["nerd_facts_dbt", "marts", "star_wars", "dim_sw_vehicles"], "alias": "dim_sw_vehicles", "checksum": {"name": "sha256", "checksum": "66cfa651e45689e306b4162442f5974ba2be0bb6e9d808afc5bb6f0e76ac8ce6"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "table", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": "vehicle_key", "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected", "indexes": [{"columns": ["vehicle_id"]}, {"columns": ["vehicle_name"]}, {"columns": ["vehicle_class"]}]}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"materialized": "table", "indexes": [{"columns": ["vehicle_id"]}, {"columns": ["vehicle_name"]}, {"columns": ["vehicle_class"]}], "unique_key": "vehicle_key"}, "created_at": 1742205059.2394984, "relation_name": "\"nerd_facts\".\"public\".\"dim_sw_vehicles\"", "raw_code": "{{\n  config(\n    materialized = 'table',\n    indexes = [{'columns': ['vehicle_id']}, {'columns': ['vehicle_name']}, {'columns': ['vehicle_class']}],\n    unique_key = 'vehicle_key'\n  )\n}}\n\n/*\n  Model: dim_sw_vehicles\n  Description: Dimension table for Star Wars vehicles\n  \n  Notes:\n  - Contains comprehensive vehicle data from the Star Wars universe\n  - Provides specifications, classifications, and performance metrics\n  - Categorizes vehicles by era, affiliation, and purpose\n  - Adds derived attributes about role and significance\n  - Includes vehicle-specific context and lore details\n*/\n\nWITH vehicles AS (\n    SELECT\n        id AS vehicle_id,\n        name AS vehicle_name,\n        model,\n        manufacturer,\n        NULLIF(cost_in_credits, 'unknown')::NUMERIC AS cost_in_credits,\n        NULLIF(length, 'unknown')::NUMERIC AS length,\n        NULLIF(max_atmosphering_speed, 'unknown')::NUMERIC AS max_atmosphering_speed,\n        NULLIF(crew, 'unknown')::NUMERIC AS crew,\n        NULLIF(passengers, 'unknown')::NUMERIC AS passengers,\n        NULLIF(cargo_capacity, 'unknown')::NUMERIC AS cargo_capacity,\n        consumables,\n        vehicle_class\n    FROM {{ ref('stg_swapi_vehicles') }}\n),\n\n-- Add derived attributes\nvehicle_attributes AS (\n    SELECT\n        *,\n        -- Enhanced vehicle size classification with more granularity\n        CASE\n            WHEN length IS NULL THEN 'Unknown'\n            WHEN length < 5 THEN 'Tiny'\n            WHEN length < 10 THEN 'Small'\n            WHEN length < 25 THEN 'Medium'\n            WHEN length < 50 THEN 'Large'\n            WHEN length < 100 THEN 'Very Large'\n            WHEN length < 200 THEN 'Huge'\n            ELSE 'Massive'\n        END AS size_class,\n        \n        -- Enhanced speed classification with better ranges\n        CASE\n            WHEN max_atmosphering_speed IS NULL THEN 'Unknown'\n            WHEN max_atmosphering_speed < 50 THEN 'Very Slow'\n            WHEN max_atmosphering_speed < 100 THEN 'Slow'\n            WHEN max_atmosphering_speed < 300 THEN 'Moderate'\n            WHEN max_atmosphering_speed < 500 THEN 'Fast'\n            WHEN max_atmosphering_speed < 800 THEN 'Very Fast'\n            WHEN max_atmosphering_speed < 1200 THEN 'Extremely Fast'\n            ELSE 'Ultra Fast'\n        END AS speed_class,\n        \n        -- Enhanced passenger capacity classification\n        CASE\n            WHEN passengers IS NULL THEN 'Unknown'\n            WHEN passengers = 0 THEN 'No Passengers'\n            WHEN passengers < 3 THEN 'Very Few'\n            WHEN passengers < 10 THEN 'Few'\n            WHEN passengers < 20 THEN 'Medium'\n            WHEN passengers < 50 THEN 'Many'\n            WHEN passengers < 100 THEN 'Large'\n            WHEN passengers < 500 THEN 'Very Large'\n            ELSE 'Massive'\n        END AS passenger_capacity\n    FROM vehicles\n),\n\n-- Add vehicle era, faction, and purpose information\nvehicle_context AS (\n    SELECT\n        va.*,\n        -- Vehicle purpose/role based on vehicle class and name\n        CASE\n            WHEN LOWER(vehicle_class) LIKE '%transport%' OR \n                 LOWER(vehicle_class) LIKE '%cargo%' THEN 'Transport'\n            WHEN LOWER(vehicle_class) LIKE '%speeder%' AND \n                 (LOWER(vehicle_name) LIKE '%police%' OR\n                  LOWER(vehicle_name) LIKE '%patrol%') THEN 'Law Enforcement'\n            WHEN LOWER(vehicle_class) LIKE '%walker%' OR \n                 LOWER(vehicle_class) LIKE '%assault%' OR\n                 LOWER(vehicle_class) LIKE '%combat%' OR\n                 LOWER(vehicle_name) LIKE '%at-%' OR\n                 LOWER(vehicle_name) LIKE '%fighter%' THEN 'Military'\n            WHEN LOWER(vehicle_class) LIKE '%speeder%' OR \n                 LOWER(vehicle_class) LIKE '%bike%' OR\n                 LOWER(vehicle_class) LIKE '%airspeeder%' THEN 'Civilian Transport'\n            WHEN LOWER(vehicle_class) LIKE '%sail%' OR \n                 LOWER(vehicle_name) LIKE '%barge%' THEN 'Leisure/Luxury'\n            WHEN LOWER(vehicle_class) LIKE '%submarine%' OR \n                 LOWER(vehicle_class) LIKE '%aquatic%' THEN 'Aquatic'\n            WHEN LOWER(vehicle_class) LIKE '%mining%' OR \n                 LOWER(vehicle_class) LIKE '%crawler%' THEN 'Industrial'\n            WHEN LOWER(vehicle_class) LIKE '%repulsor%' AND \n                 LOWER(vehicle_name) NOT LIKE '%military%' THEN 'Civilian Transport'\n            ELSE 'Multipurpose'\n        END AS vehicle_purpose,\n        \n        -- Vehicle faction affiliation based on known vehicles\n        CASE\n            WHEN LOWER(vehicle_name) LIKE '%imperial%' OR\n                 LOWER(vehicle_name) IN ('at-at', 'at-st', 'at-dp', 'tie', 'tie bomber',\n                                       'tie fighter', 'tie interceptor', 'tie/ln starfighter',\n                                       'storm iv twin-pod cloud car', 'sentinel-class landing craft') OR\n                 LOWER(model) LIKE '%imperial%' THEN 'Imperial'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%republic%' OR\n                 LOWER(vehicle_name) IN ('laat/i', 'at-te', 'spha', 'juggernaut', \n                                       'flitknot speeder', 'hailfire droid', \n                                       'corporate alliance tank droid') OR\n                 LOWER(model) LIKE '%republic%' THEN 'Republic'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%rebel%' OR\n                 LOWER(vehicle_name) IN ('snowspeeder', 't-47 airspeeder', \n                                       'rebel alliance snowspeeder', 'tantive iv') OR\n                 LOWER(model) LIKE '%rebel%' THEN 'Rebel Alliance'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%separatist%' OR\n                 LOWER(manufacturer) LIKE '%techno union%' OR\n                 LOWER(vehicle_name) LIKE '%droid%' THEN 'Separatist'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%first order%' OR\n                 LOWER(model) LIKE '%first order%' THEN 'First Order'\n            \n            WHEN LOWER(vehicle_name) LIKE '%resistance%' OR\n                 LOWER(model) LIKE '%resistance%' THEN 'Resistance'\n            \n            WHEN LOWER(manufacturer) LIKE '%hutt%' OR\n                 LOWER(vehicle_name) LIKE '%barge%' AND \n                 LOWER(vehicle_name) LIKE '%sail%' THEN 'Hutt Cartel/Criminal'\n                 \n            ELSE 'Civilian/Neutral'\n        END AS faction_affiliation,\n        \n        -- Vehicle era based on known vehicles and factions\n        CASE\n            WHEN LOWER(vehicle_name) LIKE '%republic%' OR\n                 LOWER(manufacturer) LIKE '%kuat drive yards%' AND\n                 LOWER(vehicle_name) IN ('laat/i', 'at-te', 'spha', 'juggernaut') OR\n                 LOWER(vehicle_name) LIKE '%droid%' THEN 'Prequel Era (Clone Wars)'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%imperial%' OR\n                 LOWER(vehicle_name) IN ('at-at', 'at-st', 'tie bomber', 'tie fighter',\n                                       'snowspeeder', 'cloud car', 'sail barge') OR\n                 LOWER(vehicle_name) LIKE '%rebel%' THEN 'Original Trilogy Era (Galactic Civil War)'\n                 \n            WHEN LOWER(vehicle_name) LIKE '%first order%' OR\n                 LOWER(vehicle_name) LIKE '%resistance%' THEN 'Sequel Era (First Order Conflict)'\n                 \n            ELSE 'Multiple Eras/Unspecified'\n        END AS vehicle_era\n    FROM vehicle_attributes va\n)\n\nSELECT\n    -- Primary key\n    {{ dbt_utils.generate_surrogate_key(['vc.vehicle_id']) }} AS vehicle_key,\n    \n    -- Core identifiers\n    vc.vehicle_id,\n    vc.vehicle_name,\n    \n    -- Manufacturer details\n    vc.model,\n    vc.manufacturer,\n    \n    -- Technical specifications with better type handling\n    CASE WHEN vc.cost_in_credits IS NOT NULL \n         THEN vc.cost_in_credits \n         ELSE NULL\n    END AS cost_in_credits,\n    \n    -- Format costs in a readable way\n    CASE\n        WHEN vc.cost_in_credits >= 1000000 THEN TRIM(TO_CHAR(vc.cost_in_credits/1000000.0, '999,999,990.9')) || ' million'\n        WHEN vc.cost_in_credits >= 1000 THEN TRIM(TO_CHAR(vc.cost_in_credits/1000.0, '999,999,990.9')) || ' thousand'\n        WHEN vc.cost_in_credits IS NOT NULL THEN TRIM(TO_CHAR(vc.cost_in_credits, '999,999,999,999'))\n        ELSE 'unknown'\n    END AS cost_formatted,\n    \n    -- Physical attributes\n    CASE WHEN vc.length IS NOT NULL \n         THEN vc.length \n         ELSE NULL\n    END AS length_m,\n    \n    CASE WHEN vc.max_atmosphering_speed IS NOT NULL \n         THEN vc.max_atmosphering_speed \n         ELSE NULL\n    END AS max_atmosphering_speed,\n    \n    -- Capacity information with improved handling\n    COALESCE(vc.crew, 0) AS crew_count,\n    COALESCE(vc.passengers, 0) AS passenger_count,\n    COALESCE(vc.crew, 0) + COALESCE(vc.passengers, 0) AS total_capacity,\n    \n    CASE WHEN vc.cargo_capacity IS NOT NULL \n         THEN vc.cargo_capacity \n         ELSE NULL\n    END AS cargo_capacity,\n    \n    -- Format cargo in a readable way\n    CASE\n        WHEN vc.cargo_capacity >= 1000000 THEN TRIM(TO_CHAR(vc.cargo_capacity/1000000.0, '999,999,990.9')) || ' tons'\n        WHEN vc.cargo_capacity >= 1000 THEN TRIM(TO_CHAR(vc.cargo_capacity/1000.0, '999,999,990.9')) || ' kg'\n        WHEN vc.cargo_capacity IS NOT NULL THEN TRIM(TO_CHAR(vc.cargo_capacity, '999,999,999,999')) || ' kg'\n        ELSE 'unknown'\n    END AS cargo_capacity_formatted,\n    \n    -- Operational information\n    vc.consumables,\n    \n    -- Classification fields with better organization\n    vc.vehicle_class,\n    vc.size_class,\n    vc.speed_class,\n    vc.passenger_capacity,\n    \n    -- Star Wars specific context\n    vc.vehicle_purpose,\n    vc.faction_affiliation,\n    vc.vehicle_era,\n    \n    -- Effectiveness rating (1-10) based on size, speed, and military utility\n    CASE\n        WHEN vc.vehicle_purpose = 'Military' THEN\n            GREATEST(1, LEAST(10, FLOOR(\n                COALESCE((\n                    -- Base military vehicle score\n                    5 +\n                    -- Size bonus for military vehicles (bigger is better for intimidation)\n                    CASE\n                        WHEN vc.size_class = 'Massive' THEN 3\n                        WHEN vc.size_class = 'Huge' THEN 2\n                        WHEN vc.size_class = 'Very Large' THEN 1\n                        WHEN vc.size_class = 'Tiny' THEN -1\n                        ELSE 0\n                    END +\n                    -- Speed bonus (faster is better for military)\n                    CASE\n                        WHEN vc.speed_class = 'Ultra Fast' THEN 3\n                        WHEN vc.speed_class = 'Extremely Fast' THEN 2\n                        WHEN vc.speed_class = 'Very Fast' THEN 1\n                        WHEN vc.speed_class = 'Very Slow' THEN -1\n                        ELSE 0\n                    END +\n                    -- Known effective military vehicles bonus\n                    CASE\n                        WHEN LOWER(vc.vehicle_name) IN ('at-at', 'at-te', 'juggernaut') THEN 2\n                        ELSE 0\n                    END\n                ), 5)))\n        ELSE\n            -- Non-military vehicles rated on different criteria\n            GREATEST(1, LEAST(10, FLOOR(\n                COALESCE((\n                    -- Base civilian vehicle score\n                    5 +\n                    -- Speed bonus (faster is better for civilian)\n                    CASE\n                        WHEN vc.speed_class = 'Ultra Fast' THEN 3\n                        WHEN vc.speed_class = 'Extremely Fast' THEN 2\n                        WHEN vc.speed_class = 'Very Fast' THEN 1\n                        ELSE 0\n                    END +\n                    -- Passenger capacity bonus\n                    CASE\n                        WHEN vc.passenger_capacity = 'Massive' THEN 2\n                        WHEN vc.passenger_capacity = 'Very Large' THEN 1\n                        ELSE 0\n                    END +\n                    -- Luxury/special vehicle bonus\n                    CASE\n                        WHEN vc.vehicle_purpose = 'Leisure/Luxury' THEN 2\n                        ELSE 0\n                    END\n                ), 5)))\n    END AS effectiveness_rating,\n    \n    -- Expanded iconic vehicle detection with many more iconic vehicles\n    CASE\n        WHEN LOWER(vc.vehicle_name) IN (\n            'at-at', 'at-st', 'snowspeeder', 'speeder bike',\n            'imperial speeder bike', 'tie bomber', 'tie fighter', 'tie interceptor',\n            'sandcrawler', 'sail barge', 'storm iv twin-pod cloud car',\n            'at-te', 'laat/i', 'juggernaut', 'spha', 'hailfire droid',\n            'vulture droid', 'corporate alliance tank droid',\n            'tribubble bongo', 'sith speeder', 'zephyr-g swoop',\n            'koro-2 exodrive airspeeder', 'xj-6 airspeeder',\n            'flitknot speeder', 'v-wing airspeeder',\n            'firespray-31', 'slave i', 'tantive iv', 'republic attack cruiser',\n            'a-wing', 'b-wing', 'x-wing', 'y-wing', 'naboo n-1 starfighter'\n        ) THEN TRUE\n        ELSE FALSE\n    END AS is_iconic,\n    \n    -- Vehicle popularity rating (1-10)\n    CASE\n        WHEN LOWER(vc.vehicle_name) IN ('at-at', 'at-st', 'snowspeeder', 'tie fighter', 'speeder bike') THEN 10\n        WHEN LOWER(vc.vehicle_name) IN ('sandcrawler', 'sail barge', 'cloud car', 'at-te', 'laat/i') THEN 8\n        WHEN LOWER(vc.vehicle_name) IN ('juggernaut', 'hailfire droid', 'vulture droid') THEN 6\n        WHEN vc.is_iconic THEN 7\n        WHEN vc.faction_affiliation = 'Imperial' THEN 5\n        WHEN vc.faction_affiliation = 'Republic' THEN 5\n        WHEN vc.faction_affiliation = 'Rebel Alliance' THEN 5\n        ELSE 3\n    END AS popularity_rating,\n    \n    -- Film appearances (episodes)\n    CASE\n        WHEN LOWER(vc.vehicle_name) = 'sandcrawler' THEN ARRAY[4]\n        WHEN LOWER(vc.vehicle_name) IN ('at-at', 'snowspeeder') THEN ARRAY[5]\n        WHEN LOWER(vc.vehicle_name) IN ('at-st', 'speeder bike') THEN ARRAY[6]\n        WHEN LOWER(vc.vehicle_name) = 'sail barge' THEN ARRAY[6]\n        WHEN LOWER(vc.vehicle_name) LIKE '%cloud car%' THEN ARRAY[5]\n        WHEN LOWER(vc.vehicle_name) IN ('vulture droid', 'sith speeder') THEN ARRAY[1]\n        WHEN LOWER(vc.vehicle_name) IN ('at-te', 'hailfire droid', 'corporate alliance tank droid', 'flitknot speeder') THEN ARRAY[2]\n        WHEN LOWER(vc.vehicle_name) IN ('laat/i', 'juggernaut', 'spha') THEN ARRAY[2, 3]\n        WHEN LOWER(vc.vehicle_name) LIKE '%airspeeder%' THEN ARRAY[2, 3]\n        WHEN LOWER(vc.vehicle_name) = 'tribubble bongo' THEN ARRAY[1]\n        ELSE NULL\n    END AS film_appearances,\n    \n    -- Vehicle versatility score (1-10) based on multipurpose functionality\n    CASE\n        WHEN vc.cargo_capacity > 1000 AND vc.passengers > 10 THEN 8\n        WHEN vc.vehicle_purpose = 'Multipurpose' THEN 7\n        WHEN vc.cargo_capacity > 500 AND vc.passengers > 5 THEN 6\n        WHEN vc.vehicle_purpose = 'Transport' THEN 5\n        WHEN vc.vehicle_purpose = 'Military' THEN 3\n        ELSE 4\n    END AS versatility_score,\n    \n    -- Add another attribute like \"stealth capability\" for military vehicles\n    CASE\n        WHEN vc.vehicle_purpose = 'Military' AND\n             (LOWER(vc.vehicle_name) LIKE '%scout%' OR\n              LOWER(vc.vehicle_name) LIKE '%speeder bike%' OR\n              LOWER(vc.model) LIKE '%recon%') THEN 'High Stealth'\n        WHEN vc.vehicle_purpose = 'Military' AND\n             (LOWER(vc.vehicle_name) LIKE '%at-%' OR\n              LOWER(vc.vehicle_name) LIKE '%walker%') THEN 'Low Stealth'\n        WHEN vc.vehicle_purpose = 'Military' THEN 'Moderate Stealth'\n        ELSE 'Not Applicable'\n    END AS stealth_capability,\n    \n    -- Data tracking field\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM vehicle_context vc\nWHERE vc.vehicle_id IS NOT NULL\nORDER BY vc.faction_affiliation, effectiveness_rating DESC, vc.vehicle_name", "language": "sql", "refs": [{"name": "stg_swapi_vehicles", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": [], "nodes": ["model.nerd_facts_dbt.stg_swapi_vehicles"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": [], "time_spine": null}, "model.nerd_facts_dbt.stg_swapi_vehicles": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_vehicles", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_vehicles.sql", "original_file_path": "models/staging/swapi/stg_swapi_vehicles.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_vehicles", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_vehicles"], "alias": "stg_swapi_vehicles", "checksum": {"name": "sha256", "checksum": "d1d222ec1d6eba485a2ca5908a7884e57bb834006456a44577333dbfe3571fad"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars vehicle data with terrain capabilities and classifications", "columns": {"id": {"name": "id", "description": "Primary key for vehicles", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Vehicle name", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "model": {"name": "model", "description": "Vehicle model", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "manufacturer": {"name": "manufacturer", "description": "Vehicle manufacturer", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "cost_in_credits": {"name": "cost_in_credits", "description": "Cost in galactic credits", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "length": {"name": "length", "description": "Length in meters", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "max_atmosphering_speed": {"name": "max_atmosphering_speed", "description": "Maximum speed in atmosphere", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "crew": {"name": "crew", "description": "Number of crew required", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "passengers": {"name": "passengers", "description": "Number of passengers vehicle can transport", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "cargo_capacity": {"name": "cargo_capacity", "description": "Cargo capacity in kilograms", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "consumables": {"name": "consumables", "description": "Time period before requiring resupply", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "vehicle_class": {"name": "vehicle_class", "description": "Vehicle class (e.g., wheeled, repulsorcraft)", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "pilots": {"name": "pilots", "description": "JSONB array of pilot references", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "films": {"name": "films", "description": "JSONB array of film appearances", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_vehicles.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742205059.3548694, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_vehicles\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_vehicles\n  Description: Standardizes Star Wars vehicle data from SWAPI\n  Source: raw.swapi_vehicles\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Speeds and capacities have proper error handling\n  - Pilot and film references are extracted as counts\n  - Additional derived fields help with vehicle classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        model,\n        manufacturer,\n        NULLIF(cost_in_credits, 'unknown') AS cost_in_credits,\n        NULLIF(length, 'unknown') AS length,\n        NULLIF(max_atmosphering_speed, 'unknown') AS max_atmosphering_speed,\n        NULLIF(crew, 'unknown') AS crew,\n        NULLIF(passengers, 'unknown') AS passengers,\n        NULLIF(cargo_capacity, 'unknown') AS cargo_capacity,\n        consumables,\n        vehicle_class,\n        CASE WHEN pilots IS NULL OR pilots = '' THEN NULL::jsonb ELSE pilots::jsonb END AS pilots,\n        CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM {{ source('swapi', 'vehicles') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS vehicle_name,\n    model,\n    manufacturer,\n    vehicle_class,\n    \n    -- Technical specifications with proper error handling\n    CASE \n        WHEN lower(cost_in_credits) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cost_in_credits, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cost_in_credits,\n    \n    CASE \n        WHEN lower(length) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(length, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS length_m,\n    \n    CASE \n        WHEN lower(max_atmosphering_speed) = 'unknown' THEN NULL\n        WHEN lower(max_atmosphering_speed) = 'n/a' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(max_atmosphering_speed, '[^0-9]+.*', '', 'g'), '')::INTEGER \n    END AS max_speed,\n    \n    -- Capacity information with proper type conversion\n    CASE \n        WHEN lower(crew) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER\n    END AS crew_count,\n    \n    CASE \n        WHEN lower(passengers) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER\n    END AS passenger_capacity,\n    \n    CASE \n        WHEN lower(cargo_capacity) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cargo_capacity, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cargo_capacity,\n    \n    consumables,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(pilots), 0) AS pilot_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    pilots,\n    films,\n    \n    -- Derived vehicle classifications\n    CASE\n        WHEN lower(vehicle_class) IN ('assault', 'combat', 'battle') \n             OR lower(name) LIKE '%fighter%' \n             OR lower(name) LIKE '%tank%'\n             OR lower(name) LIKE '%cannon%' THEN 'Military'\n        WHEN lower(vehicle_class) IN ('transport', 'cargo', 'container') \n             OR lower(name) LIKE '%transport%'\n             OR lower(name) LIKE '%freighter%' THEN 'Transport'\n        WHEN lower(vehicle_class) IN ('speeder', 'airspeeder', 'swoop', 'landspeeder') \n             OR lower(name) LIKE '%speeder%' THEN 'Personal'\n        ELSE 'Other'\n    END AS vehicle_purpose,\n    \n    -- Size classification\n    CASE\n        WHEN length IS NULL THEN 'Unknown'\n        WHEN length::NUMERIC < 10 THEN 'Small'\n        WHEN length::NUMERIC < 25 THEN 'Medium'\n        WHEN length::NUMERIC < 100 THEN 'Large'\n        ELSE 'Very Large'\n    END AS vehicle_size,\n    \n    -- Terrain capability\n    CASE\n        WHEN lower(vehicle_class) LIKE '%walker%' \n             OR lower(name) LIKE '%walker%' THEN 'Ground Only'\n        WHEN lower(vehicle_class) LIKE '%speeder%'\n             OR lower(name) LIKE '%speeder%' THEN 'Ground & Low Altitude'\n        WHEN lower(vehicle_class) LIKE '%airspeeder%'\n             OR lower(name) LIKE '%airspeeder%' THEN 'Aerial'\n        ELSE 'Unknown'\n    END AS terrain_capability,\n    \n    -- Notable vehicle flag\n    CASE\n        WHEN name IN ('AT-AT', 'AT-ST', 'Snowspeeder', 'Speeder bike',\n                     'Sand Crawler', 'TIE bomber', 'Imperial Speeder Bike') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_vehicle,\n    \n    -- Total capacity (crew + passengers)\n    COALESCE(\n        NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) + \n    COALESCE(\n        NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) AS total_capacity,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [["swapi", "vehicles"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.swapi.vehicles"]}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_vehicles.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_vehicles\n  Description: Standardizes Star Wars vehicle data from SWAPI\n  Source: raw.swapi_vehicles\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Speeds and capacities have proper error handling\n  - Pilot and film references are extracted as counts\n  - Additional derived fields help with vehicle classification\n*/\n\nWITH raw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        model,\n        manufacturer,\n        NULLIF(cost_in_credits, 'unknown') AS cost_in_credits,\n        NULLIF(length, 'unknown') AS length,\n        NULLIF(max_atmosphering_speed, 'unknown') AS max_atmosphering_speed,\n        NULLIF(crew, 'unknown') AS crew,\n        NULLIF(passengers, 'unknown') AS passengers,\n        NULLIF(cargo_capacity, 'unknown') AS cargo_capacity,\n        consumables,\n        vehicle_class,\n        CASE WHEN pilots IS NULL OR pilots = '' THEN NULL::jsonb ELSE pilots::jsonb END AS pilots,\n        CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END AS films,\n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM \"nerd_facts\".\"raw\".\"swapi_vehicles\"\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS vehicle_name,\n    model,\n    manufacturer,\n    vehicle_class,\n    \n    -- Technical specifications with proper error handling\n    CASE \n        WHEN lower(cost_in_credits) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cost_in_credits, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cost_in_credits,\n    \n    CASE \n        WHEN lower(length) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(length, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS length_m,\n    \n    CASE \n        WHEN lower(max_atmosphering_speed) = 'unknown' THEN NULL\n        WHEN lower(max_atmosphering_speed) = 'n/a' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(max_atmosphering_speed, '[^0-9]+.*', '', 'g'), '')::INTEGER \n    END AS max_speed,\n    \n    -- Capacity information with proper type conversion\n    CASE \n        WHEN lower(crew) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER\n    END AS crew_count,\n    \n    CASE \n        WHEN lower(passengers) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER\n    END AS passenger_capacity,\n    \n    CASE \n        WHEN lower(cargo_capacity) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(cargo_capacity, '[^0-9]', '', 'g'), '')::NUMERIC\n    END AS cargo_capacity,\n    \n    consumables,\n    \n    -- Entity counts with error handling\n    COALESCE(jsonb_array_length(pilots), 0) AS pilot_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    pilots,\n    films,\n    \n    -- Derived vehicle classifications\n    CASE\n        WHEN lower(vehicle_class) IN ('assault', 'combat', 'battle') \n             OR lower(name) LIKE '%fighter%' \n             OR lower(name) LIKE '%tank%'\n             OR lower(name) LIKE '%cannon%' THEN 'Military'\n        WHEN lower(vehicle_class) IN ('transport', 'cargo', 'container') \n             OR lower(name) LIKE '%transport%'\n             OR lower(name) LIKE '%freighter%' THEN 'Transport'\n        WHEN lower(vehicle_class) IN ('speeder', 'airspeeder', 'swoop', 'landspeeder') \n             OR lower(name) LIKE '%speeder%' THEN 'Personal'\n        ELSE 'Other'\n    END AS vehicle_purpose,\n    \n    -- Size classification\n    CASE\n        WHEN length IS NULL THEN 'Unknown'\n        WHEN length::NUMERIC < 10 THEN 'Small'\n        WHEN length::NUMERIC < 25 THEN 'Medium'\n        WHEN length::NUMERIC < 100 THEN 'Large'\n        ELSE 'Very Large'\n    END AS vehicle_size,\n    \n    -- Terrain capability\n    CASE\n        WHEN lower(vehicle_class) LIKE '%walker%' \n             OR lower(name) LIKE '%walker%' THEN 'Ground Only'\n        WHEN lower(vehicle_class) LIKE '%speeder%'\n             OR lower(name) LIKE '%speeder%' THEN 'Ground & Low Altitude'\n        WHEN lower(vehicle_class) LIKE '%airspeeder%'\n             OR lower(name) LIKE '%airspeeder%' THEN 'Aerial'\n        ELSE 'Unknown'\n    END AS terrain_capability,\n    \n    -- Notable vehicle flag\n    CASE\n        WHEN name IN ('AT-AT', 'AT-ST', 'Snowspeeder', 'Speeder bike',\n                     'Sand Crawler', 'TIE bomber', 'Imperial Speeder Bike') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_vehicle,\n    \n    -- Total capacity (crew + passengers)\n    COALESCE(\n        NULLIF(REGEXP_REPLACE(crew, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) + \n    COALESCE(\n        NULLIF(REGEXP_REPLACE(passengers, '[^0-9]', '', 'g'), '')::INTEGER, 0\n    ) AS total_capacity,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "test.nerd_facts_dbt.unique_stg_swapi_people_id.61c011a764": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_people_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_people_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_people_id.61c011a764", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_people_id"], "alias": "unique_stg_swapi_people_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4488752, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_people"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_people", "attached_node": "model.nerd_facts_dbt.stg_swapi_people", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_people')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_people_id.7a1b515eed": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_people_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_people_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_people_id.7a1b515eed", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_people_id"], "alias": "not_null_stg_swapi_people_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4502747, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_people"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_people", "attached_node": "model.nerd_facts_dbt.stg_swapi_people", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_people')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_people_name.f39acc5c3f": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_people_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_people_name.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_people_name.f39acc5c3f", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_people_name"], "alias": "not_null_stg_swapi_people_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4518013, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_people", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_people"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "models.stg_swapi_people", "attached_node": "model.nerd_facts_dbt.stg_swapi_people", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(ref('stg_swapi_people')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.unique_stg_swapi_species_id.d223d89b92": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_species_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_species_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_species_id.d223d89b92", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_species_id"], "alias": "unique_stg_swapi_species_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4624212, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_species", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_species"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_species", "attached_node": "model.nerd_facts_dbt.stg_swapi_species", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_species')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_species_id.09ea9d15a8": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_species_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_species_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_species_id.09ea9d15a8", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_species_id"], "alias": "not_null_stg_swapi_species_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4639883, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_species", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_species"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_species", "attached_node": "model.nerd_facts_dbt.stg_swapi_species", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_species')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_species_name.72dd894221": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_species_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_species_name.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_species_name.72dd894221", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_species_name"], "alias": "not_null_stg_swapi_species_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4655855, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_species", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_species"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "models.stg_swapi_species", "attached_node": "model.nerd_facts_dbt.stg_swapi_species", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(ref('stg_swapi_species')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.unique_stg_swapi_vehicles_id.8b524818ea": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_vehicles_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_vehicles_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_vehicles_id.8b524818ea", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_vehicles_id"], "alias": "unique_stg_swapi_vehicles_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.4669373, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_vehicles", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_vehicles"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_vehicles", "attached_node": "model.nerd_facts_dbt.stg_swapi_vehicles", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_vehicles')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_id.fb013dcb6d": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_vehicles_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_vehicles_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_id.fb013dcb6d", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_vehicles_id"], "alias": "not_null_stg_swapi_vehicles_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.468129, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_vehicles", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_vehicles"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_vehicles", "attached_node": "model.nerd_facts_dbt.stg_swapi_vehicles", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_vehicles')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_name.f1ef2875b7": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_vehicles_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_vehicles_name.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_name.f1ef2875b7", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_vehicles_name"], "alias": "not_null_stg_swapi_vehicles_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.469328, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_vehicles", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_vehicles"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "models.stg_swapi_vehicles", "attached_node": "model.nerd_facts_dbt.stg_swapi_vehicles", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(ref('stg_swapi_vehicles')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.source_unique_swapi_starships_id.4a35a82bda": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "source_unique_swapi_starships_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "source_unique_swapi_starships_id.sql", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "test.nerd_facts_dbt.source_unique_swapi_starships_id.4a35a82bda", "fqn": ["nerd_facts_dbt", "staging", "swapi", "source_unique_swapi_starships_id"], "alias": "source_unique_swapi_starships_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.5412338, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [], "sources": [["swapi", "starships"]], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["source.nerd_facts_dbt.swapi.starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "sources.swapi", "attached_node": null, "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(source('swapi', 'starships')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.source_not_null_swapi_starships_id.20f60e38ef": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "source_not_null_swapi_starships_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "source_not_null_swapi_starships_id.sql", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "test.nerd_facts_dbt.source_not_null_swapi_starships_id.20f60e38ef", "fqn": ["nerd_facts_dbt", "staging", "swapi", "source_not_null_swapi_starships_id"], "alias": "source_not_null_swapi_starships_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205059.542981, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [], "sources": [["swapi", "starships"]], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["source.nerd_facts_dbt.swapi.starships"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "sources.swapi", "attached_node": null, "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(source('swapi', 'starships')) }}"}, "namespace": null}}, "model.nerd_facts_dbt.stg_swapi_films": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_films", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_films.sql", "original_file_path": "models/staging/swapi/stg_swapi_films.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_films", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_films"], "alias": "stg_swapi_films", "checksum": {"name": "sha256", "checksum": "b7b6ac3a6f9000e6a2f61b252a006f0233b6929d31039f73c3fd8b0b6680fe28"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars film data with chronological ordering and entity counts", "columns": {"id": {"name": "id", "description": "Primary key for films", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "title": {"name": "title", "description": "Film title", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "episode_id": {"name": "episode_id", "description": "Episode number in the saga", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "opening_crawl": {"name": "opening_crawl", "description": "Opening crawl text from the film", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "director": {"name": "director", "description": "Film director", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "producer": {"name": "producer", "description": "Film producer(s)", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "release_date": {"name": "release_date", "description": "Theatrical release date", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "created": {"name": "created", "description": "Record creation timestamp", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "edited": {"name": "edited", "description": "Record last update timestamp", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_films.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742205255.7345092, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_films\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_films\n  Description: Standardizes Star Wars film data from SWAPI\n  Source: raw.swapi_films\n  \n  Notes:\n  - Adds derived fields for easier analysis (release_year, trilogy)\n  - Extracts counts from related entities (characters, planets, species)\n  - Converts dates to proper DATE types and adds chronological ordering\n*/\n\n-- First, let's check what columns actually exist in the source table\nWITH column_check AS (\n    SELECT \n        column_name \n    FROM information_schema.columns \n    WHERE table_schema = 'raw' \n    AND table_name = 'swapi_films'\n),\n\nraw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        episode_id,\n        title,\n        director,\n        producer,\n        release_date,\n        opening_crawl,\n        \n        -- Dynamically handle character data - could be \"characters\" or \"people\"\n        CASE \n            -- Handle case where column is named \"characters\"\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'characters') \n            THEN \n                CASE WHEN characters IS NULL OR characters = '' THEN NULL::jsonb \n                ELSE characters::jsonb END\n            -- Handle case where column is named \"people\" \n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'people')\n            THEN\n                CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb \n                ELSE people::jsonb END\n            -- Fallback to empty array\n            ELSE '[]'::jsonb\n        END AS characters,\n        \n        -- Additional fields with safer access\n        CASE WHEN planets IS NULL OR planets = '' THEN NULL::jsonb \n             ELSE planets::jsonb END AS planets,\n        CASE WHEN starships IS NULL OR starships = '' THEN NULL::jsonb \n             ELSE starships::jsonb END AS starships,\n        CASE WHEN vehicles IS NULL OR vehicles = '' THEN NULL::jsonb \n             ELSE vehicles::jsonb END AS vehicles,\n        CASE WHEN species IS NULL OR species = '' THEN NULL::jsonb \n             ELSE species::jsonb END AS species,\n        created,\n        edited,\n        url\n    FROM {{ source('swapi', 'films') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    episode_id,\n    title AS film_title,\n    \n    -- Creative team\n    director,\n    producer,\n    \n    -- Standardize dates and add derived time fields\n    CASE \n        WHEN release_date IS NULL OR release_date = '' THEN NULL\n        ELSE TO_DATE(release_date, 'YYYY-MM-DD') \n    END AS release_date,\n    \n    EXTRACT(YEAR FROM TO_DATE(release_date, 'YYYY-MM-DD')) AS release_year,\n    \n    -- Story elements\n    opening_crawl,\n    \n    -- Derived chronological order (story timeline vs. release order)\n    CASE episode_id\n        WHEN 1 THEN 1  -- The Phantom Menace\n        WHEN 2 THEN 2  -- Attack of the Clones\n        WHEN 3 THEN 3  -- Revenge of the Sith\n        WHEN 4 THEN 4  -- A New Hope\n        WHEN 5 THEN 5  -- Empire Strikes Back\n        WHEN 6 THEN 6  -- Return of the Jedi\n        WHEN 7 THEN 7  -- The Force Awakens\n        WHEN 8 THEN 8  -- The Last Jedi\n        WHEN 9 THEN 9  -- The Rise of Skywalker\n        ELSE 99        -- Unknown/other\n    END AS chronological_order,\n    \n    -- Trilogy classification\n    CASE\n        WHEN episode_id BETWEEN 1 AND 3 THEN 'Prequel Trilogy'\n        WHEN episode_id BETWEEN 4 AND 6 THEN 'Original Trilogy'\n        WHEN episode_id BETWEEN 7 AND 9 THEN 'Sequel Trilogy'\n        ELSE 'Anthology'\n    END AS trilogy,\n    \n    -- Entity counts with safer access\n    COALESCE(jsonb_array_length(characters), 0) AS character_count,\n    COALESCE(jsonb_array_length(planets), 0) AS planet_count,\n    COALESCE(jsonb_array_length(starships), 0) AS starship_count,\n    COALESCE(jsonb_array_length(vehicles), 0) AS vehicle_count,\n    COALESCE(jsonb_array_length(species), 0) AS species_count,\n    \n    -- Word count of opening crawl (approximate)\n    ARRAY_LENGTH(STRING_TO_ARRAY(REGEXP_REPLACE(COALESCE(opening_crawl, ''), '\\r|\\n', ' ', 'g'), ' '), 1) AS opening_crawl_word_count,\n    \n    -- API metadata with proper handling\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Data tracking\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data\nORDER BY episode_id", "language": "sql", "refs": [], "sources": [["swapi", "films"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.swapi.films"]}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_films.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_films\n  Description: Standardizes Star Wars film data from SWAPI\n  Source: raw.swapi_films\n  \n  Notes:\n  - Adds derived fields for easier analysis (release_year, trilogy)\n  - Extracts counts from related entities (characters, planets, species)\n  - Converts dates to proper DATE types and adds chronological ordering\n*/\n\n-- First, let's check what columns actually exist in the source table\nWITH column_check AS (\n    SELECT \n        column_name \n    FROM information_schema.columns \n    WHERE table_schema = 'raw' \n    AND table_name = 'swapi_films'\n),\n\nraw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        episode_id,\n        title,\n        director,\n        producer,\n        release_date,\n        opening_crawl,\n        \n        -- Dynamically handle character data - could be \"characters\" or \"people\"\n        CASE \n            -- Handle case where column is named \"characters\"\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'characters') \n            THEN \n                CASE WHEN characters IS NULL OR characters = '' THEN NULL::jsonb \n                ELSE characters::jsonb END\n            -- Handle case where column is named \"people\" \n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'people')\n            THEN\n                CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb \n                ELSE people::jsonb END\n            -- Fallback to empty array\n            ELSE '[]'::jsonb\n        END AS characters,\n        \n        -- Additional fields with safer access\n        CASE WHEN planets IS NULL OR planets = '' THEN NULL::jsonb \n             ELSE planets::jsonb END AS planets,\n        CASE WHEN starships IS NULL OR starships = '' THEN NULL::jsonb \n             ELSE starships::jsonb END AS starships,\n        CASE WHEN vehicles IS NULL OR vehicles = '' THEN NULL::jsonb \n             ELSE vehicles::jsonb END AS vehicles,\n        CASE WHEN species IS NULL OR species = '' THEN NULL::jsonb \n             ELSE species::jsonb END AS species,\n        created,\n        edited,\n        url\n    FROM \"nerd_facts\".\"raw\".\"swapi_films\"\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    episode_id,\n    title AS film_title,\n    \n    -- Creative team\n    director,\n    producer,\n    \n    -- Standardize dates and add derived time fields\n    CASE \n        WHEN release_date IS NULL OR release_date = '' THEN NULL\n        ELSE TO_DATE(release_date, 'YYYY-MM-DD') \n    END AS release_date,\n    \n    EXTRACT(YEAR FROM TO_DATE(release_date, 'YYYY-MM-DD')) AS release_year,\n    \n    -- Story elements\n    opening_crawl,\n    \n    -- Derived chronological order (story timeline vs. release order)\n    CASE episode_id\n        WHEN 1 THEN 1  -- The Phantom Menace\n        WHEN 2 THEN 2  -- Attack of the Clones\n        WHEN 3 THEN 3  -- Revenge of the Sith\n        WHEN 4 THEN 4  -- A New Hope\n        WHEN 5 THEN 5  -- Empire Strikes Back\n        WHEN 6 THEN 6  -- Return of the Jedi\n        WHEN 7 THEN 7  -- The Force Awakens\n        WHEN 8 THEN 8  -- The Last Jedi\n        WHEN 9 THEN 9  -- The Rise of Skywalker\n        ELSE 99        -- Unknown/other\n    END AS chronological_order,\n    \n    -- Trilogy classification\n    CASE\n        WHEN episode_id BETWEEN 1 AND 3 THEN 'Prequel Trilogy'\n        WHEN episode_id BETWEEN 4 AND 6 THEN 'Original Trilogy'\n        WHEN episode_id BETWEEN 7 AND 9 THEN 'Sequel Trilogy'\n        ELSE 'Anthology'\n    END AS trilogy,\n    \n    -- Entity counts with safer access\n    COALESCE(jsonb_array_length(characters), 0) AS character_count,\n    COALESCE(jsonb_array_length(planets), 0) AS planet_count,\n    COALESCE(jsonb_array_length(starships), 0) AS starship_count,\n    COALESCE(jsonb_array_length(vehicles), 0) AS vehicle_count,\n    COALESCE(jsonb_array_length(species), 0) AS species_count,\n    \n    -- Word count of opening crawl (approximate)\n    ARRAY_LENGTH(STRING_TO_ARRAY(REGEXP_REPLACE(COALESCE(opening_crawl, ''), '\\r|\\n', ' ', 'g'), ' '), 1) AS opening_crawl_word_count,\n    \n    -- API metadata with proper handling\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Data tracking\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data\nORDER BY episode_id", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "test.nerd_facts_dbt.unique_stg_swapi_films_id.14c2b7f5e2": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_films_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_films_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_films_id.14c2b7f5e2", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_films_id"], "alias": "unique_stg_swapi_films_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.837086, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_films_id.4e52f2f208": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_films_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_films_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_films_id.4e52f2f208", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_films_id"], "alias": "not_null_stg_swapi_films_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.8386495, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_films_title.4f45458548": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_films_title", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_films_title.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_films_title.4f45458548", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_films_title"], "alias": "not_null_stg_swapi_films_title", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.839955, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "title", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "title", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_films_episode_id.bc98d1b696": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_films_episode_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_films_episode_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_films_episode_id.bc98d1b696", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_films_episode_id"], "alias": "not_null_stg_swapi_films_episode_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.841197, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "episode_id", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "episode_id", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.a5d4199e05": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.a5d4199e05", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1"], "alias": "dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.8424447, "relation_name": null, "raw_code": "{{ dbt_utils.test_accepted_range(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_accepted_range", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "episode_id", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "accepted_range", "kwargs": {"min_value": 1, "max_value": 9, "column_name": "episode_id", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": "dbt_utils"}}, "test.nerd_facts_dbt.not_null_stg_swapi_films_release_date.6599c8fb74": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_films_release_date", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_films_release_date.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_films_release_date.6599c8fb74", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_films_release_date"], "alias": "not_null_stg_swapi_films_release_date", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205255.8601184, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_films", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_films"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "release_date", "file_key_name": "models.stg_swapi_films", "attached_node": "model.nerd_facts_dbt.stg_swapi_films", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "release_date", "model": "{{ get_where_subquery(ref('stg_swapi_films')) }}"}, "namespace": null}}, "model.nerd_facts_dbt.stg_swapi_planets": {"database": "nerd_facts", "schema": "public", "name": "stg_swapi_planets", "resource_type": "model", "package_name": "nerd_facts_dbt", "path": "staging/swapi/stg_swapi_planets.sql", "original_file_path": "models/staging/swapi/stg_swapi_planets.sql", "unique_id": "model.nerd_facts_dbt.stg_swapi_planets", "fqn": ["nerd_facts_dbt", "staging", "swapi", "stg_swapi_planets"], "alias": "stg_swapi_planets", "checksum": {"name": "sha256", "checksum": "5d6efad3c5334a40f44529af8bb471dbc33dd43935133fd781ae920657352f55"}, "config": {"enabled": true, "alias": null, "schema": null, "database": null, "tags": [], "meta": {}, "group": null, "materialized": "view", "incremental_strategy": null, "batch_size": null, "lookback": 1, "begin": null, "persist_docs": {}, "post-hook": [], "pre-hook": [], "quoting": {}, "column_types": {}, "full_refresh": null, "unique_key": null, "on_schema_change": "ignore", "on_configuration_change": "apply", "grants": {}, "packages": [], "docs": {"show": true, "node_color": null}, "contract": {"enforced": false, "alias_types": true}, "event_time": null, "concurrent_batches": null, "access": "protected"}, "tags": [], "description": "Standardized Star Wars planet data with habitability scores and climate classifications", "columns": {"id": {"name": "id", "description": "Primary key for planets", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Planet name", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "rotation_period": {"name": "rotation_period", "description": "Hours to complete one rotation on axis", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "orbital_period": {"name": "orbital_period", "description": "Days to complete one orbit around star", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "diameter": {"name": "diameter", "description": "Diameter in kilometers", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "climate": {"name": "climate", "description": "Climate types on planet", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "gravity": {"name": "gravity", "description": "Gravity relative to standard", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "terrain": {"name": "terrain", "description": "Terrain types on planet", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "surface_water": {"name": "surface_water", "description": "Percentage of planet covered by water", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "population": {"name": "population", "description": "Population count", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": "nerd_facts_dbt://models/staging/swapi/stg_swapi.yml", "build_path": "target/run/nerd_facts_dbt/models/staging/swapi/stg_swapi_planets.sql", "unrendered_config": {"materialized": "view"}, "created_at": 1742205418.1114185, "relation_name": "\"nerd_facts\".\"public\".\"stg_swapi_planets\"", "raw_code": "{{\n  config(\n    materialized = 'view'\n  )\n}}\n\n/*\n  Model: stg_swapi_planets\n  Description: Standardizes Star Wars planet data from SWAPI\n  Source: raw.swapi_planets\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Population is handled with appropriate NULL values\n  - Derived planet classifications are added for analysis\n  - Climate and terrain are standardized for consistency\n*/\n\n-- First check what columns actually exist\nWITH column_check AS (\n    SELECT \n        column_name \n    FROM information_schema.columns \n    WHERE table_schema = 'raw' \n    AND table_name = 'swapi_planets'\n),\n\nraw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        rotation_period,\n        orbital_period,\n        diameter,\n        climate,\n        gravity,\n        terrain,\n        surface_water,\n        population,\n        \n        -- Handle various possible column names for resident data\n        CASE\n            -- Check for standard \"residents\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'residents')\n            THEN CASE WHEN residents IS NULL OR residents = '' THEN NULL::jsonb ELSE residents::jsonb END\n            \n            -- Check for alternative \"people\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'people')\n            THEN CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb ELSE people::jsonb END\n            \n            -- Check for alternative \"characters\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'characters')\n            THEN CASE WHEN characters IS NULL OR characters = '' THEN NULL::jsonb ELSE characters::jsonb END\n            \n            -- Default to empty array if no matching column found\n            ELSE '[]'::jsonb\n        END AS residents,\n        \n        -- Handle films data with similar approach\n        CASE\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'films')\n            THEN CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END\n            \n            -- Default to empty array if no matching column found\n            ELSE '[]'::jsonb\n        END AS films,\n        \n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM {{ source('swapi', 'planets') }}\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS planet_name,\n    \n    -- Physical characteristics with proper typing\n    CASE \n        WHEN rotation_period IS NULL OR lower(rotation_period) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(rotation_period, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS rotation_period,\n    \n    CASE \n        WHEN orbital_period IS NULL OR lower(orbital_period) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(orbital_period, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS orbital_period,\n    \n    CASE \n        WHEN diameter IS NULL OR lower(diameter) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(diameter, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS diameter,\n    \n    -- Environment attributes\n    LOWER(COALESCE(climate, 'unknown')) AS climate,\n    LOWER(COALESCE(gravity, 'unknown')) AS gravity,\n    LOWER(COALESCE(terrain, 'unknown')) AS terrain,\n    \n    CASE \n        WHEN surface_water IS NULL OR lower(surface_water) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(surface_water, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS surface_water,\n    \n    -- Population with proper handling\n    CASE \n        WHEN population IS NULL OR lower(population) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(population, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS population,\n    \n    -- Entity counts\n    COALESCE(jsonb_array_length(residents), 0) AS resident_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    residents,\n    films,\n    \n    -- Derived classifications\n    CASE\n        WHEN lower(climate) LIKE '%temperate%' THEN TRUE\n        ELSE FALSE\n    END AS is_temperate,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%forest%' OR \n             lower(terrain) LIKE '%jungle%' OR\n             lower(terrain) LIKE '%grasslands%' THEN TRUE\n        ELSE FALSE\n    END AS has_vegetation,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%ocean%' OR \n             lower(terrain) LIKE '%water%' OR\n             (surface_water IS NOT NULL AND \n              CASE WHEN surface_water ~ '^[0-9\\.]+$' \n                   THEN surface_water::NUMERIC > 50 \n                   ELSE FALSE \n              END) THEN TRUE\n        ELSE FALSE\n    END AS is_water_world,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%desert%' OR \n             lower(climate) LIKE '%arid%' OR\n             (surface_water IS NOT NULL AND TRY_CAST(surface_water AS NUMERIC) < 5) THEN TRUE\n        ELSE FALSE\n    END AS is_desert_world,\n    \n    -- Planet habitability score (0-100)\n    CASE\n        WHEN lower(climate) LIKE '%temperate%' THEN\n            CASE\n                WHEN lower(terrain) LIKE '%forest%' OR \n                     lower(terrain) LIKE '%grasslands%' THEN 90\n                ELSE 75\n            END\n        WHEN lower(climate) LIKE '%tropical%' OR lower(climate) LIKE '%humid%' THEN 65\n        WHEN lower(climate) LIKE '%arid%' OR lower(climate) LIKE '%hot%' THEN 35\n        WHEN lower(climate) LIKE '%frozen%' OR lower(climate) LIKE '%frigid%' THEN 15\n        ELSE 50\n    END AS habitability_score,\n    \n    -- Notable planet flag\n    CASE\n        WHEN name IN ('Tatooine', 'Alderaan', 'Yavin IV', 'Hoth', 'Dagobah', \n                      'Bespin', 'Endor', 'Naboo', 'Coruscant', 'Kamino', 'Geonosis') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_planet,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "language": "sql", "refs": [], "sources": [["swapi", "planets"]], "metrics": [], "depends_on": {"macros": [], "nodes": ["source.nerd_facts_dbt.swapi.planets"]}, "compiled_path": "target/compiled/nerd_facts_dbt/models/staging/swapi/stg_swapi_planets.sql", "compiled": true, "compiled_code": "\n\n/*\n  Model: stg_swapi_planets\n  Description: Standardizes Star Wars planet data from SWAPI\n  Source: raw.swapi_planets\n  \n  Notes:\n  - Numeric fields are cleaned and converted to proper types\n  - Population is handled with appropriate NULL values\n  - Derived planet classifications are added for analysis\n  - Climate and terrain are standardized for consistency\n*/\n\n-- First check what columns actually exist\nWITH column_check AS (\n    SELECT \n        column_name \n    FROM information_schema.columns \n    WHERE table_schema = 'raw' \n    AND table_name = 'swapi_planets'\n),\n\nraw_data AS (\n    -- Explicitly list columns to prevent issues if source schema changes\n    SELECT\n        id,\n        name,\n        rotation_period,\n        orbital_period,\n        diameter,\n        climate,\n        gravity,\n        terrain,\n        surface_water,\n        population,\n        \n        -- Handle various possible column names for resident data\n        CASE\n            -- Check for standard \"residents\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'residents')\n            THEN CASE WHEN residents IS NULL OR residents = '' THEN NULL::jsonb ELSE residents::jsonb END\n            \n            -- Check for alternative \"people\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'people')\n            THEN CASE WHEN people IS NULL OR people = '' THEN NULL::jsonb ELSE people::jsonb END\n            \n            -- Check for alternative \"characters\" column\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'characters')\n            THEN CASE WHEN characters IS NULL OR characters = '' THEN NULL::jsonb ELSE characters::jsonb END\n            \n            -- Default to empty array if no matching column found\n            ELSE '[]'::jsonb\n        END AS residents,\n        \n        -- Handle films data with similar approach\n        CASE\n            WHEN EXISTS (SELECT 1 FROM column_check WHERE column_name = 'films')\n            THEN CASE WHEN films IS NULL OR films = '' THEN NULL::jsonb ELSE films::jsonb END\n            \n            -- Default to empty array if no matching column found\n            ELSE '[]'::jsonb\n        END AS films,\n        \n        created,\n        edited,\n        CURRENT_TIMESTAMP AS _loaded_at\n    FROM \"nerd_facts\".\"raw\".\"swapi_planets\"\n    WHERE id IS NOT NULL\n)\n\nSELECT\n    -- Primary identifiers\n    id,\n    name AS planet_name,\n    \n    -- Physical characteristics with proper typing\n    CASE \n        WHEN rotation_period IS NULL OR lower(rotation_period) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(rotation_period, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS rotation_period,\n    \n    CASE \n        WHEN orbital_period IS NULL OR lower(orbital_period) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(orbital_period, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS orbital_period,\n    \n    CASE \n        WHEN diameter IS NULL OR lower(diameter) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(diameter, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS diameter,\n    \n    -- Environment attributes\n    LOWER(COALESCE(climate, 'unknown')) AS climate,\n    LOWER(COALESCE(gravity, 'unknown')) AS gravity,\n    LOWER(COALESCE(terrain, 'unknown')) AS terrain,\n    \n    CASE \n        WHEN surface_water IS NULL OR lower(surface_water) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(surface_water, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS surface_water,\n    \n    -- Population with proper handling\n    CASE \n        WHEN population IS NULL OR lower(population) = 'unknown' THEN NULL\n        ELSE NULLIF(REGEXP_REPLACE(population, '[^0-9\\.]', '', 'g'), '')::NUMERIC\n    END AS population,\n    \n    -- Entity counts\n    COALESCE(jsonb_array_length(residents), 0) AS resident_count,\n    COALESCE(jsonb_array_length(films), 0) AS film_appearances,\n    \n    -- Keep raw arrays for downstream usage\n    residents,\n    films,\n    \n    -- Derived classifications\n    CASE\n        WHEN lower(climate) LIKE '%temperate%' THEN TRUE\n        ELSE FALSE\n    END AS is_temperate,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%forest%' OR \n             lower(terrain) LIKE '%jungle%' OR\n             lower(terrain) LIKE '%grasslands%' THEN TRUE\n        ELSE FALSE\n    END AS has_vegetation,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%ocean%' OR \n             lower(terrain) LIKE '%water%' OR\n             (surface_water IS NOT NULL AND \n              CASE WHEN surface_water ~ '^[0-9\\.]+$' \n                   THEN surface_water::NUMERIC > 50 \n                   ELSE FALSE \n              END) THEN TRUE\n        ELSE FALSE\n    END AS is_water_world,\n    \n    CASE\n        WHEN lower(terrain) LIKE '%desert%' OR \n             lower(climate) LIKE '%arid%' OR\n             (surface_water IS NOT NULL AND TRY_CAST(surface_water AS NUMERIC) < 5) THEN TRUE\n        ELSE FALSE\n    END AS is_desert_world,\n    \n    -- Planet habitability score (0-100)\n    CASE\n        WHEN lower(climate) LIKE '%temperate%' THEN\n            CASE\n                WHEN lower(terrain) LIKE '%forest%' OR \n                     lower(terrain) LIKE '%grasslands%' THEN 90\n                ELSE 75\n            END\n        WHEN lower(climate) LIKE '%tropical%' OR lower(climate) LIKE '%humid%' THEN 65\n        WHEN lower(climate) LIKE '%arid%' OR lower(climate) LIKE '%hot%' THEN 35\n        WHEN lower(climate) LIKE '%frozen%' OR lower(climate) LIKE '%frigid%' THEN 15\n        ELSE 50\n    END AS habitability_score,\n    \n    -- Notable planet flag\n    CASE\n        WHEN name IN ('Tatooine', 'Alderaan', 'Yavin IV', 'Hoth', 'Dagobah', \n                      'Bespin', 'Endor', 'Naboo', 'Coruscant', 'Kamino', 'Geonosis') \n        THEN TRUE\n        ELSE FALSE\n    END AS is_notable_planet,\n    \n    -- API metadata\n    created::TIMESTAMP AS created_at,\n    edited::TIMESTAMP AS updated_at,\n    \n    -- Add data tracking fields\n    CURRENT_TIMESTAMP AS dbt_loaded_at\n    \nFROM raw_data", "extra_ctes_injected": true, "extra_ctes": [], "contract": {"enforced": false, "alias_types": true, "checksum": null}, "access": "protected", "constraints": [], "version": null, "latest_version": null, "deprecation_date": null, "primary_key": ["id"], "time_spine": null}, "test.nerd_facts_dbt.unique_stg_swapi_planets_id.6c040cab42": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "unique_stg_swapi_planets_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "unique_stg_swapi_planets_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.unique_stg_swapi_planets_id.6c040cab42", "fqn": ["nerd_facts_dbt", "staging", "swapi", "unique_stg_swapi_planets_id"], "alias": "unique_stg_swapi_planets_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205418.2239838, "relation_name": null, "raw_code": "{{ test_unique(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_unique"], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_planets", "attached_node": "model.nerd_facts_dbt.stg_swapi_planets", "test_metadata": {"name": "unique", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_planets')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_planets_id.1980954ad2": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_planets_id", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_planets_id.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_planets_id.1980954ad2", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_planets_id"], "alias": "not_null_stg_swapi_planets_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205418.2258384, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "id", "file_key_name": "models.stg_swapi_planets", "attached_node": "model.nerd_facts_dbt.stg_swapi_planets", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "id", "model": "{{ get_where_subquery(ref('stg_swapi_planets')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.not_null_stg_swapi_planets_name.290277cf78": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "not_null_stg_swapi_planets_name", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "not_null_stg_swapi_planets_name.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.not_null_stg_swapi_planets_name.290277cf78", "fqn": ["nerd_facts_dbt", "staging", "swapi", "not_null_stg_swapi_planets_name"], "alias": "not_null_stg_swapi_planets_name", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": null, "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "ERROR", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {}, "created_at": 1742205418.2272818, "relation_name": null, "raw_code": "{{ test_not_null(**_dbt_generic_test_kwargs) }}", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "name", "file_key_name": "models.stg_swapi_planets", "attached_node": "model.nerd_facts_dbt.stg_swapi_planets", "test_metadata": {"name": "not_null", "kwargs": {"column_name": "name", "model": "{{ get_where_subquery(ref('stg_swapi_planets')) }}"}, "namespace": null}}, "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0.a9aca03c03": {"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "dbt_utils_accepted_range_stg_s_dc3789df0cd4354ea093aa3d5ed78748.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0.a9aca03c03", "fqn": ["nerd_facts_dbt", "staging", "swapi", "dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0"], "alias": "dbt_utils_accepted_range_stg_s_dc3789df0cd4354ea093aa3d5ed78748", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "alias": "dbt_utils_accepted_range_stg_s_dc3789df0cd4354ea093aa3d5ed78748", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "dbt_utils_accepted_range_stg_s_dc3789df0cd4354ea093aa3d5ed78748"}, "created_at": 1742205418.2294044, "relation_name": null, "raw_code": "{{ dbt_utils.test_accepted_range(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"dbt_utils_accepted_range_stg_s_dc3789df0cd4354ea093aa3d5ed78748\") }}", "language": "sql", "refs": [{"name": "stg_swapi_planets", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt_utils.test_accepted_range", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi_planets"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "surface_water", "file_key_name": "models.stg_swapi_planets", "attached_node": "model.nerd_facts_dbt.stg_swapi_planets", "test_metadata": {"name": "accepted_range", "kwargs": {"min_value": 0, "max_value": 100, "column_name": "surface_water", "model": "{{ get_where_subquery(ref('stg_swapi_planets')) }}"}, "namespace": "dbt_utils"}}}, "sources": {"source.nerd_facts_dbt.raw.swapi_people": {"database": "nerd_facts", "schema": "raw", "name": "swapi_people", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_people", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_people"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_people", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_people\"", "created_at": 1742132015.0815413, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.swapi_planets": {"database": "nerd_facts", "schema": "raw", "name": "swapi_planets", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_planets", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_planets"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_planets", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_planets\"", "created_at": 1742132015.0826, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.swapi_starships": {"database": "nerd_facts", "schema": "raw", "name": "swapi_starships", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_starships", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_starships"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_starships", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_starships\"", "created_at": 1742132015.082736, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.swapi_vehicles": {"database": "nerd_facts", "schema": "raw", "name": "swapi_vehicles", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_vehicles", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_vehicles"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_vehicles", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_vehicles\"", "created_at": 1742132015.0828586, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.swapi_species": {"database": "nerd_facts", "schema": "raw", "name": "swapi_species", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_species", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_species"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_species", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_species\"", "created_at": 1742132015.0829756, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.swapi_films": {"database": "nerd_facts", "schema": "raw", "name": "swapi_films", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.swapi_films", "fqn": ["nerd_facts_dbt", "raw", "raw", "swapi_films"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "swapi_films", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_films\"", "created_at": 1742132015.0830922, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.pokeapi_pokemon": {"database": "nerd_facts", "schema": "raw", "name": "pokeapi_pokemon", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.pokeapi_pokemon", "fqn": ["nerd_facts_dbt", "raw", "raw", "pokeapi_pokemon"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "pokeapi_pokemon", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"pokeapi_pokemon\"", "created_at": 1742132015.0832024, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.pokeapi_types": {"database": "nerd_facts", "schema": "raw", "name": "pokeapi_types", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.pokeapi_types", "fqn": ["nerd_facts_dbt", "raw", "raw", "pokeapi_types"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "pokeapi_types", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"pokeapi_types\"", "created_at": 1742132015.0833104, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.pokeapi_abilities": {"database": "nerd_facts", "schema": "raw", "name": "pokeapi_abilities", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.pokeapi_abilities", "fqn": ["nerd_facts_dbt", "raw", "raw", "pokeapi_abilities"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "pokeapi_abilities", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"pokeapi_abilities\"", "created_at": 1742132015.0834198, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.pokeapi_moves": {"database": "nerd_facts", "schema": "raw", "name": "pokeapi_moves", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.pokeapi_moves", "fqn": ["nerd_facts_dbt", "raw", "raw", "pokeapi_moves"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "pokeapi_moves", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"pokeapi_moves\"", "created_at": 1742132015.0835419, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.raw.pokeapi_items": {"database": "nerd_facts", "schema": "raw", "name": "pokeapi_items", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/raw/sources.yml", "original_file_path": "models/raw/sources.yml", "unique_id": "source.nerd_facts_dbt.raw.pokeapi_items", "fqn": ["nerd_facts_dbt", "raw", "raw", "pokeapi_items"], "source_name": "raw", "source_description": "", "loader": "", "identifier": "pokeapi_items", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"pokeapi_items\"", "created_at": 1742132015.083685, "unrendered_database": null, "unrendered_schema": "raw"}, "source.nerd_facts_dbt.pokeapi.moves": {"database": "pokemon_db", "schema": "public", "name": "moves", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/pokeapi/pokeapi_sources.yml", "original_file_path": "models/staging/pokeapi/pokeapi_sources.yml", "unique_id": "source.nerd_facts_dbt.pokeapi.moves", "fqn": ["nerd_facts_dbt", "staging", "pokeapi", "pokeapi", "moves"], "source_name": "pokeapi", "source_description": "Pokemon data from the PokeAPI", "loader": "", "identifier": "moves", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Pokemon moves including power, accuracy, and effect text\n", "columns": {"id": {"name": "id", "description": "Primary key for the move", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Name of the move", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"pokemon_db\".\"public\".\"moves\"", "created_at": 1742203914.7138653, "unrendered_database": "pokemon_db", "unrendered_schema": "public"}, "source.nerd_facts_dbt.swapi.starships": {"database": "nerd_facts", "schema": "raw", "name": "starships", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.starships", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "starships"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_starships", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars starships", "columns": {"id": {"name": "id", "description": "Primary key for starship", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}, "name": {"name": "name", "description": "Name of the starship", "meta": {}, "data_type": null, "constraints": [], "quote": null, "tags": [], "granularity": null}}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_starships\"", "created_at": 1742205059.5473447, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}, "source.nerd_facts_dbt.swapi.films": {"database": "nerd_facts", "schema": "raw", "name": "films", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.films", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "films"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_films", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars films", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_films\"", "created_at": 1742205059.548386, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}, "source.nerd_facts_dbt.swapi.people": {"database": "nerd_facts", "schema": "raw", "name": "people", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.people", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "people"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_people", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars characters", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_people\"", "created_at": 1742205059.5485187, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}, "source.nerd_facts_dbt.swapi.planets": {"database": "nerd_facts", "schema": "raw", "name": "planets", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.planets", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "planets"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_planets", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars planets", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_planets\"", "created_at": 1742205059.548638, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}, "source.nerd_facts_dbt.swapi.species": {"database": "nerd_facts", "schema": "raw", "name": "species", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.species", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "species"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_species", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars species", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_species\"", "created_at": 1742205059.5487487, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}, "source.nerd_facts_dbt.swapi.vehicles": {"database": "nerd_facts", "schema": "raw", "name": "vehicles", "resource_type": "source", "package_name": "nerd_facts_dbt", "path": "models/staging/swapi/swapi_sources.yml", "original_file_path": "models/staging/swapi/swapi_sources.yml", "unique_id": "source.nerd_facts_dbt.swapi.vehicles", "fqn": ["nerd_facts_dbt", "staging", "swapi", "swapi", "vehicles"], "source_name": "swapi", "source_description": "Star Wars API data source", "loader": "", "identifier": "swapi_vehicles", "quoting": {"database": null, "schema": null, "identifier": null, "column": null}, "loaded_at_field": null, "freshness": {"warn_after": {"count": null, "period": null}, "error_after": {"count": null, "period": null}, "filter": null}, "external": null, "description": "Raw data about Star Wars vehicles", "columns": {}, "meta": {}, "source_meta": {}, "tags": [], "config": {"enabled": true, "event_time": null}, "patch_path": null, "unrendered_config": {}, "relation_name": "\"nerd_facts\".\"raw\".\"swapi_vehicles\"", "created_at": 1742205059.548857, "unrendered_database": "nerd_facts", "unrendered_schema": "raw"}}, "macros": {"macro.dbt_postgres.postgres__create_table_as": {"name": "postgres__create_table_as", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__create_table_as", "macro_sql": "{% macro postgres__create_table_as(temporary, relation, sql) -%}\n  {%- set unlogged = config.get('unlogged', default=false) -%}\n  {%- set sql_header = config.get('sql_header', none) -%}\n\n  {{ sql_header if sql_header is not none }}\n\n  create {% if temporary -%}\n    temporary\n  {%- elif unlogged -%}\n    unlogged\n  {%- endif %} table {{ relation }}\n  {% set contract_config = config.get('contract') %}\n  {% if contract_config.enforced %}\n    {{ get_assert_columns_equivalent(sql) }}\n  {% endif -%}\n  {% if contract_config.enforced and (not temporary) -%}\n      {{ get_table_columns_and_constraints() }} ;\n    insert into {{ relation }} (\n      {{ adapter.dispatch('get_column_names', 'dbt')() }}\n    )\n    {%- set sql = get_select_subquery(sql) %}\n  {% else %}\n    as\n  {% endif %}\n  (\n    {{ sql }}\n  );\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_assert_columns_equivalent", "macro.dbt.get_table_columns_and_constraints", "macro.dbt.default__get_column_names", "macro.dbt.get_select_subquery"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8908784, "supported_languages": null}, "macro.dbt_postgres.postgres__get_create_index_sql": {"name": "postgres__get_create_index_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__get_create_index_sql", "macro_sql": "{% macro postgres__get_create_index_sql(relation, index_dict) -%}\n  {%- set index_config = adapter.parse_index(index_dict) -%}\n  {%- set comma_separated_columns = \", \".join(index_config.columns) -%}\n  {%- set index_name = index_config.render(relation) -%}\n\n  create {% if index_config.unique -%}\n    unique\n  {%- endif %} index if not exists\n  \"{{ index_name }}\"\n  on {{ relation }} {% if index_config.type -%}\n    using {{ index_config.type }}\n  {%- endif %}\n  ({{ comma_separated_columns }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8917935, "supported_languages": null}, "macro.dbt_postgres.postgres__create_schema": {"name": "postgres__create_schema", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__create_schema", "macro_sql": "{% macro postgres__create_schema(relation) -%}\n  {% if relation.database -%}\n    {{ adapter.verify_database(relation.database) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ relation.without_identifier().include(database=False) }}\n  {%- endcall -%}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8923624, "supported_languages": null}, "macro.dbt_postgres.postgres__drop_schema": {"name": "postgres__drop_schema", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__drop_schema", "macro_sql": "{% macro postgres__drop_schema(relation) -%}\n  {% if relation.database -%}\n    {{ adapter.verify_database(relation.database) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ relation.without_identifier().include(database=False) }} cascade\n  {%- endcall -%}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.892896, "supported_languages": null}, "macro.dbt_postgres.postgres__get_columns_in_relation": {"name": "postgres__get_columns_in_relation", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__get_columns_in_relation", "macro_sql": "{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.sql_convert_columns_in_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8938727, "supported_languages": null}, "macro.dbt_postgres.postgres__list_relations_without_caching": {"name": "postgres__list_relations_without_caching", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__list_relations_without_caching", "macro_sql": "{% macro postgres__list_relations_without_caching(schema_relation) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ schema_relation.database }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema_relation.schema }}'\n    union all\n    select\n      '{{ schema_relation.database }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema_relation.schema }}'\n    union all\n    select\n      '{{ schema_relation.database }}' as database,\n      matviewname as name,\n      schemaname as schema,\n      'materialized_view' as type\n    from pg_matviews\n    where schemaname ilike '{{ schema_relation.schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8946369, "supported_languages": null}, "macro.dbt_postgres.postgres__information_schema_name": {"name": "postgres__information_schema_name", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__information_schema_name", "macro_sql": "{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8949316, "supported_languages": null}, "macro.dbt_postgres.postgres__list_schemas": {"name": "postgres__list_schemas", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__list_schemas", "macro_sql": "{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8955064, "supported_languages": null}, "macro.dbt_postgres.postgres__check_schema_exists": {"name": "postgres__check_schema_exists", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__check_schema_exists", "macro_sql": "{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if information_schema.database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8961763, "supported_languages": null}, "macro.dbt_postgres.postgres__make_relation_with_suffix": {"name": "postgres__make_relation_with_suffix", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__make_relation_with_suffix", "macro_sql": "{% macro postgres__make_relation_with_suffix(base_relation, suffix, dstring) %}\n    {% if dstring %}\n      {% set dt = modules.datetime.datetime.now() %}\n      {% set dtstring = dt.strftime(\"%H%M%S%f\") %}\n      {% set suffix = suffix ~ dtstring %}\n    {% endif %}\n    {% set suffix_length = suffix|length %}\n    {% set relation_max_name_length = base_relation.relation_max_name_length() %}\n    {% if suffix_length > relation_max_name_length %}\n        {% do exceptions.raise_compiler_error('Relation suffix is too long (' ~ suffix_length ~ ' characters). Maximum length is ' ~ relation_max_name_length ~ ' characters.') %}\n    {% endif %}\n    {% set identifier = base_relation.identifier[:relation_max_name_length - suffix_length] ~ suffix %}\n\n    {{ return(base_relation.incorporate(path={\"identifier\": identifier })) }}\n\n  {% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.897588, "supported_languages": null}, "macro.dbt_postgres.postgres__make_intermediate_relation": {"name": "postgres__make_intermediate_relation", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__make_intermediate_relation", "macro_sql": "{% macro postgres__make_intermediate_relation(base_relation, suffix) %}\n    {{ return(postgres__make_relation_with_suffix(base_relation, suffix, dstring=False)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_relation_with_suffix"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.897861, "supported_languages": null}, "macro.dbt_postgres.postgres__make_temp_relation": {"name": "postgres__make_temp_relation", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__make_temp_relation", "macro_sql": "{% macro postgres__make_temp_relation(base_relation, suffix) %}\n    {% set temp_relation = postgres__make_relation_with_suffix(base_relation, suffix, dstring=True) %}\n    {{ return(temp_relation.incorporate(path={\"schema\": none,\n                                              \"database\": none})) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_relation_with_suffix"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.898282, "supported_languages": null}, "macro.dbt_postgres.postgres__make_backup_relation": {"name": "postgres__make_backup_relation", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__make_backup_relation", "macro_sql": "{% macro postgres__make_backup_relation(base_relation, backup_relation_type, suffix) %}\n    {% set backup_relation = postgres__make_relation_with_suffix(base_relation, suffix, dstring=False) %}\n    {{ return(backup_relation.incorporate(type=backup_relation_type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_relation_with_suffix"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.898634, "supported_languages": null}, "macro.dbt_postgres.postgres_escape_comment": {"name": "postgres_escape_comment", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres_escape_comment", "macro_sql": "{% macro postgres_escape_comment(comment) -%}\n  {% if comment is not string %}\n    {% do exceptions.raise_compiler_error('cannot escape a non-string: ' ~ comment) %}\n  {% endif %}\n  {%- set magic = '$dbt_comment_literal_block$' -%}\n  {%- if magic in comment -%}\n    {%- do exceptions.raise_compiler_error('The string ' ~ magic ~ ' is not allowed in comments.') -%}\n  {%- endif -%}\n  {{ magic }}{{ comment }}{{ magic }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8991961, "supported_languages": null}, "macro.dbt_postgres.postgres__alter_relation_comment": {"name": "postgres__alter_relation_comment", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__alter_relation_comment", "macro_sql": "{% macro postgres__alter_relation_comment(relation, comment) %}\n  {% set escaped_comment = postgres_escape_comment(comment) %}\n  {% if relation.type == 'materialized_view' -%}\n    {% set relation_type = \"materialized view\" %}\n  {%- else -%}\n    {%- set relation_type = relation.type -%}\n  {%- endif -%}\n  comment on {{ relation_type }} {{ relation }} is {{ escaped_comment }};\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres_escape_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.8998187, "supported_languages": null}, "macro.dbt_postgres.postgres__alter_column_comment": {"name": "postgres__alter_column_comment", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__alter_column_comment", "macro_sql": "{% macro postgres__alter_column_comment(relation, column_dict) %}\n  {% set existing_columns = adapter.get_columns_in_relation(relation) | map(attribute=\"name\") | list %}\n  {% for column_name in column_dict if (column_name in existing_columns) %}\n    {% set comment = column_dict[column_name]['description'] %}\n    {% set escaped_comment = postgres_escape_comment(comment) %}\n    comment on column {{ relation }}.{{ adapter.quote(column_name) if column_dict[column_name]['quote'] else column_name }} is {{ escaped_comment }};\n  {% endfor %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres_escape_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9008374, "supported_languages": null}, "macro.dbt_postgres.postgres__get_show_grant_sql": {"name": "postgres__get_show_grant_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__get_show_grant_sql", "macro_sql": "\n\n{%- macro postgres__get_show_grant_sql(relation) -%}\n  select grantee, privilege_type\n  from {{ relation.information_schema('role_table_grants') }}\n      where grantor = current_role\n        and grantee != current_role\n        and table_schema = '{{ relation.schema }}'\n        and table_name = '{{ relation.identifier }}'\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9012227, "supported_languages": null}, "macro.dbt_postgres.postgres__copy_grants": {"name": "postgres__copy_grants", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__copy_grants", "macro_sql": "{% macro postgres__copy_grants() %}\n    {{ return(False) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9015303, "supported_languages": null}, "macro.dbt_postgres.postgres__get_show_indexes_sql": {"name": "postgres__get_show_indexes_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__get_show_indexes_sql", "macro_sql": "{% macro postgres__get_show_indexes_sql(relation) %}\n    select\n        i.relname                                   as name,\n        m.amname                                    as method,\n        ix.indisunique                              as \"unique\",\n        array_to_string(array_agg(a.attname), ',')  as column_names\n    from pg_index ix\n    join pg_class i\n        on i.oid = ix.indexrelid\n    join pg_am m\n        on m.oid=i.relam\n    join pg_class t\n        on t.oid = ix.indrelid\n    join pg_namespace n\n        on n.oid = t.relnamespace\n    join pg_attribute a\n        on a.attrelid = t.oid\n        and a.attnum = ANY(ix.indkey)\n    where t.relname = '{{ relation.identifier }}'\n      and n.nspname = '{{ relation.schema }}'\n      and t.relkind in ('r', 'm')\n    group by 1, 2, 3\n    order by 1, 2, 3\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9018767, "supported_languages": null}, "macro.dbt_postgres.postgres__get_drop_index_sql": {"name": "postgres__get_drop_index_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "unique_id": "macro.dbt_postgres.postgres__get_drop_index_sql", "macro_sql": "\n\n\n{%- macro postgres__get_drop_index_sql(relation, index_name) -%}\n    drop index if exists \"{{ relation.schema }}\".\"{{ index_name }}\"\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9021175, "supported_languages": null}, "macro.dbt_postgres.postgres__get_catalog_relations": {"name": "postgres__get_catalog_relations", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/catalog.sql", "original_file_path": "macros/catalog.sql", "unique_id": "macro.dbt_postgres.postgres__get_catalog_relations", "macro_sql": "{% macro postgres__get_catalog_relations(information_schema, relations) -%}\n  {%- call statement('catalog', fetch_result=True) -%}\n\n    {#\n      If the user has multiple databases set and the first one is wrong, this will fail.\n      But we won't fail in the case where there are multiple quoting-difference-only dbs, which is better.\n    #}\n    {% set database = information_schema.database %}\n    {{ adapter.verify_database(database) }}\n\n    select\n        '{{ database }}' as table_database,\n        sch.nspname as table_schema,\n        tbl.relname as table_name,\n        case tbl.relkind\n            when 'v' then 'VIEW'\n            when 'm' then 'MATERIALIZED VIEW'\n            else 'BASE TABLE'\n        end as table_type,\n        tbl_desc.description as table_comment,\n        col.attname as column_name,\n        col.attnum as column_index,\n        pg_catalog.format_type(col.atttypid, col.atttypmod) as column_type,\n        col_desc.description as column_comment,\n        pg_get_userbyid(tbl.relowner) as table_owner\n\n    from pg_catalog.pg_namespace sch\n    join pg_catalog.pg_class tbl on tbl.relnamespace = sch.oid\n    join pg_catalog.pg_attribute col on col.attrelid = tbl.oid\n    left outer join pg_catalog.pg_description tbl_desc on (tbl_desc.objoid = tbl.oid and tbl_desc.objsubid = 0)\n    left outer join pg_catalog.pg_description col_desc on (col_desc.objoid = tbl.oid and col_desc.objsubid = col.attnum)\n    where (\n      {%- for relation in relations -%}\n        {%- if relation.identifier -%}\n          (upper(sch.nspname) = upper('{{ relation.schema }}') and\n           upper(tbl.relname) = upper('{{ relation.identifier }}'))\n        {%- else-%}\n          upper(sch.nspname) = upper('{{ relation.schema }}')\n        {%- endif -%}\n        {%- if not loop.last %} or {% endif -%}\n      {%- endfor -%}\n    )\n      and not pg_is_other_temp_schema(sch.oid) -- not a temporary schema belonging to another session\n      and tbl.relpersistence in ('p', 'u') -- [p]ermanent table or [u]nlogged table. Exclude [t]emporary tables\n      and tbl.relkind in ('r', 'v', 'f', 'p', 'm') -- o[r]dinary table, [v]iew, [f]oreign table, [p]artitioned table, [m]aterialized view. Other values are [i]ndex, [S]equence, [c]omposite type, [t]OAST table\n      and col.attnum > 0 -- negative numbers are used for system columns such as oid\n      and not col.attisdropped -- column as not been dropped\n\n    order by\n        sch.nspname,\n        tbl.relname,\n        col.attnum\n\n  {%- endcall -%}\n\n  {{ return(load_result('catalog').table) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.903692, "supported_languages": null}, "macro.dbt_postgres.postgres__get_catalog": {"name": "postgres__get_catalog", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/catalog.sql", "original_file_path": "macros/catalog.sql", "unique_id": "macro.dbt_postgres.postgres__get_catalog", "macro_sql": "{% macro postgres__get_catalog(information_schema, schemas) -%}\n  {%- set relations = [] -%}\n  {%- for schema in schemas -%}\n    {%- set dummy = relations.append({'schema': schema}) -%}\n  {%- endfor -%}\n  {{ return(postgres__get_catalog_relations(information_schema, relations)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_catalog_relations"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.904323, "supported_languages": null}, "macro.dbt_postgres.postgres__current_timestamp": {"name": "postgres__current_timestamp", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/timestamps.sql", "original_file_path": "macros/timestamps.sql", "unique_id": "macro.dbt_postgres.postgres__current_timestamp", "macro_sql": "{% macro postgres__current_timestamp() -%}\n    now()\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9046912, "supported_languages": null}, "macro.dbt_postgres.postgres__snapshot_string_as_time": {"name": "postgres__snapshot_string_as_time", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/timestamps.sql", "original_file_path": "macros/timestamps.sql", "unique_id": "macro.dbt_postgres.postgres__snapshot_string_as_time", "macro_sql": "{% macro postgres__snapshot_string_as_time(timestamp) -%}\n    {%- set result = \"'\" ~ timestamp ~ \"'::timestamp without time zone\" -%}\n    {{ return(result) }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9049945, "supported_languages": null}, "macro.dbt_postgres.postgres__snapshot_get_time": {"name": "postgres__snapshot_get_time", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/timestamps.sql", "original_file_path": "macros/timestamps.sql", "unique_id": "macro.dbt_postgres.postgres__snapshot_get_time", "macro_sql": "{% macro postgres__snapshot_get_time() -%}\n  {{ current_timestamp() }}::timestamp without time zone\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9051738, "supported_languages": null}, "macro.dbt_postgres.postgres__current_timestamp_backcompat": {"name": "postgres__current_timestamp_backcompat", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/timestamps.sql", "original_file_path": "macros/timestamps.sql", "unique_id": "macro.dbt_postgres.postgres__current_timestamp_backcompat", "macro_sql": "{% macro postgres__current_timestamp_backcompat() %}\n    current_timestamp::{{ type_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.905379, "supported_languages": null}, "macro.dbt_postgres.postgres__current_timestamp_in_utc_backcompat": {"name": "postgres__current_timestamp_in_utc_backcompat", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/timestamps.sql", "original_file_path": "macros/timestamps.sql", "unique_id": "macro.dbt_postgres.postgres__current_timestamp_in_utc_backcompat", "macro_sql": "{% macro postgres__current_timestamp_in_utc_backcompat() %}\n    (current_timestamp at time zone 'utc')::{{ type_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9057345, "supported_languages": null}, "macro.dbt_postgres.postgres__get_relations": {"name": "postgres__get_relations", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations.sql", "original_file_path": "macros/relations.sql", "unique_id": "macro.dbt_postgres.postgres__get_relations", "macro_sql": "{% macro postgres__get_relations() -%}\n\n  {#\n      -- in pg_depend, objid is the dependent, refobjid is the referenced object\n      --  > a pg_depend entry indicates that the referenced object cannot be\n      --  > dropped without also dropping the dependent object.\n  #}\n\n  {%- call statement('relations', fetch_result=True) -%}\n    with relation as (\n        select\n            pg_rewrite.ev_class as class,\n            pg_rewrite.oid as id\n        from pg_rewrite\n    ),\n    class as (\n        select\n            oid as id,\n            relname as name,\n            relnamespace as schema,\n            relkind as kind\n        from pg_class\n    ),\n    dependency as (\n        select distinct\n            pg_depend.objid as id,\n            pg_depend.refobjid as ref\n        from pg_depend\n    ),\n    schema as (\n        select\n            pg_namespace.oid as id,\n            pg_namespace.nspname as name\n        from pg_namespace\n        where nspname != 'information_schema' and nspname not like 'pg\\_%'\n    ),\n    referenced as (\n        select\n            relation.id AS id,\n            referenced_class.name ,\n            referenced_class.schema ,\n            referenced_class.kind\n        from relation\n        join class as referenced_class on relation.class=referenced_class.id\n        where referenced_class.kind in ('r', 'v', 'm')\n    ),\n    relationships as (\n        select\n            referenced.name as referenced_name,\n            referenced.schema as referenced_schema_id,\n            dependent_class.name as dependent_name,\n            dependent_class.schema as dependent_schema_id,\n            referenced.kind as kind\n        from referenced\n        join dependency on referenced.id=dependency.id\n        join class as dependent_class on dependency.ref=dependent_class.id\n        where\n            (referenced.name != dependent_class.name or\n             referenced.schema != dependent_class.schema)\n    )\n\n    select\n        referenced_schema.name as referenced_schema,\n        relationships.referenced_name as referenced_name,\n        dependent_schema.name as dependent_schema,\n        relationships.dependent_name as dependent_name\n    from relationships\n    join schema as dependent_schema on relationships.dependent_schema_id=dependent_schema.id\n    join schema as referenced_schema on relationships.referenced_schema_id=referenced_schema.id\n    group by referenced_schema, referenced_name, dependent_schema, dependent_name\n    order by referenced_schema, referenced_name, dependent_schema, dependent_name;\n\n  {%- endcall -%}\n\n  {{ return(load_result('relations').table) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.90645, "supported_languages": null}, "macro.dbt_postgres.postgres_get_relations": {"name": "postgres_get_relations", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations.sql", "original_file_path": "macros/relations.sql", "unique_id": "macro.dbt_postgres.postgres_get_relations", "macro_sql": "{% macro postgres_get_relations() %}\n  {{ return(postgres__get_relations()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_relations"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9066179, "supported_languages": null}, "macro.dbt_postgres.postgres__get_incremental_default_sql": {"name": "postgres__get_incremental_default_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/materializations/incremental_strategies.sql", "original_file_path": "macros/materializations/incremental_strategies.sql", "unique_id": "macro.dbt_postgres.postgres__get_incremental_default_sql", "macro_sql": "{% macro postgres__get_incremental_default_sql(arg_dict) %}\n\n  {% if arg_dict[\"unique_key\"] %}\n    {% do return(get_incremental_delete_insert_sql(arg_dict)) %}\n  {% else %}\n    {% do return(get_incremental_append_sql(arg_dict)) %}\n  {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_incremental_delete_insert_sql", "macro.dbt.get_incremental_append_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9071882, "supported_languages": null}, "macro.dbt_postgres.postgres__get_incremental_microbatch_sql": {"name": "postgres__get_incremental_microbatch_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/materializations/incremental_strategies.sql", "original_file_path": "macros/materializations/incremental_strategies.sql", "unique_id": "macro.dbt_postgres.postgres__get_incremental_microbatch_sql", "macro_sql": "{% macro postgres__get_incremental_microbatch_sql(arg_dict) %}\n\n  {% if arg_dict[\"unique_key\"] %}\n    {% do return(adapter.dispatch('get_incremental_merge_sql', 'dbt')(arg_dict)) %}\n  {% else %}\n    {{ exceptions.raise_compiler_error(\"dbt-postgres 'microbatch' requires a `unique_key` config\") }}\n  {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_incremental_merge_sql", "macro.dbt.default__get_incremental_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.907686, "supported_languages": null}, "macro.dbt_postgres.postgres__snapshot_merge_sql": {"name": "postgres__snapshot_merge_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/materializations/snapshot_merge.sql", "original_file_path": "macros/materializations/snapshot_merge.sql", "unique_id": "macro.dbt_postgres.postgres__snapshot_merge_sql", "macro_sql": "{% macro postgres__snapshot_merge_sql(target, source, insert_cols) -%}\n    {%- set insert_cols_csv = insert_cols | join(', ') -%}\n\n    {%- set columns = config.get(\"snapshot_table_column_names\") or get_snapshot_table_column_names() -%}\n\n    update {{ target }}\n    set {{ columns.dbt_valid_to }} = DBT_INTERNAL_SOURCE.{{ columns.dbt_valid_to }}\n    from {{ source }} as DBT_INTERNAL_SOURCE\n    where DBT_INTERNAL_SOURCE.{{ columns.dbt_scd_id }}::text = {{ target }}.{{ columns.dbt_scd_id }}::text\n      and DBT_INTERNAL_SOURCE.dbt_change_type::text in ('update'::text, 'delete'::text)\n      {% if config.get(\"dbt_valid_to_current\") %}\n        and ({{ target }}.{{ columns.dbt_valid_to }} = {{ config.get('dbt_valid_to_current') }} or {{ target }}.{{ columns.dbt_valid_to }} is null);\n      {% else %}\n        and {{ target }}.{{ columns.dbt_valid_to }} is null;\n      {% endif %}\n\n\n    insert into {{ target }} ({{ insert_cols_csv }})\n    select {% for column in insert_cols -%}\n        DBT_INTERNAL_SOURCE.{{ column }} {%- if not loop.last %}, {%- endif %}\n    {%- endfor %}\n    from {{ source }} as DBT_INTERNAL_SOURCE\n    where DBT_INTERNAL_SOURCE.dbt_change_type::text = 'insert'::text;\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_snapshot_table_column_names"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9096375, "supported_languages": null}, "macro.dbt_postgres.postgres__get_replace_table_sql": {"name": "postgres__get_replace_table_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/table/replace.sql", "original_file_path": "macros/relations/table/replace.sql", "unique_id": "macro.dbt_postgres.postgres__get_replace_table_sql", "macro_sql": "{% macro postgres__get_replace_table_sql(relation, sql) -%}\n\n    {%- set sql_header = config.get('sql_header', none) -%}\n    {{ sql_header if sql_header is not none }}\n\n    create or replace table {{ relation }}\n        {% set contract_config = config.get('contract') %}\n        {% if contract_config.enforced %}\n            {{ get_assert_columns_equivalent(sql) }}\n            {{ get_table_columns_and_constraints() }}\n            {%- set sql = get_select_subquery(sql) %}\n        {% endif %}\n    as (\n        {{ sql }}\n    );\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_assert_columns_equivalent", "macro.dbt.get_table_columns_and_constraints", "macro.dbt.get_select_subquery"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9105086, "supported_languages": null}, "macro.dbt_postgres.postgres__drop_table": {"name": "postgres__drop_table", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/table/drop.sql", "original_file_path": "macros/relations/table/drop.sql", "unique_id": "macro.dbt_postgres.postgres__drop_table", "macro_sql": "{% macro postgres__drop_table(relation) -%}\n    drop table if exists {{ relation }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.91071, "supported_languages": null}, "macro.dbt_postgres.postgres__get_rename_table_sql": {"name": "postgres__get_rename_table_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/table/rename.sql", "original_file_path": "macros/relations/table/rename.sql", "unique_id": "macro.dbt_postgres.postgres__get_rename_table_sql", "macro_sql": "{% macro postgres__get_rename_table_sql(relation, new_name) %}\n    alter table {{ relation }} rename to {{ new_name }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9109647, "supported_languages": null}, "macro.dbt_postgres.postgres__get_alter_materialized_view_as_sql": {"name": "postgres__get_alter_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt_postgres.postgres__get_alter_materialized_view_as_sql", "macro_sql": "{% macro postgres__get_alter_materialized_view_as_sql(\n    relation,\n    configuration_changes,\n    sql,\n    existing_relation,\n    backup_relation,\n    intermediate_relation\n) %}\n\n    -- apply a full refresh immediately if needed\n    {% if configuration_changes.requires_full_refresh %}\n\n        {{ get_replace_sql(existing_relation, relation, sql) }}\n\n    -- otherwise apply individual changes as needed\n    {% else %}\n\n        {{ postgres__update_indexes_on_materialized_view(relation, configuration_changes.indexes) }}\n\n    {%- endif -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_replace_sql", "macro.dbt_postgres.postgres__update_indexes_on_materialized_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9119115, "supported_languages": null}, "macro.dbt_postgres.postgres__update_indexes_on_materialized_view": {"name": "postgres__update_indexes_on_materialized_view", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt_postgres.postgres__update_indexes_on_materialized_view", "macro_sql": "\n\n\n{%- macro postgres__update_indexes_on_materialized_view(relation, index_changes) -%}\n    {{- log(\"Applying UPDATE INDEXES to: \" ~ relation) -}}\n\n    {%- for _index_change in index_changes -%}\n        {%- set _index = _index_change.context -%}\n\n        {%- if _index_change.action == \"drop\" -%}\n\n            {{ postgres__get_drop_index_sql(relation, _index.name) }}\n\n        {%- elif _index_change.action == \"create\" -%}\n\n            {{ postgres__get_create_index_sql(relation, _index.as_node_config) }}\n\n        {%- endif -%}\n\t{{ ';' if not loop.last else \"\" }}\n\n    {%- endfor -%}\n\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_drop_index_sql", "macro.dbt_postgres.postgres__get_create_index_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9128318, "supported_languages": null}, "macro.dbt_postgres.postgres__get_materialized_view_configuration_changes": {"name": "postgres__get_materialized_view_configuration_changes", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt_postgres.postgres__get_materialized_view_configuration_changes", "macro_sql": "{% macro postgres__get_materialized_view_configuration_changes(existing_relation, new_config) %}\n    {% set _existing_materialized_view = postgres__describe_materialized_view(existing_relation) %}\n    {% set _configuration_changes = existing_relation.get_materialized_view_config_change_collection(_existing_materialized_view, new_config.model) %}\n    {% do return(_configuration_changes) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__describe_materialized_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9133291, "supported_languages": null}, "macro.dbt_postgres.postgres__describe_materialized_view": {"name": "postgres__describe_materialized_view", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/describe.sql", "original_file_path": "macros/relations/materialized_view/describe.sql", "unique_id": "macro.dbt_postgres.postgres__describe_materialized_view", "macro_sql": "{% macro postgres__describe_materialized_view(relation) %}\n    -- for now just get the indexes, we don't need the name or the query yet\n    {% set _indexes = run_query(get_show_indexes_sql(relation)) %}\n    {% do return({'indexes': _indexes}) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_query", "macro.dbt.get_show_indexes_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9137952, "supported_languages": null}, "macro.dbt_postgres.postgres__refresh_materialized_view": {"name": "postgres__refresh_materialized_view", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/refresh.sql", "original_file_path": "macros/relations/materialized_view/refresh.sql", "unique_id": "macro.dbt_postgres.postgres__refresh_materialized_view", "macro_sql": "{% macro postgres__refresh_materialized_view(relation) %}\n    refresh materialized view {{ relation }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9139955, "supported_languages": null}, "macro.dbt_postgres.postgres__drop_materialized_view": {"name": "postgres__drop_materialized_view", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/drop.sql", "original_file_path": "macros/relations/materialized_view/drop.sql", "unique_id": "macro.dbt_postgres.postgres__drop_materialized_view", "macro_sql": "{% macro postgres__drop_materialized_view(relation) -%}\n    drop materialized view if exists {{ relation }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9141867, "supported_languages": null}, "macro.dbt_postgres.postgres__get_rename_materialized_view_sql": {"name": "postgres__get_rename_materialized_view_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/rename.sql", "original_file_path": "macros/relations/materialized_view/rename.sql", "unique_id": "macro.dbt_postgres.postgres__get_rename_materialized_view_sql", "macro_sql": "{% macro postgres__get_rename_materialized_view_sql(relation, new_name) %}\n    alter materialized view {{ relation }} rename to {{ new_name }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9144166, "supported_languages": null}, "macro.dbt_postgres.postgres__get_create_materialized_view_as_sql": {"name": "postgres__get_create_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/materialized_view/create.sql", "original_file_path": "macros/relations/materialized_view/create.sql", "unique_id": "macro.dbt_postgres.postgres__get_create_materialized_view_as_sql", "macro_sql": "{% macro postgres__get_create_materialized_view_as_sql(relation, sql) %}\n    create materialized view if not exists {{ relation }} as {{ sql }};\n\n    {% for _index_dict in config.get('indexes', []) -%}\n        {{- get_create_index_sql(relation, _index_dict) -}}{{ ';' if not loop.last else \"\" }}\n    {%- endfor -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_create_index_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9149668, "supported_languages": null}, "macro.dbt_postgres.postgres__get_replace_view_sql": {"name": "postgres__get_replace_view_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt_postgres.postgres__get_replace_view_sql", "macro_sql": "{% macro postgres__get_replace_view_sql(relation, sql) -%}\n\n    {%- set sql_header = config.get('sql_header', none) -%}\n    {{ sql_header if sql_header is not none }}\n\n    create or replace view {{ relation }}\n        {% set contract_config = config.get('contract') %}\n        {% if contract_config.enforced %}\n            {{ get_assert_columns_equivalent(sql) }}\n        {%- endif %}\n    as (\n        {{ sql }}\n    );\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_assert_columns_equivalent"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.915693, "supported_languages": null}, "macro.dbt_postgres.postgres__drop_view": {"name": "postgres__drop_view", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/view/drop.sql", "original_file_path": "macros/relations/view/drop.sql", "unique_id": "macro.dbt_postgres.postgres__drop_view", "macro_sql": "{% macro postgres__drop_view(relation) -%}\n    drop view if exists {{ relation }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.915928, "supported_languages": null}, "macro.dbt_postgres.postgres__get_rename_view_sql": {"name": "postgres__get_rename_view_sql", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/relations/view/rename.sql", "original_file_path": "macros/relations/view/rename.sql", "unique_id": "macro.dbt_postgres.postgres__get_rename_view_sql", "macro_sql": "{% macro postgres__get_rename_view_sql(relation, new_name) %}\n    alter view {{ relation }} rename to {{ new_name }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9162047, "supported_languages": null}, "macro.dbt_postgres.postgres__split_part": {"name": "postgres__split_part", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/split_part.sql", "original_file_path": "macros/utils/split_part.sql", "unique_id": "macro.dbt_postgres.postgres__split_part", "macro_sql": "{% macro postgres__split_part(string_text, delimiter_text, part_number) %}\n\n  {% if part_number >= 0 %}\n    {{ dbt.default__split_part(string_text, delimiter_text, part_number) }}\n  {% else %}\n    {{ dbt._split_part_negative(string_text, delimiter_text, part_number) }}\n  {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__split_part", "macro.dbt._split_part_negative"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9169738, "supported_languages": null}, "macro.dbt_postgres.postgres__any_value": {"name": "postgres__any_value", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/any_value.sql", "original_file_path": "macros/utils/any_value.sql", "unique_id": "macro.dbt_postgres.postgres__any_value", "macro_sql": "{% macro postgres__any_value(expression) -%}\n\n    min({{ expression }})\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9172335, "supported_languages": null}, "macro.dbt_postgres.postgres__datediff": {"name": "postgres__datediff", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/datediff.sql", "original_file_path": "macros/utils/datediff.sql", "unique_id": "macro.dbt_postgres.postgres__datediff", "macro_sql": "{% macro postgres__datediff(first_date, second_date, datepart) -%}\n\n    {% if datepart == 'year' %}\n        (date_part('year', ({{second_date}})::date) - date_part('year', ({{first_date}})::date))\n    {% elif datepart == 'quarter' %}\n        ({{ datediff(first_date, second_date, 'year') }} * 4 + date_part('quarter', ({{second_date}})::date) - date_part('quarter', ({{first_date}})::date))\n    {% elif datepart == 'month' %}\n        ({{ datediff(first_date, second_date, 'year') }} * 12 + date_part('month', ({{second_date}})::date) - date_part('month', ({{first_date}})::date))\n    {% elif datepart == 'day' %}\n        (({{second_date}})::date - ({{first_date}})::date)\n    {% elif datepart == 'week' %}\n        ({{ datediff(first_date, second_date, 'day') }} / 7 + case\n            when date_part('dow', ({{first_date}})::timestamp) <= date_part('dow', ({{second_date}})::timestamp) then\n                case when {{first_date}} <= {{second_date}} then 0 else -1 end\n            else\n                case when {{first_date}} <= {{second_date}} then 1 else 0 end\n        end)\n    {% elif datepart == 'hour' %}\n        ({{ datediff(first_date, second_date, 'day') }} * 24 + date_part('hour', ({{second_date}})::timestamp) - date_part('hour', ({{first_date}})::timestamp))\n    {% elif datepart == 'minute' %}\n        ({{ datediff(first_date, second_date, 'hour') }} * 60 + date_part('minute', ({{second_date}})::timestamp) - date_part('minute', ({{first_date}})::timestamp))\n    {% elif datepart == 'second' %}\n        ({{ datediff(first_date, second_date, 'minute') }} * 60 + floor(date_part('second', ({{second_date}})::timestamp)) - floor(date_part('second', ({{first_date}})::timestamp)))\n    {% elif datepart == 'millisecond' %}\n        ({{ datediff(first_date, second_date, 'minute') }} * 60000 + floor(date_part('millisecond', ({{second_date}})::timestamp)) - floor(date_part('millisecond', ({{first_date}})::timestamp)))\n    {% elif datepart == 'microsecond' %}\n        ({{ datediff(first_date, second_date, 'minute') }} * 60000000 + floor(date_part('microsecond', ({{second_date}})::timestamp)) - floor(date_part('microsecond', ({{first_date}})::timestamp)))\n    {% else %}\n        {{ exceptions.raise_compiler_error(\"Unsupported datepart for macro datediff in postgres: {!r}\".format(datepart)) }}\n    {% endif %}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9200866, "supported_languages": null}, "macro.dbt_postgres.postgres__dateadd": {"name": "postgres__dateadd", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/dateadd.sql", "original_file_path": "macros/utils/dateadd.sql", "unique_id": "macro.dbt_postgres.postgres__dateadd", "macro_sql": "{% macro postgres__dateadd(datepart, interval, from_date_or_timestamp) %}\n\n    {{ from_date_or_timestamp }} + ((interval '1 {{ datepart }}') * ({{ interval }}))\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9205184, "supported_languages": null}, "macro.dbt_postgres.postgres__listagg": {"name": "postgres__listagg", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/listagg.sql", "original_file_path": "macros/utils/listagg.sql", "unique_id": "macro.dbt_postgres.postgres__listagg", "macro_sql": "{% macro postgres__listagg(measure, delimiter_text, order_by_clause, limit_num) -%}\n\n    {% if limit_num -%}\n    array_to_string(\n        (array_agg(\n            {{ measure }}\n            {% if order_by_clause -%}\n            {{ order_by_clause }}\n            {%- endif %}\n        ))[1:{{ limit_num }}],\n        {{ delimiter_text }}\n        )\n    {%- else %}\n    string_agg(\n        {{ measure }},\n        {{ delimiter_text }}\n        {% if order_by_clause -%}\n        {{ order_by_clause }}\n        {%- endif %}\n        )\n    {%- endif %}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9213884, "supported_languages": null}, "macro.dbt_postgres.postgres__last_day": {"name": "postgres__last_day", "resource_type": "macro", "package_name": "dbt_postgres", "path": "macros/utils/last_day.sql", "original_file_path": "macros/utils/last_day.sql", "unique_id": "macro.dbt_postgres.postgres__last_day", "macro_sql": "{% macro postgres__last_day(date, datepart) -%}\n\n    {%- if datepart == 'quarter' -%}\n    -- postgres dateadd does not support quarter interval.\n    cast(\n        {{dbt.dateadd('day', '-1',\n        dbt.dateadd('month', '3', dbt.date_trunc(datepart, date))\n        )}}\n        as date)\n    {%- else -%}\n    {{dbt.default_last_day(date, datepart)}}\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.dateadd", "macro.dbt.date_trunc", "macro.dbt.default_last_day"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9220583, "supported_languages": null}, "macro.dbt.default__test_unique": {"name": "default__test_unique", "resource_type": "macro", "package_name": "dbt", "path": "macros/generic_test_sql/unique.sql", "original_file_path": "macros/generic_test_sql/unique.sql", "unique_id": "macro.dbt.default__test_unique", "macro_sql": "{% macro default__test_unique(model, column_name) %}\n\nselect\n    {{ column_name }} as unique_field,\n    count(*) as n_records\n\nfrom {{ model }}\nwhere {{ column_name }} is not null\ngroup by {{ column_name }}\nhaving count(*) > 1\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9223695, "supported_languages": null}, "macro.dbt.default__test_accepted_values": {"name": "default__test_accepted_values", "resource_type": "macro", "package_name": "dbt", "path": "macros/generic_test_sql/accepted_values.sql", "original_file_path": "macros/generic_test_sql/accepted_values.sql", "unique_id": "macro.dbt.default__test_accepted_values", "macro_sql": "{% macro default__test_accepted_values(model, column_name, values, quote=True) %}\n\nwith all_values as (\n\n    select\n        {{ column_name }} as value_field,\n        count(*) as n_records\n\n    from {{ model }}\n    group by {{ column_name }}\n\n)\n\nselect *\nfrom all_values\nwhere value_field not in (\n    {% for value in values -%}\n        {% if quote -%}\n        '{{ value }}'\n        {%- else -%}\n        {{ value }}\n        {%- endif -%}\n        {%- if not loop.last -%},{%- endif %}\n    {%- endfor %}\n)\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.923047, "supported_languages": null}, "macro.dbt.default__test_relationships": {"name": "default__test_relationships", "resource_type": "macro", "package_name": "dbt", "path": "macros/generic_test_sql/relationships.sql", "original_file_path": "macros/generic_test_sql/relationships.sql", "unique_id": "macro.dbt.default__test_relationships", "macro_sql": "{% macro default__test_relationships(model, column_name, to, field) %}\n\nwith child as (\n    select {{ column_name }} as from_field\n    from {{ model }}\n    where {{ column_name }} is not null\n),\n\nparent as (\n    select {{ field }} as to_field\n    from {{ to }}\n)\n\nselect\n    from_field\n\nfrom child\nleft join parent\n    on child.from_field = parent.to_field\n\nwhere parent.to_field is null\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.923581, "supported_languages": null}, "macro.dbt.default__test_not_null": {"name": "default__test_not_null", "resource_type": "macro", "package_name": "dbt", "path": "macros/generic_test_sql/not_null.sql", "original_file_path": "macros/generic_test_sql/not_null.sql", "unique_id": "macro.dbt.default__test_not_null", "macro_sql": "{% macro default__test_not_null(model, column_name) %}\n\n{% set column_list = '*' if should_store_failures() else column_name %}\n\nselect {{ column_list }}\nfrom {{ model }}\nwhere {{ column_name }} is null\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.should_store_failures"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9241853, "supported_languages": null}, "macro.dbt.set_sql_header": {"name": "set_sql_header", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/configs.sql", "original_file_path": "macros/materializations/configs.sql", "unique_id": "macro.dbt.set_sql_header", "macro_sql": "{% macro set_sql_header(config) -%}\n  {{ config.set('sql_header', caller()) }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.924763, "supported_languages": null}, "macro.dbt.should_full_refresh": {"name": "should_full_refresh", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/configs.sql", "original_file_path": "macros/materializations/configs.sql", "unique_id": "macro.dbt.should_full_refresh", "macro_sql": "{% macro should_full_refresh() %}\n  {% set config_full_refresh = config.get('full_refresh') %}\n  {% if config_full_refresh is none %}\n    {% set config_full_refresh = flags.FULL_REFRESH %}\n  {% endif %}\n  {% do return(config_full_refresh) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.925496, "supported_languages": null}, "macro.dbt.should_store_failures": {"name": "should_store_failures", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/configs.sql", "original_file_path": "macros/materializations/configs.sql", "unique_id": "macro.dbt.should_store_failures", "macro_sql": "{% macro should_store_failures() %}\n  {% set config_store_failures = config.get('store_failures') %}\n  {% if config_store_failures is none %}\n    {% set config_store_failures = flags.STORE_FAILURES %}\n  {% endif %}\n  {% do return(config_store_failures) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.926122, "supported_languages": null}, "macro.dbt.run_hooks": {"name": "run_hooks", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/hooks.sql", "original_file_path": "macros/materializations/hooks.sql", "unique_id": "macro.dbt.run_hooks", "macro_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% set rendered = render(hook.get('sql')) | trim %}\n    {% if (rendered | length) > 0 %}\n      {% call statement(auto_begin=inside_transaction) %}\n        {{ rendered }}\n      {% endcall %}\n    {% endif %}\n  {% endfor %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.927857, "supported_languages": null}, "macro.dbt.make_hook_config": {"name": "make_hook_config", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/hooks.sql", "original_file_path": "macros/materializations/hooks.sql", "unique_id": "macro.dbt.make_hook_config", "macro_sql": "{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9283576, "supported_languages": null}, "macro.dbt.before_begin": {"name": "before_begin", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/hooks.sql", "original_file_path": "macros/materializations/hooks.sql", "unique_id": "macro.dbt.before_begin", "macro_sql": "{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.make_hook_config"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9287066, "supported_languages": null}, "macro.dbt.in_transaction": {"name": "in_transaction", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/hooks.sql", "original_file_path": "macros/materializations/hooks.sql", "unique_id": "macro.dbt.in_transaction", "macro_sql": "{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.make_hook_config"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9290287, "supported_languages": null}, "macro.dbt.after_commit": {"name": "after_commit", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/hooks.sql", "original_file_path": "macros/materializations/hooks.sql", "unique_id": "macro.dbt.after_commit", "macro_sql": "{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.make_hook_config"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9293504, "supported_languages": null}, "macro.dbt.materialization_view_default": {"name": "materialization_view_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/view.sql", "original_file_path": "macros/materializations/models/view.sql", "unique_id": "macro.dbt.materialization_view_default", "macro_sql": "{%- materialization view, default -%}\n\n  {%- set existing_relation = load_cached_relation(this) -%}\n  {%- set target_relation = this.incorporate(type='view') -%}\n  {%- set intermediate_relation =  make_intermediate_relation(target_relation) -%}\n\n  -- the intermediate_relation should not already exist in the database; get_relation\n  -- will return None in that case. Otherwise, we get a relation that we can drop\n  -- later, before we try to use this name for the current operation\n  {%- set preexisting_intermediate_relation = load_cached_relation(intermediate_relation) -%}\n  /*\n     This relation (probably) doesn't exist yet. If it does exist, it's a leftover from\n     a previous run, and we're going to try to drop it immediately. At the end of this\n     materialization, we're going to rename the \"existing_relation\" to this identifier,\n     and then we're going to drop it. In order to make sure we run the correct one of:\n       - drop view ...\n       - drop table ...\n\n     We need to set the type of this relation to be the type of the existing_relation, if it exists,\n     or else \"view\" as a sane default if it does not. Note that if the existing_relation does not\n     exist, then there is nothing to move out of the way and subsequentally drop. In that case,\n     this relation will be effectively unused.\n  */\n  {%- set backup_relation_type = 'view' if existing_relation is none else existing_relation.type -%}\n  {%- set backup_relation = make_backup_relation(target_relation, backup_relation_type) -%}\n  -- as above, the backup_relation should not already exist\n  {%- set preexisting_backup_relation = load_cached_relation(backup_relation) -%}\n  -- grab current tables grants config for comparision later on\n  {% set grant_config = config.get('grants') %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- drop the temp relations if they exist already in the database\n  {{ drop_relation_if_exists(preexisting_intermediate_relation) }}\n  {{ drop_relation_if_exists(preexisting_backup_relation) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% call statement('main') -%}\n    {{ get_create_view_as_sql(intermediate_relation, sql) }}\n  {%- endcall %}\n\n  -- cleanup\n  -- move the existing view out of the way\n  {% if existing_relation is not none %}\n     /* Do the equivalent of rename_if_exists. 'existing_relation' could have been dropped\n        since the variable was first set. */\n    {% set existing_relation = load_cached_relation(existing_relation) %}\n    {% if existing_relation is not none %}\n        {{ adapter.rename_relation(existing_relation, backup_relation) }}\n    {% endif %}\n  {% endif %}\n  {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n\n  {% set should_revoke = should_revoke(existing_relation, full_refresh_mode=True) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {% do persist_docs(target_relation, model) %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {{ adapter.commit() }}\n\n  {{ drop_relation_if_exists(backup_relation) }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n  {{ return({'relations': [target_relation]}) }}\n\n{%- endmaterialization -%}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.make_intermediate_relation", "macro.dbt.make_backup_relation", "macro.dbt.run_hooks", "macro.dbt.drop_relation_if_exists", "macro.dbt.statement", "macro.dbt.get_create_view_as_sql", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9342098, "supported_languages": ["sql"]}, "macro.dbt.materialization_materialized_view_default": {"name": "materialization_materialized_view_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialization_materialized_view_default", "macro_sql": "{% materialization materialized_view, default %}\n    {% set existing_relation = load_cached_relation(this) %}\n    {% set target_relation = this.incorporate(type=this.MaterializedView) %}\n    {% set intermediate_relation = make_intermediate_relation(target_relation) %}\n    {% set backup_relation_type = target_relation.MaterializedView if existing_relation is none else existing_relation.type %}\n    {% set backup_relation = make_backup_relation(target_relation, backup_relation_type) %}\n\n    {{ materialized_view_setup(backup_relation, intermediate_relation, pre_hooks) }}\n\n        {% set build_sql = materialized_view_get_build_sql(existing_relation, target_relation, backup_relation, intermediate_relation) %}\n\n        {% if build_sql == '' %}\n            {{ materialized_view_execute_no_op(target_relation) }}\n        {% else %}\n            {{ materialized_view_execute_build_sql(build_sql, existing_relation, target_relation, post_hooks) }}\n        {% endif %}\n\n    {{ materialized_view_teardown(backup_relation, intermediate_relation, post_hooks) }}\n\n    {{ return({'relations': [target_relation]}) }}\n\n{% endmaterialization %}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.make_intermediate_relation", "macro.dbt.make_backup_relation", "macro.dbt.materialized_view_setup", "macro.dbt.materialized_view_get_build_sql", "macro.dbt.materialized_view_execute_no_op", "macro.dbt.materialized_view_execute_build_sql", "macro.dbt.materialized_view_teardown"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.93752, "supported_languages": ["sql"]}, "macro.dbt.materialized_view_setup": {"name": "materialized_view_setup", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialized_view_setup", "macro_sql": "{% macro materialized_view_setup(backup_relation, intermediate_relation, pre_hooks) %}\n\n    -- backup_relation and intermediate_relation should not already exist in the database\n    -- it's possible these exist because of a previous run that exited unexpectedly\n    {% set preexisting_backup_relation = load_cached_relation(backup_relation) %}\n    {% set preexisting_intermediate_relation = load_cached_relation(intermediate_relation) %}\n\n    -- drop the temp relations if they exist already in the database\n    {{ drop_relation_if_exists(preexisting_backup_relation) }}\n    {{ drop_relation_if_exists(preexisting_intermediate_relation) }}\n\n    {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.drop_relation_if_exists", "macro.dbt.run_hooks"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9381971, "supported_languages": null}, "macro.dbt.materialized_view_teardown": {"name": "materialized_view_teardown", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialized_view_teardown", "macro_sql": "{% macro materialized_view_teardown(backup_relation, intermediate_relation, post_hooks) %}\n\n    -- drop the temp relations if they exist to leave the database clean for the next run\n    {{ drop_relation_if_exists(backup_relation) }}\n    {{ drop_relation_if_exists(intermediate_relation) }}\n\n    {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.drop_relation_if_exists", "macro.dbt.run_hooks"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9385343, "supported_languages": null}, "macro.dbt.materialized_view_get_build_sql": {"name": "materialized_view_get_build_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialized_view_get_build_sql", "macro_sql": "{% macro materialized_view_get_build_sql(existing_relation, target_relation, backup_relation, intermediate_relation) %}\n\n    {% set full_refresh_mode = should_full_refresh() %}\n\n    -- determine the scenario we're in: create, full_refresh, alter, refresh data\n    {% if existing_relation is none %}\n        {% set build_sql = get_create_materialized_view_as_sql(target_relation, sql) %}\n    {% elif full_refresh_mode or not existing_relation.is_materialized_view %}\n        {% set build_sql = get_replace_sql(existing_relation, target_relation, sql) %}\n    {% else %}\n\n        -- get config options\n        {% set on_configuration_change = config.get('on_configuration_change') %}\n        {% set configuration_changes = get_materialized_view_configuration_changes(existing_relation, config) %}\n\n        {% if configuration_changes is none %}\n            {% set build_sql = refresh_materialized_view(target_relation) %}\n\n        {% elif on_configuration_change == 'apply' %}\n            {% set build_sql = get_alter_materialized_view_as_sql(target_relation, configuration_changes, sql, existing_relation, backup_relation, intermediate_relation) %}\n        {% elif on_configuration_change == 'continue' %}\n            {% set build_sql = '' %}\n            {{ exceptions.warn(\"Configuration changes were identified and `on_configuration_change` was set to `continue` for `\" ~ target_relation.render() ~ \"`\") }}\n        {% elif on_configuration_change == 'fail' %}\n            {{ exceptions.raise_fail_fast_error(\"Configuration changes were identified and `on_configuration_change` was set to `fail` for `\" ~ target_relation.render() ~ \"`\") }}\n\n        {% else %}\n            -- this only happens if the user provides a value other than `apply`, 'skip', 'fail'\n            {{ exceptions.raise_compiler_error(\"Unexpected configuration scenario\") }}\n\n        {% endif %}\n\n    {% endif %}\n\n    {% do return(build_sql) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.should_full_refresh", "macro.dbt.get_create_materialized_view_as_sql", "macro.dbt.get_replace_sql", "macro.dbt.get_materialized_view_configuration_changes", "macro.dbt.refresh_materialized_view", "macro.dbt.get_alter_materialized_view_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9409304, "supported_languages": null}, "macro.dbt.materialized_view_execute_no_op": {"name": "materialized_view_execute_no_op", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialized_view_execute_no_op", "macro_sql": "{% macro materialized_view_execute_no_op(target_relation) %}\n    {% do store_raw_result(\n        name=\"main\",\n        message=\"skip \" ~ target_relation,\n        code=\"skip\",\n        rows_affected=\"-1\"\n    ) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.94156, "supported_languages": null}, "macro.dbt.materialized_view_execute_build_sql": {"name": "materialized_view_execute_build_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/materialized_view.sql", "original_file_path": "macros/materializations/models/materialized_view.sql", "unique_id": "macro.dbt.materialized_view_execute_build_sql", "macro_sql": "{% macro materialized_view_execute_build_sql(build_sql, existing_relation, target_relation, post_hooks) %}\n\n    -- `BEGIN` happens here:\n    {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n    {% set grant_config = config.get('grants') %}\n\n    {% call statement(name=\"main\") %}\n        {{ build_sql }}\n    {% endcall %}\n\n    {% set should_revoke = should_revoke(existing_relation, full_refresh_mode=True) %}\n    {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n    {% do persist_docs(target_relation, model) %}\n\n    {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n    {{ adapter.commit() }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_hooks", "macro.dbt.statement", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.942717, "supported_languages": null}, "macro.dbt.materialization_table_default": {"name": "materialization_table_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/table.sql", "original_file_path": "macros/materializations/models/table.sql", "unique_id": "macro.dbt.materialization_table_default", "macro_sql": "{% materialization table, default %}\n\n  {%- set existing_relation = load_cached_relation(this) -%}\n  {%- set target_relation = this.incorporate(type='table') %}\n  {%- set intermediate_relation =  make_intermediate_relation(target_relation) -%}\n  -- the intermediate_relation should not already exist in the database; get_relation\n  -- will return None in that case. Otherwise, we get a relation that we can drop\n  -- later, before we try to use this name for the current operation\n  {%- set preexisting_intermediate_relation = load_cached_relation(intermediate_relation) -%}\n  /*\n      See ../view/view.sql for more information about this relation.\n  */\n  {%- set backup_relation_type = 'table' if existing_relation is none else existing_relation.type -%}\n  {%- set backup_relation = make_backup_relation(target_relation, backup_relation_type) -%}\n  -- as above, the backup_relation should not already exist\n  {%- set preexisting_backup_relation = load_cached_relation(backup_relation) -%}\n  -- grab current tables grants config for comparision later on\n  {% set grant_config = config.get('grants') %}\n\n  -- drop the temp relations if they exist already in the database\n  {{ drop_relation_if_exists(preexisting_intermediate_relation) }}\n  {{ drop_relation_if_exists(preexisting_backup_relation) }}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% call statement('main') -%}\n    {{ get_create_table_as_sql(False, intermediate_relation, sql) }}\n  {%- endcall %}\n\n  -- cleanup\n  {% if existing_relation is not none %}\n     /* Do the equivalent of rename_if_exists. 'existing_relation' could have been dropped\n        since the variable was first set. */\n    {% set existing_relation = load_cached_relation(existing_relation) %}\n    {% if existing_relation is not none %}\n        {{ adapter.rename_relation(existing_relation, backup_relation) }}\n    {% endif %}\n  {% endif %}\n\n  {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n\n  {% do create_indexes(target_relation) %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {% set should_revoke = should_revoke(existing_relation, full_refresh_mode=True) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {% do persist_docs(target_relation, model) %}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  -- finally, drop the existing/backup relation after the commit\n  {{ drop_relation_if_exists(backup_relation) }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n  {{ return({'relations': [target_relation]}) }}\n{% endmaterialization %}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.make_intermediate_relation", "macro.dbt.make_backup_relation", "macro.dbt.drop_relation_if_exists", "macro.dbt.run_hooks", "macro.dbt.statement", "macro.dbt.get_create_table_as_sql", "macro.dbt.create_indexes", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9461217, "supported_languages": ["sql"]}, "macro.dbt.get_incremental_append_sql": {"name": "get_incremental_append_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_append_sql", "macro_sql": "{% macro get_incremental_append_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_append_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_incremental_append_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9469793, "supported_languages": null}, "macro.dbt.default__get_incremental_append_sql": {"name": "default__get_incremental_append_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_append_sql", "macro_sql": "{% macro default__get_incremental_append_sql(arg_dict) %}\n\n  {% do return(get_insert_into_sql(arg_dict[\"target_relation\"], arg_dict[\"temp_relation\"], arg_dict[\"dest_columns\"])) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_insert_into_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9472888, "supported_languages": null}, "macro.dbt.get_incremental_delete_insert_sql": {"name": "get_incremental_delete_insert_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_delete_insert_sql", "macro_sql": "{% macro get_incremental_delete_insert_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_delete_insert_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_incremental_delete_insert_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9475398, "supported_languages": null}, "macro.dbt.default__get_incremental_delete_insert_sql": {"name": "default__get_incremental_delete_insert_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_delete_insert_sql", "macro_sql": "{% macro default__get_incremental_delete_insert_sql(arg_dict) %}\n\n  {% do return(get_delete_insert_merge_sql(arg_dict[\"target_relation\"], arg_dict[\"temp_relation\"], arg_dict[\"unique_key\"], arg_dict[\"dest_columns\"], arg_dict[\"incremental_predicates\"])) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_delete_insert_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9479184, "supported_languages": null}, "macro.dbt.get_incremental_merge_sql": {"name": "get_incremental_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_merge_sql", "macro_sql": "{% macro get_incremental_merge_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_merge_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_incremental_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.948165, "supported_languages": null}, "macro.dbt.default__get_incremental_merge_sql": {"name": "default__get_incremental_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_merge_sql", "macro_sql": "{% macro default__get_incremental_merge_sql(arg_dict) %}\n\n  {% do return(get_merge_sql(arg_dict[\"target_relation\"], arg_dict[\"temp_relation\"], arg_dict[\"unique_key\"], arg_dict[\"dest_columns\"], arg_dict[\"incremental_predicates\"])) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.948536, "supported_languages": null}, "macro.dbt.get_incremental_insert_overwrite_sql": {"name": "get_incremental_insert_overwrite_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_insert_overwrite_sql", "macro_sql": "{% macro get_incremental_insert_overwrite_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_insert_overwrite_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_incremental_insert_overwrite_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9487722, "supported_languages": null}, "macro.dbt.default__get_incremental_insert_overwrite_sql": {"name": "default__get_incremental_insert_overwrite_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_insert_overwrite_sql", "macro_sql": "{% macro default__get_incremental_insert_overwrite_sql(arg_dict) %}\n\n  {% do return(get_insert_overwrite_merge_sql(arg_dict[\"target_relation\"], arg_dict[\"temp_relation\"], arg_dict[\"dest_columns\"], arg_dict[\"incremental_predicates\"])) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_insert_overwrite_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9491186, "supported_languages": null}, "macro.dbt.get_incremental_default_sql": {"name": "get_incremental_default_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_default_sql", "macro_sql": "{% macro get_incremental_default_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_default_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_incremental_default_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9493546, "supported_languages": null}, "macro.dbt.default__get_incremental_default_sql": {"name": "default__get_incremental_default_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_default_sql", "macro_sql": "{% macro default__get_incremental_default_sql(arg_dict) %}\n\n  {% do return(get_incremental_append_sql(arg_dict)) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_incremental_append_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9495645, "supported_languages": null}, "macro.dbt.get_incremental_microbatch_sql": {"name": "get_incremental_microbatch_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_incremental_microbatch_sql", "macro_sql": "{% macro get_incremental_microbatch_sql(arg_dict) %}\n\n  {{ return(adapter.dispatch('get_incremental_microbatch_sql', 'dbt')(arg_dict)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_incremental_microbatch_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9498909, "supported_languages": null}, "macro.dbt.default__get_incremental_microbatch_sql": {"name": "default__get_incremental_microbatch_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.default__get_incremental_microbatch_sql", "macro_sql": "{% macro default__get_incremental_microbatch_sql(arg_dict) %}\n\n  {{ exceptions.raise_not_implemented('microbatch materialization strategy not implemented for adapter ' + adapter.type()) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9501026, "supported_languages": null}, "macro.dbt.get_insert_into_sql": {"name": "get_insert_into_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/strategies.sql", "original_file_path": "macros/materializations/models/incremental/strategies.sql", "unique_id": "macro.dbt.get_insert_into_sql", "macro_sql": "{% macro get_insert_into_sql(target_relation, temp_relation, dest_columns) %}\n\n    {%- set dest_cols_csv = get_quoted_csv(dest_columns | map(attribute=\"name\")) -%}\n\n    insert into {{ target_relation }} ({{ dest_cols_csv }})\n    (\n        select {{ dest_cols_csv }}\n        from {{ temp_relation }}\n    )\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_quoted_csv"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9504607, "supported_languages": null}, "macro.dbt.get_quoted_csv": {"name": "get_quoted_csv", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/column_helpers.sql", "original_file_path": "macros/materializations/models/incremental/column_helpers.sql", "unique_id": "macro.dbt.get_quoted_csv", "macro_sql": "{% macro get_quoted_csv(column_names) %}\n\n    {% set quoted = [] %}\n    {% for col in column_names -%}\n        {%- do quoted.append(adapter.quote(col)) -%}\n    {%- endfor %}\n\n    {%- set dest_cols_csv = quoted | join(', ') -%}\n    {{ return(dest_cols_csv) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9515243, "supported_languages": null}, "macro.dbt.diff_columns": {"name": "diff_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/column_helpers.sql", "original_file_path": "macros/materializations/models/incremental/column_helpers.sql", "unique_id": "macro.dbt.diff_columns", "macro_sql": "{% macro diff_columns(source_columns, target_columns) %}\n\n  {% set result = [] %}\n  {% set source_names = source_columns | map(attribute = 'column') | list %}\n  {% set target_names = target_columns | map(attribute = 'column') | list %}\n\n   {# --check whether the name attribute exists in the target - this does not perform a data type check #}\n   {% for sc in source_columns %}\n     {% if sc.name not in target_names %}\n        {{ result.append(sc) }}\n     {% endif %}\n   {% endfor %}\n\n  {{ return(result) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9524553, "supported_languages": null}, "macro.dbt.diff_column_data_types": {"name": "diff_column_data_types", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/column_helpers.sql", "original_file_path": "macros/materializations/models/incremental/column_helpers.sql", "unique_id": "macro.dbt.diff_column_data_types", "macro_sql": "{% macro diff_column_data_types(source_columns, target_columns) %}\n\n  {% set result = [] %}\n  {% for sc in source_columns %}\n    {% set tc = target_columns | selectattr(\"name\", \"equalto\", sc.name) | list | first %}\n    {% if tc %}\n      {% if sc.data_type != tc.data_type and not sc.can_expand_to(other_column=tc) %}\n        {{ result.append( { 'column_name': tc.name, 'new_type': sc.data_type } ) }}\n      {% endif %}\n    {% endif %}\n  {% endfor %}\n\n  {{ return(result) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9535384, "supported_languages": null}, "macro.dbt.get_merge_update_columns": {"name": "get_merge_update_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/column_helpers.sql", "original_file_path": "macros/materializations/models/incremental/column_helpers.sql", "unique_id": "macro.dbt.get_merge_update_columns", "macro_sql": "{% macro get_merge_update_columns(merge_update_columns, merge_exclude_columns, dest_columns) %}\n  {{ return(adapter.dispatch('get_merge_update_columns', 'dbt')(merge_update_columns, merge_exclude_columns, dest_columns)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_merge_update_columns"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9538517, "supported_languages": null}, "macro.dbt.default__get_merge_update_columns": {"name": "default__get_merge_update_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/column_helpers.sql", "original_file_path": "macros/materializations/models/incremental/column_helpers.sql", "unique_id": "macro.dbt.default__get_merge_update_columns", "macro_sql": "{% macro default__get_merge_update_columns(merge_update_columns, merge_exclude_columns, dest_columns) %}\n  {%- set default_cols = dest_columns | map(attribute=\"quoted\") | list -%}\n\n  {%- if merge_update_columns and merge_exclude_columns -%}\n    {{ exceptions.raise_compiler_error(\n        'Model cannot specify merge_update_columns and merge_exclude_columns. Please update model to use only one config'\n    )}}\n  {%- elif merge_update_columns -%}\n    {%- set update_columns = merge_update_columns -%}\n  {%- elif merge_exclude_columns -%}\n    {%- set update_columns = [] -%}\n    {%- for column in dest_columns -%}\n      {% if column.column | lower not in merge_exclude_columns | map(\"lower\") | list %}\n        {%- do update_columns.append(column.quoted) -%}\n      {% endif %}\n    {%- endfor -%}\n  {%- else -%}\n    {%- set update_columns = default_cols -%}\n  {%- endif -%}\n\n  {{ return(update_columns) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9547803, "supported_languages": null}, "macro.dbt.materialization_incremental_default": {"name": "materialization_incremental_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/incremental.sql", "original_file_path": "macros/materializations/models/incremental/incremental.sql", "unique_id": "macro.dbt.materialization_incremental_default", "macro_sql": "{% materialization incremental, default -%}\n\n  -- relations\n  {%- set existing_relation = load_cached_relation(this) -%}\n  {%- set target_relation = this.incorporate(type='table') -%}\n  {%- set temp_relation = make_temp_relation(target_relation)-%}\n  {%- set intermediate_relation = make_intermediate_relation(target_relation)-%}\n  {%- set backup_relation_type = 'table' if existing_relation is none else existing_relation.type -%}\n  {%- set backup_relation = make_backup_relation(target_relation, backup_relation_type) -%}\n\n  -- configs\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set full_refresh_mode = (should_full_refresh()  or existing_relation.is_view) -%}\n  {%- set on_schema_change = incremental_validate_on_schema_change(config.get('on_schema_change'), default='ignore') -%}\n\n  -- the temp_ and backup_ relations should not already exist in the database; get_relation\n  -- will return None in that case. Otherwise, we get a relation that we can drop\n  -- later, before we try to use this name for the current operation. This has to happen before\n  -- BEGIN, in a separate transaction\n  {%- set preexisting_intermediate_relation = load_cached_relation(intermediate_relation)-%}\n  {%- set preexisting_backup_relation = load_cached_relation(backup_relation) -%}\n   -- grab current tables grants config for comparision later on\n  {% set grant_config = config.get('grants') %}\n  {{ drop_relation_if_exists(preexisting_intermediate_relation) }}\n  {{ drop_relation_if_exists(preexisting_backup_relation) }}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  {% set to_drop = [] %}\n\n  {% set incremental_strategy = config.get('incremental_strategy') or 'default' %}\n  {% set strategy_sql_macro_func = adapter.get_incremental_strategy_macro(context, incremental_strategy) %}\n\n  {% if existing_relation is none %}\n      {% set build_sql = get_create_table_as_sql(False, target_relation, sql) %}\n  {% elif full_refresh_mode %}\n      {% set build_sql = get_create_table_as_sql(False, intermediate_relation, sql) %}\n      {% set need_swap = true %}\n  {% else %}\n    {% do run_query(get_create_table_as_sql(True, temp_relation, sql)) %}\n    {% set contract_config = config.get('contract') %}\n    {% if not contract_config or not contract_config.enforced %}\n      {% do adapter.expand_target_column_types(\n               from_relation=temp_relation,\n               to_relation=target_relation) %}\n    {% endif %}\n    {#-- Process schema changes. Returns dict of changes if successful. Use source columns for upserting/merging --#}\n    {% set dest_columns = process_schema_changes(on_schema_change, temp_relation, existing_relation) %}\n    {% if not dest_columns %}\n      {% set dest_columns = adapter.get_columns_in_relation(existing_relation) %}\n    {% endif %}\n\n    {#-- Get the incremental_strategy, the macro to use for the strategy, and build the sql --#}\n    {% set incremental_predicates = config.get('predicates', none) or config.get('incremental_predicates', none) %}\n    {% set strategy_arg_dict = ({'target_relation': target_relation, 'temp_relation': temp_relation, 'unique_key': unique_key, 'dest_columns': dest_columns, 'incremental_predicates': incremental_predicates }) %}\n    {% set build_sql = strategy_sql_macro_func(strategy_arg_dict) %}\n\n  {% endif %}\n\n  {% call statement(\"main\") %}\n      {{ build_sql }}\n  {% endcall %}\n\n  {% if need_swap %}\n      {% do adapter.rename_relation(target_relation, backup_relation) %}\n      {% do adapter.rename_relation(intermediate_relation, target_relation) %}\n      {% do to_drop.append(backup_relation) %}\n  {% endif %}\n\n  {% set should_revoke = should_revoke(existing_relation, full_refresh_mode) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {% do persist_docs(target_relation, model) %}\n\n  {% if existing_relation is none or existing_relation.is_view or should_full_refresh() %}\n    {% do create_indexes(target_relation) %}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {% do adapter.commit() %}\n\n  {% for rel in to_drop %}\n      {% do adapter.drop_relation(rel) %}\n  {% endfor %}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n  {{ return({'relations': [target_relation]}) }}\n\n{%- endmaterialization %}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.make_temp_relation", "macro.dbt.make_intermediate_relation", "macro.dbt.make_backup_relation", "macro.dbt.should_full_refresh", "macro.dbt.incremental_validate_on_schema_change", "macro.dbt.drop_relation_if_exists", "macro.dbt.run_hooks", "macro.dbt.get_create_table_as_sql", "macro.dbt.run_query", "macro.dbt.process_schema_changes", "macro.dbt.statement", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs", "macro.dbt.create_indexes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9609616, "supported_languages": ["sql"]}, "macro.dbt.get_merge_sql": {"name": "get_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.get_merge_sql", "macro_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns, incremental_predicates=none) -%}\n   -- back compat for old kwarg name\n  {% set incremental_predicates = kwargs.get('predicates', incremental_predicates) %}\n  {{ adapter.dispatch('get_merge_sql', 'dbt')(target, source, unique_key, dest_columns, incremental_predicates) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.962467, "supported_languages": null}, "macro.dbt.default__get_merge_sql": {"name": "default__get_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.default__get_merge_sql", "macro_sql": "{% macro default__get_merge_sql(target, source, unique_key, dest_columns, incremental_predicates=none) -%}\n    {%- set predicates = [] if incremental_predicates is none else [] + incremental_predicates -%}\n    {%- set dest_cols_csv = get_quoted_csv(dest_columns | map(attribute=\"name\")) -%}\n    {%- set merge_update_columns = config.get('merge_update_columns') -%}\n    {%- set merge_exclude_columns = config.get('merge_exclude_columns') -%}\n    {%- set update_columns = get_merge_update_columns(merge_update_columns, merge_exclude_columns, dest_columns) -%}\n    {%- set sql_header = config.get('sql_header', none) -%}\n\n    {% if unique_key %}\n        {% if unique_key is sequence and unique_key is not mapping and unique_key is not string %}\n            {% for key in unique_key %}\n                {% set this_key_match %}\n                    DBT_INTERNAL_SOURCE.{{ key }} = DBT_INTERNAL_DEST.{{ key }}\n                {% endset %}\n                {% do predicates.append(this_key_match) %}\n            {% endfor %}\n        {% else %}\n            {% set source_unique_key = (\"DBT_INTERNAL_SOURCE.\" ~ unique_key) | trim %}\n\t    {% set target_unique_key = (\"DBT_INTERNAL_DEST.\" ~ unique_key) | trim %}\n\t    {% set unique_key_match = equals(source_unique_key, target_unique_key) | trim %}\n            {% do predicates.append(unique_key_match) %}\n        {% endif %}\n    {% else %}\n        {% do predicates.append('FALSE') %}\n    {% endif %}\n\n    {{ sql_header if sql_header is not none }}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n        using {{ source }} as DBT_INTERNAL_SOURCE\n        on {{\"(\" ~ predicates | join(\") and (\") ~ \")\"}}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column_name in update_columns -%}\n            {{ column_name }} = DBT_INTERNAL_SOURCE.{{ column_name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_quoted_csv", "macro.dbt.get_merge_update_columns", "macro.dbt.equals"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9651115, "supported_languages": null}, "macro.dbt.get_delete_insert_merge_sql": {"name": "get_delete_insert_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.get_delete_insert_merge_sql", "macro_sql": "{% macro get_delete_insert_merge_sql(target, source, unique_key, dest_columns, incremental_predicates) -%}\n  {{ adapter.dispatch('get_delete_insert_merge_sql', 'dbt')(target, source, unique_key, dest_columns, incremental_predicates) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_delete_insert_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9655519, "supported_languages": null}, "macro.dbt.default__get_delete_insert_merge_sql": {"name": "default__get_delete_insert_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.default__get_delete_insert_merge_sql", "macro_sql": "{% macro default__get_delete_insert_merge_sql(target, source, unique_key, dest_columns, incremental_predicates) -%}\n\n    {%- set dest_cols_csv = get_quoted_csv(dest_columns | map(attribute=\"name\")) -%}\n\n    {% if unique_key %}\n        {% if unique_key is string %}\n        {% set unique_key = [unique_key] %}\n        {% endif %}\n\n        {%- set unique_key_str = unique_key|join(', ') -%}\n\n        delete from {{ target }}\n        where ({{ unique_key_str }}) in (\n            select distinct {{ unique_key_str }}\n            from {{ source }}\n        )\n        {%- if incremental_predicates %}\n            {% for predicate in incremental_predicates %}\n                and {{ predicate }}\n            {% endfor %}\n        {%- endif -%};\n\n    {% endif %}\n\n    insert into {{ target }} ({{ dest_cols_csv }})\n    (\n        select {{ dest_cols_csv }}\n        from {{ source }}\n    )\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_quoted_csv"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.966497, "supported_languages": null}, "macro.dbt.get_insert_overwrite_merge_sql": {"name": "get_insert_overwrite_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.get_insert_overwrite_merge_sql", "macro_sql": "{% macro get_insert_overwrite_merge_sql(target, source, dest_columns, predicates, include_sql_header=false) -%}\n  {{ adapter.dispatch('get_insert_overwrite_merge_sql', 'dbt')(target, source, dest_columns, predicates, include_sql_header) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_insert_overwrite_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9668329, "supported_languages": null}, "macro.dbt.default__get_insert_overwrite_merge_sql": {"name": "default__get_insert_overwrite_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/merge.sql", "original_file_path": "macros/materializations/models/incremental/merge.sql", "unique_id": "macro.dbt.default__get_insert_overwrite_merge_sql", "macro_sql": "{% macro default__get_insert_overwrite_merge_sql(target, source, dest_columns, predicates, include_sql_header) -%}\n    {#-- The only time include_sql_header is True: --#}\n    {#-- BigQuery + insert_overwrite strategy + \"static\" partitions config --#}\n    {#-- We should consider including the sql header at the materialization level instead --#}\n\n    {%- set predicates = [] if predicates is none else [] + predicates -%}\n    {%- set dest_cols_csv = get_quoted_csv(dest_columns | map(attribute=\"name\")) -%}\n    {%- set sql_header = config.get('sql_header', none) -%}\n\n    {{ sql_header if sql_header is not none and include_sql_header }}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n        using {{ source }} as DBT_INTERNAL_SOURCE\n        on FALSE\n\n    when not matched by source\n        {% if predicates %} and {{ predicates | join(' and ') }} {% endif %}\n        then delete\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_quoted_csv"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9678152, "supported_languages": null}, "macro.dbt.incremental_validate_on_schema_change": {"name": "incremental_validate_on_schema_change", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/on_schema_change.sql", "original_file_path": "macros/materializations/models/incremental/on_schema_change.sql", "unique_id": "macro.dbt.incremental_validate_on_schema_change", "macro_sql": "{% macro incremental_validate_on_schema_change(on_schema_change, default='ignore') %}\n\n   {% if on_schema_change not in ['sync_all_columns', 'append_new_columns', 'fail', 'ignore'] %}\n\n     {% set log_message = 'Invalid value for on_schema_change (%s) specified. Setting default value of %s.' % (on_schema_change, default) %}\n     {% do log(log_message) %}\n\n     {{ return(default) }}\n\n   {% else %}\n\n     {{ return(on_schema_change) }}\n\n   {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9696841, "supported_languages": null}, "macro.dbt.check_for_schema_changes": {"name": "check_for_schema_changes", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/on_schema_change.sql", "original_file_path": "macros/materializations/models/incremental/on_schema_change.sql", "unique_id": "macro.dbt.check_for_schema_changes", "macro_sql": "{% macro check_for_schema_changes(source_relation, target_relation) %}\n\n  {% set schema_changed = False %}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set target_columns = adapter.get_columns_in_relation(target_relation) -%}\n  {%- set source_not_in_target = diff_columns(source_columns, target_columns) -%}\n  {%- set target_not_in_source = diff_columns(target_columns, source_columns) -%}\n\n  {% set new_target_types = diff_column_data_types(source_columns, target_columns) %}\n\n  {% if source_not_in_target != [] %}\n    {% set schema_changed = True %}\n  {% elif target_not_in_source != [] or new_target_types != [] %}\n    {% set schema_changed = True %}\n  {% elif new_target_types != [] %}\n    {% set schema_changed = True %}\n  {% endif %}\n\n  {% set changes_dict = {\n    'schema_changed': schema_changed,\n    'source_not_in_target': source_not_in_target,\n    'target_not_in_source': target_not_in_source,\n    'source_columns': source_columns,\n    'target_columns': target_columns,\n    'new_target_types': new_target_types\n  } %}\n\n  {% set msg %}\n    In {{ target_relation }}:\n        Schema changed: {{ schema_changed }}\n        Source columns not in target: {{ source_not_in_target }}\n        Target columns not in source: {{ target_not_in_source }}\n        New column types: {{ new_target_types }}\n  {% endset %}\n\n  {% do log(msg) %}\n\n  {{ return(changes_dict) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.diff_columns", "macro.dbt.diff_column_data_types"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9712868, "supported_languages": null}, "macro.dbt.sync_column_schemas": {"name": "sync_column_schemas", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/on_schema_change.sql", "original_file_path": "macros/materializations/models/incremental/on_schema_change.sql", "unique_id": "macro.dbt.sync_column_schemas", "macro_sql": "{% macro sync_column_schemas(on_schema_change, target_relation, schema_changes_dict) %}\n\n  {%- set add_to_target_arr = schema_changes_dict['source_not_in_target'] -%}\n\n  {%- if on_schema_change == 'append_new_columns'-%}\n     {%- if add_to_target_arr | length > 0 -%}\n       {%- do alter_relation_add_remove_columns(target_relation, add_to_target_arr, none) -%}\n     {%- endif -%}\n\n  {% elif on_schema_change == 'sync_all_columns' %}\n     {%- set remove_from_target_arr = schema_changes_dict['target_not_in_source'] -%}\n     {%- set new_target_types = schema_changes_dict['new_target_types'] -%}\n\n     {% if add_to_target_arr | length > 0 or remove_from_target_arr | length > 0 %}\n       {%- do alter_relation_add_remove_columns(target_relation, add_to_target_arr, remove_from_target_arr) -%}\n     {% endif %}\n\n     {% if new_target_types != [] %}\n       {% for ntt in new_target_types %}\n         {% set column_name = ntt['column_name'] %}\n         {% set new_type = ntt['new_type'] %}\n         {% do alter_column_type(target_relation, column_name, new_type) %}\n       {% endfor %}\n     {% endif %}\n\n  {% endif %}\n\n  {% set schema_change_message %}\n    In {{ target_relation }}:\n        Schema change approach: {{ on_schema_change }}\n        Columns added: {{ add_to_target_arr }}\n        Columns removed: {{ remove_from_target_arr }}\n        Data types changed: {{ new_target_types }}\n  {% endset %}\n\n  {% do log(schema_change_message) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.alter_relation_add_remove_columns", "macro.dbt.alter_column_type"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9733672, "supported_languages": null}, "macro.dbt.process_schema_changes": {"name": "process_schema_changes", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/on_schema_change.sql", "original_file_path": "macros/materializations/models/incremental/on_schema_change.sql", "unique_id": "macro.dbt.process_schema_changes", "macro_sql": "{% macro process_schema_changes(on_schema_change, source_relation, target_relation) %}\n\n    {% if on_schema_change == 'ignore' %}\n\n     {{ return({}) }}\n\n    {% else %}\n\n      {% set schema_changes_dict = check_for_schema_changes(source_relation, target_relation) %}\n\n      {% if schema_changes_dict['schema_changed'] %}\n\n        {% if on_schema_change == 'fail' %}\n\n          {% set fail_msg %}\n              The source and target schemas on this incremental model are out of sync!\n              They can be reconciled in several ways:\n                - set the `on_schema_change` config to either append_new_columns or sync_all_columns, depending on your situation.\n                - Re-run the incremental model with `full_refresh: True` to update the target schema.\n                - update the schema manually and re-run the process.\n\n              Additional troubleshooting context:\n                 Source columns not in target: {{ schema_changes_dict['source_not_in_target'] }}\n                 Target columns not in source: {{ schema_changes_dict['target_not_in_source'] }}\n                 New column types: {{ schema_changes_dict['new_target_types'] }}\n          {% endset %}\n\n          {% do exceptions.raise_compiler_error(fail_msg) %}\n\n        {# -- unless we ignore, run the sync operation per the config #}\n        {% else %}\n\n          {% do sync_column_schemas(on_schema_change, target_relation, schema_changes_dict) %}\n\n        {% endif %}\n\n      {% endif %}\n\n      {{ return(schema_changes_dict['source_columns']) }}\n\n    {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.check_for_schema_changes", "macro.dbt.sync_column_schemas"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.974483, "supported_languages": null}, "macro.dbt.is_incremental": {"name": "is_incremental", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/incremental/is_incremental.sql", "original_file_path": "macros/materializations/models/incremental/is_incremental.sql", "unique_id": "macro.dbt.is_incremental", "macro_sql": "{% macro is_incremental() %}\n    {#-- do not run introspective queries in parsing #}\n    {% if not execute %}\n        {{ return(False) }}\n    {% else %}\n        {% set relation = adapter.get_relation(this.database, this.schema, this.table) %}\n        {{ return(relation is not none\n                  and relation.type == 'table'\n                  and model.config.materialized == 'incremental'\n                  and not should_full_refresh()) }}\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.should_full_refresh"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.97524, "supported_languages": null}, "macro.dbt.create_or_replace_clone": {"name": "create_or_replace_clone", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/clone/create_or_replace_clone.sql", "original_file_path": "macros/materializations/models/clone/create_or_replace_clone.sql", "unique_id": "macro.dbt.create_or_replace_clone", "macro_sql": "{% macro create_or_replace_clone(this_relation, defer_relation) %}\n    {{ return(adapter.dispatch('create_or_replace_clone', 'dbt')(this_relation, defer_relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__create_or_replace_clone"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.97567, "supported_languages": null}, "macro.dbt.default__create_or_replace_clone": {"name": "default__create_or_replace_clone", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/clone/create_or_replace_clone.sql", "original_file_path": "macros/materializations/models/clone/create_or_replace_clone.sql", "unique_id": "macro.dbt.default__create_or_replace_clone", "macro_sql": "{% macro default__create_or_replace_clone(this_relation, defer_relation) %}\n    create or replace table {{ this_relation.render() }} clone {{ defer_relation.render() }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9759736, "supported_languages": null}, "macro.dbt.materialization_clone_default": {"name": "materialization_clone_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/clone/clone.sql", "original_file_path": "macros/materializations/models/clone/clone.sql", "unique_id": "macro.dbt.materialization_clone_default", "macro_sql": "{%- materialization clone, default -%}\n\n  {%- set relations = {'relations': []} -%}\n\n  {%- if not defer_relation -%}\n      -- nothing to do\n      {{ log(\"No relation found in state manifest for \" ~ model.unique_id, info=True) }}\n      {{ return(relations) }}\n  {%- endif -%}\n\n  {%- set existing_relation = load_cached_relation(this) -%}\n\n  {%- if existing_relation and not flags.FULL_REFRESH -%}\n      -- noop!\n      {{ log(\"Relation \" ~ existing_relation ~ \" already exists\", info=True) }}\n      {{ return(relations) }}\n  {%- endif -%}\n\n  {%- set other_existing_relation = load_cached_relation(defer_relation) -%}\n\n  -- If this is a database that can do zero-copy cloning of tables, and the other relation is a table, then this will be a table\n  -- Otherwise, this will be a view\n\n  {% set can_clone_table = can_clone_table() %}\n\n  {%- if other_existing_relation and other_existing_relation.type == 'table' and can_clone_table -%}\n\n      {%- set target_relation = this.incorporate(type='table') -%}\n      {% if existing_relation is not none and not existing_relation.is_table %}\n        {{ log(\"Dropping relation \" ~ existing_relation.render() ~ \" because it is of type \" ~ existing_relation.type) }}\n        {{ drop_relation_if_exists(existing_relation) }}\n      {% endif %}\n\n      -- as a general rule, data platforms that can clone tables can also do atomic 'create or replace'\n      {% call statement('main') %}\n          {% if target_relation and defer_relation and target_relation == defer_relation %}\n              {{ log(\"Target relation and defer relation are the same, skipping clone for relation: \" ~ target_relation.render()) }}\n          {% else %}\n              {{ create_or_replace_clone(target_relation, defer_relation) }}\n          {% endif %}\n\n      {% endcall %}\n\n      {% set should_revoke = should_revoke(existing_relation, full_refresh_mode=True) %}\n      {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n      {% do persist_docs(target_relation, model) %}\n\n      {{ return({'relations': [target_relation]}) }}\n\n  {%- else -%}\n\n      {%- set target_relation = this.incorporate(type='view') -%}\n\n      -- reuse the view materialization\n      -- TODO: support actual dispatch for materialization macros\n      -- Tracking ticket: https://github.com/dbt-labs/dbt-core/issues/7799\n      {% set search_name = \"materialization_view_\" ~ adapter.type() %}\n      {% if not search_name in context %}\n          {% set search_name = \"materialization_view_default\" %}\n      {% endif %}\n      {% set materialization_macro = context[search_name] %}\n      {% set relations = materialization_macro() %}\n      {{ return(relations) }}\n\n  {%- endif -%}\n\n{%- endmaterialization -%}", "depends_on": {"macros": ["macro.dbt.load_cached_relation", "macro.dbt.can_clone_table", "macro.dbt.drop_relation_if_exists", "macro.dbt.statement", "macro.dbt.create_or_replace_clone", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9793963, "supported_languages": ["sql"]}, "macro.dbt.can_clone_table": {"name": "can_clone_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/clone/can_clone_table.sql", "original_file_path": "macros/materializations/models/clone/can_clone_table.sql", "unique_id": "macro.dbt.can_clone_table", "macro_sql": "{% macro can_clone_table() %}\n    {{ return(adapter.dispatch('can_clone_table', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__can_clone_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9798062, "supported_languages": null}, "macro.dbt.default__can_clone_table": {"name": "default__can_clone_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/models/clone/can_clone_table.sql", "original_file_path": "macros/materializations/models/clone/can_clone_table.sql", "unique_id": "macro.dbt.default__can_clone_table", "macro_sql": "{% macro default__can_clone_table() %}\n    {{ return(False) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9800036, "supported_languages": null}, "macro.dbt.materialization_unit_default": {"name": "materialization_unit_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/unit.sql", "original_file_path": "macros/materializations/tests/unit.sql", "unique_id": "macro.dbt.materialization_unit_default", "macro_sql": "{%- materialization unit, default -%}\n\n  {% set relations = [] %}\n\n  {% set expected_rows = config.get('expected_rows') %}\n  {% set expected_sql = config.get('expected_sql') %}\n  {% set tested_expected_column_names = expected_rows[0].keys() if (expected_rows | length ) > 0 else get_columns_in_query(sql) %} %}\n\n  {%- set target_relation = this.incorporate(type='table') -%}\n  {%- set temp_relation = make_temp_relation(target_relation)-%}\n  {% do run_query(get_create_table_as_sql(True, temp_relation, get_empty_subquery_sql(sql))) %}\n  {%- set columns_in_relation = adapter.get_columns_in_relation(temp_relation) -%}\n  {%- set column_name_to_data_types = {} -%}\n  {%- for column in columns_in_relation -%}\n  {%-   do column_name_to_data_types.update({column.name|lower: column.data_type}) -%}\n  {%- endfor -%}\n\n  {% if not expected_sql %}\n  {%   set expected_sql = get_expected_sql(expected_rows, column_name_to_data_types) %}\n  {% endif %}\n  {% set unit_test_sql = get_unit_test_sql(sql, expected_sql, tested_expected_column_names) %}\n\n  {% call statement('main', fetch_result=True) -%}\n\n    {{ unit_test_sql }}\n\n  {%- endcall %}\n\n  {% do adapter.drop_relation(temp_relation) %}\n\n  {{ return({'relations': relations}) }}\n\n{%- endmaterialization -%}", "depends_on": {"macros": ["macro.dbt.get_columns_in_query", "macro.dbt.make_temp_relation", "macro.dbt.run_query", "macro.dbt.get_create_table_as_sql", "macro.dbt.get_empty_subquery_sql", "macro.dbt.get_expected_sql", "macro.dbt.get_unit_test_sql", "macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.982272, "supported_languages": ["sql"]}, "macro.dbt.get_test_sql": {"name": "get_test_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/helpers.sql", "original_file_path": "macros/materializations/tests/helpers.sql", "unique_id": "macro.dbt.get_test_sql", "macro_sql": "{% macro get_test_sql(main_sql, fail_calc, warn_if, error_if, limit) -%}\n  {{ adapter.dispatch('get_test_sql', 'dbt')(main_sql, fail_calc, warn_if, error_if, limit) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_test_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9829562, "supported_languages": null}, "macro.dbt.default__get_test_sql": {"name": "default__get_test_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/helpers.sql", "original_file_path": "macros/materializations/tests/helpers.sql", "unique_id": "macro.dbt.default__get_test_sql", "macro_sql": "{% macro default__get_test_sql(main_sql, fail_calc, warn_if, error_if, limit) -%}\n    select\n      {{ fail_calc }} as failures,\n      {{ fail_calc }} {{ warn_if }} as should_warn,\n      {{ fail_calc }} {{ error_if }} as should_error\n    from (\n      {{ main_sql }}\n      {{ \"limit \" ~ limit if limit != none }}\n    ) dbt_internal_test\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9833603, "supported_languages": null}, "macro.dbt.get_unit_test_sql": {"name": "get_unit_test_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/helpers.sql", "original_file_path": "macros/materializations/tests/helpers.sql", "unique_id": "macro.dbt.get_unit_test_sql", "macro_sql": "{% macro get_unit_test_sql(main_sql, expected_fixture_sql, expected_column_names) -%}\n  {{ adapter.dispatch('get_unit_test_sql', 'dbt')(main_sql, expected_fixture_sql, expected_column_names) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_unit_test_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9836712, "supported_languages": null}, "macro.dbt.default__get_unit_test_sql": {"name": "default__get_unit_test_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/helpers.sql", "original_file_path": "macros/materializations/tests/helpers.sql", "unique_id": "macro.dbt.default__get_unit_test_sql", "macro_sql": "{% macro default__get_unit_test_sql(main_sql, expected_fixture_sql, expected_column_names) -%}\n-- Build actual result given inputs\nwith dbt_internal_unit_test_actual as (\n  select\n    {% for expected_column_name in expected_column_names %}{{expected_column_name}}{% if not loop.last -%},{% endif %}{%- endfor -%}, {{ dbt.string_literal(\"actual\") }} as {{ adapter.quote(\"actual_or_expected\") }}\n  from (\n    {{ main_sql }}\n  ) _dbt_internal_unit_test_actual\n),\n-- Build expected result\ndbt_internal_unit_test_expected as (\n  select\n    {% for expected_column_name in expected_column_names %}{{expected_column_name}}{% if not loop.last -%}, {% endif %}{%- endfor -%}, {{ dbt.string_literal(\"expected\") }} as {{ adapter.quote(\"actual_or_expected\") }}\n  from (\n    {{ expected_fixture_sql }}\n  ) _dbt_internal_unit_test_expected\n)\n-- Union actual and expected results\nselect * from dbt_internal_unit_test_actual\nunion all\nselect * from dbt_internal_unit_test_expected\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.string_literal"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9846938, "supported_languages": null}, "macro.dbt.materialization_test_default": {"name": "materialization_test_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/test.sql", "original_file_path": "macros/materializations/tests/test.sql", "unique_id": "macro.dbt.materialization_test_default", "macro_sql": "{%- materialization test, default -%}\n\n  {% set relations = [] %}\n\n  {% if should_store_failures() %}\n\n    {% set identifier = model['alias'] %}\n    {% set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) %}\n\n    {% set store_failures_as = config.get('store_failures_as') %}\n    -- if `--store-failures` is invoked via command line and `store_failures_as` is not set,\n    -- config.get('store_failures_as', 'table') returns None, not 'table'\n    {% if store_failures_as == none %}{% set store_failures_as = 'table' %}{% endif %}\n    {% if store_failures_as not in ['table', 'view'] %}\n        {{ exceptions.raise_compiler_error(\n            \"'\" ~ store_failures_as ~ \"' is not a valid value for `store_failures_as`. \"\n            \"Accepted values are: ['ephemeral', 'table', 'view']\"\n        ) }}\n    {% endif %}\n\n    {% set target_relation = api.Relation.create(\n        identifier=identifier, schema=schema, database=database, type=store_failures_as) -%} %}\n\n    {% if old_relation %}\n        {% do adapter.drop_relation(old_relation) %}\n    {% endif %}\n\n    {% call statement(auto_begin=True) %}\n        {{ get_create_sql(target_relation, sql) }}\n    {% endcall %}\n\n    {% do relations.append(target_relation) %}\n\n    {% set main_sql %}\n        select *\n        from {{ target_relation }}\n    {% endset %}\n\n    {{ adapter.commit() }}\n\n  {% else %}\n\n      {% set main_sql = sql %}\n\n  {% endif %}\n\n  {% set limit = config.get('limit') %}\n  {% set fail_calc = config.get('fail_calc') %}\n  {% set warn_if = config.get('warn_if') %}\n  {% set error_if = config.get('error_if') %}\n\n  {% call statement('main', fetch_result=True) -%}\n\n    {{ get_test_sql(main_sql, fail_calc, warn_if, error_if, limit)}}\n\n  {%- endcall %}\n\n  {{ return({'relations': relations}) }}\n\n{%- endmaterialization -%}", "depends_on": {"macros": ["macro.dbt.should_store_failures", "macro.dbt.statement", "macro.dbt.get_create_sql", "macro.dbt.get_test_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9877434, "supported_languages": ["sql"]}, "macro.dbt.get_where_subquery": {"name": "get_where_subquery", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/where_subquery.sql", "original_file_path": "macros/materializations/tests/where_subquery.sql", "unique_id": "macro.dbt.get_where_subquery", "macro_sql": "{% macro get_where_subquery(relation) -%}\n    {% do return(adapter.dispatch('get_where_subquery', 'dbt')(relation)) %}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_where_subquery"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9883008, "supported_languages": null}, "macro.dbt.default__get_where_subquery": {"name": "default__get_where_subquery", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/tests/where_subquery.sql", "original_file_path": "macros/materializations/tests/where_subquery.sql", "unique_id": "macro.dbt.default__get_where_subquery", "macro_sql": "{% macro default__get_where_subquery(relation) -%}\n    {% set where = config.get('where', '') %}\n    {% if where %}\n        {%- set filtered -%}\n            (select * from {{ relation }} where {{ where }}) dbt_subquery\n        {%- endset -%}\n        {% do return(filtered) %}\n    {%- else -%}\n        {% do return(relation) %}\n    {%- endif -%}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9889493, "supported_languages": null}, "macro.dbt.strategy_dispatch": {"name": "strategy_dispatch", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.strategy_dispatch", "macro_sql": "{% macro strategy_dispatch(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        Could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set search_name = 'snapshot_' ~ name ~ '_strategy' -%}\n\n  {% if search_name not in package_context %}\n    {% set error_msg %}\n        The specified strategy macro '{{name}}' was not found in package '{{ package_name }}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n  {{ return(package_context[search_name]) }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9917226, "supported_languages": null}, "macro.dbt.snapshot_hash_arguments": {"name": "snapshot_hash_arguments", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.snapshot_hash_arguments", "macro_sql": "{% macro snapshot_hash_arguments(args) -%}\n  {{ adapter.dispatch('snapshot_hash_arguments', 'dbt')(args) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__snapshot_hash_arguments"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9920113, "supported_languages": null}, "macro.dbt.default__snapshot_hash_arguments": {"name": "default__snapshot_hash_arguments", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.default__snapshot_hash_arguments", "macro_sql": "{% macro default__snapshot_hash_arguments(args) -%}\n    md5({%- for arg in args -%}\n        coalesce(cast({{ arg }} as varchar ), '')\n        {% if not loop.last %} || '|' || {% endif %}\n    {%- endfor -%})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.992388, "supported_languages": null}, "macro.dbt.snapshot_timestamp_strategy": {"name": "snapshot_timestamp_strategy", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.snapshot_timestamp_strategy", "macro_sql": "{% macro snapshot_timestamp_strategy(node, snapshotted_rel, current_rel, model_config, target_exists) %}\n    {# The model_config parameter is no longer used, but is passed in anyway for compatibility. #}\n    {% set primary_key = config.get('unique_key') %}\n    {% set updated_at = config.get('updated_at') %}\n    {% set hard_deletes = adapter.get_hard_deletes_behavior(config) %}\n    {% set invalidate_hard_deletes = hard_deletes == 'invalidate' %}\n    {% set columns = config.get(\"snapshot_table_column_names\") or get_snapshot_table_column_names() %}\n\n    {#/*\n        The snapshot relation might not have an {{ updated_at }} value if the\n        snapshot strategy is changed from `check` to `timestamp`. We\n        should use a dbt-created column for the comparison in the snapshot\n        table instead of assuming that the user-supplied {{ updated_at }}\n        will be present in the historical data.\n\n        See https://github.com/dbt-labs/dbt-core/issues/2350\n    */ #}\n    {% set row_changed_expr -%}\n        ({{ snapshotted_rel }}.{{ columns.dbt_valid_from }} < {{ current_rel }}.{{ updated_at }})\n    {%- endset %}\n\n    {% set scd_args = api.Relation.scd_args(primary_key, updated_at) %}\n    {% set scd_id_expr = snapshot_hash_arguments(scd_args) %}\n\n    {% do return({\n        \"unique_key\": primary_key,\n        \"updated_at\": updated_at,\n        \"row_changed\": row_changed_expr,\n        \"scd_id\": scd_id_expr,\n        \"invalidate_hard_deletes\": invalidate_hard_deletes,\n        \"hard_deletes\": hard_deletes\n    }) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_snapshot_table_column_names", "macro.dbt.snapshot_hash_arguments"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9938955, "supported_languages": null}, "macro.dbt.snapshot_string_as_time": {"name": "snapshot_string_as_time", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.snapshot_string_as_time", "macro_sql": "{% macro snapshot_string_as_time(timestamp) -%}\n    {{ adapter.dispatch('snapshot_string_as_time', 'dbt')(timestamp) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__snapshot_string_as_time"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9941232, "supported_languages": null}, "macro.dbt.default__snapshot_string_as_time": {"name": "default__snapshot_string_as_time", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.default__snapshot_string_as_time", "macro_sql": "{% macro default__snapshot_string_as_time(timestamp) %}\n    {% do exceptions.raise_not_implemented(\n        'snapshot_string_as_time macro not implemented for adapter '+adapter.type()\n    ) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9943464, "supported_languages": null}, "macro.dbt.snapshot_check_all_get_existing_columns": {"name": "snapshot_check_all_get_existing_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.snapshot_check_all_get_existing_columns", "macro_sql": "{% macro snapshot_check_all_get_existing_columns(node, target_exists, check_cols_config) -%}\n    {%- if not target_exists -%}\n        {#-- no table yet -> return whatever the query does --#}\n        {{ return((false, query_columns)) }}\n    {%- endif -%}\n\n    {#-- handle any schema changes --#}\n    {%- set target_relation = adapter.get_relation(database=node.database, schema=node.schema, identifier=node.alias) -%}\n\n    {% if check_cols_config == 'all' %}\n        {%- set query_columns = get_columns_in_query(node['compiled_code']) -%}\n\n    {% elif check_cols_config is iterable and (check_cols_config | length) > 0 %}\n        {#-- query for proper casing/quoting, to support comparison below --#}\n        {%- set select_check_cols_from_target -%}\n            {#-- N.B. The whitespace below is necessary to avoid edge case issue with comments --#}\n            {#-- See: https://github.com/dbt-labs/dbt-core/issues/6781 --#}\n            select {{ check_cols_config | join(', ') }} from (\n                {{ node['compiled_code'] }}\n            ) subq\n        {%- endset -%}\n        {% set query_columns = get_columns_in_query(select_check_cols_from_target) %}\n\n    {% else %}\n        {% do exceptions.raise_compiler_error(\"Invalid value for 'check_cols': \" ~ check_cols_config) %}\n    {% endif %}\n\n    {%- set existing_cols = adapter.get_columns_in_relation(target_relation) | map(attribute = 'name') | list -%}\n    {%- set ns = namespace() -%} {#-- handle for-loop scoping with a namespace --#}\n    {%- set ns.column_added = false -%}\n\n    {%- set intersection = [] -%}\n    {%- for col in query_columns -%}\n        {%- if col in existing_cols -%}\n            {%- do intersection.append(adapter.quote(col)) -%}\n        {%- else -%}\n            {% set ns.column_added = true %}\n        {%- endif -%}\n    {%- endfor -%}\n    {{ return((ns.column_added, intersection)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_columns_in_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9963894, "supported_languages": null}, "macro.dbt.snapshot_check_strategy": {"name": "snapshot_check_strategy", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/strategies.sql", "original_file_path": "macros/materializations/snapshots/strategies.sql", "unique_id": "macro.dbt.snapshot_check_strategy", "macro_sql": "{% macro snapshot_check_strategy(node, snapshotted_rel, current_rel, model_config, target_exists) %}\n    {# The model_config parameter is no longer used, but is passed in anyway for compatibility. #}\n    {% set check_cols_config = config.get('check_cols') %}\n    {% set primary_key = config.get('unique_key') %}\n    {% set hard_deletes = adapter.get_hard_deletes_behavior(config) %}\n    {% set invalidate_hard_deletes = hard_deletes == 'invalidate' %}\n    {% set updated_at = config.get('updated_at') or snapshot_get_time() %}\n\n    {% set column_added = false %}\n\n    {% set column_added, check_cols = snapshot_check_all_get_existing_columns(node, target_exists, check_cols_config) %}\n\n    {%- set row_changed_expr -%}\n    (\n    {%- if column_added -%}\n        {{ get_true_sql() }}\n    {%- else -%}\n    {%- for col in check_cols -%}\n        {{ snapshotted_rel }}.{{ col }} != {{ current_rel }}.{{ col }}\n        or\n        (\n            (({{ snapshotted_rel }}.{{ col }} is null) and not ({{ current_rel }}.{{ col }} is null))\n            or\n            ((not {{ snapshotted_rel }}.{{ col }} is null) and ({{ current_rel }}.{{ col }} is null))\n        )\n        {%- if not loop.last %} or {% endif -%}\n    {%- endfor -%}\n    {%- endif -%}\n    )\n    {%- endset %}\n\n    {% set scd_args = api.Relation.scd_args(primary_key, updated_at) %}\n    {% set scd_id_expr = snapshot_hash_arguments(scd_args) %}\n\n    {% do return({\n        \"unique_key\": primary_key,\n        \"updated_at\": updated_at,\n        \"row_changed\": row_changed_expr,\n        \"scd_id\": scd_id_expr,\n        \"invalidate_hard_deletes\": invalidate_hard_deletes,\n        \"hard_deletes\": hard_deletes\n    }) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.snapshot_get_time", "macro.dbt.snapshot_check_all_get_existing_columns", "macro.dbt.get_true_sql", "macro.dbt.snapshot_hash_arguments"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9985797, "supported_languages": null}, "macro.dbt.snapshot_merge_sql": {"name": "snapshot_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/snapshot_merge.sql", "original_file_path": "macros/materializations/snapshots/snapshot_merge.sql", "unique_id": "macro.dbt.snapshot_merge_sql", "macro_sql": "{% macro snapshot_merge_sql(target, source, insert_cols) -%}\n  {{ adapter.dispatch('snapshot_merge_sql', 'dbt')(target, source, insert_cols) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__snapshot_merge_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132013.9991548, "supported_languages": null}, "macro.dbt.default__snapshot_merge_sql": {"name": "default__snapshot_merge_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/snapshot_merge.sql", "original_file_path": "macros/materializations/snapshots/snapshot_merge.sql", "unique_id": "macro.dbt.default__snapshot_merge_sql", "macro_sql": "{% macro default__snapshot_merge_sql(target, source, insert_cols) -%}\n    {%- set insert_cols_csv = insert_cols | join(', ') -%}\n\n    {%- set columns = config.get(\"snapshot_table_column_names\") or get_snapshot_table_column_names() -%}\n\n    merge into {{ target.render() }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n    on DBT_INTERNAL_SOURCE.{{ columns.dbt_scd_id }} = DBT_INTERNAL_DEST.{{ columns.dbt_scd_id }}\n\n    when matched\n     {% if config.get(\"dbt_valid_to_current\") %}\n\t{% set source_unique_key = (\"DBT_INTERNAL_DEST.\" ~ columns.dbt_valid_to) | trim %}\n\t{% set target_unique_key = config.get('dbt_valid_to_current') | trim %}\n\tand ({{ equals(source_unique_key, target_unique_key) }} or {{ source_unique_key }} is null)\n\n     {% else %}\n       and DBT_INTERNAL_DEST.{{ columns.dbt_valid_to }} is null\n     {% endif %}\n     and DBT_INTERNAL_SOURCE.dbt_change_type in ('update', 'delete')\n        then update\n        set {{ columns.dbt_valid_to }} = DBT_INTERNAL_SOURCE.{{ columns.dbt_valid_to }}\n\n    when not matched\n     and DBT_INTERNAL_SOURCE.dbt_change_type = 'insert'\n        then insert ({{ insert_cols_csv }})\n        values ({{ insert_cols_csv }})\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_snapshot_table_column_names", "macro.dbt.equals"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0005136, "supported_languages": null}, "macro.dbt.create_columns": {"name": "create_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.create_columns", "macro_sql": "{% macro create_columns(relation, columns) %}\n  {{ adapter.dispatch('create_columns', 'dbt')(relation, columns) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__create_columns"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0030751, "supported_languages": null}, "macro.dbt.default__create_columns": {"name": "default__create_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.default__create_columns", "macro_sql": "{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation.render() }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0034754, "supported_languages": null}, "macro.dbt.post_snapshot": {"name": "post_snapshot", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.post_snapshot", "macro_sql": "{% macro post_snapshot(staging_relation) %}\n  {{ adapter.dispatch('post_snapshot', 'dbt')(staging_relation) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__post_snapshot"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.003702, "supported_languages": null}, "macro.dbt.default__post_snapshot": {"name": "default__post_snapshot", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.default__post_snapshot", "macro_sql": "{% macro default__post_snapshot(staging_relation) %}\n    {# no-op #}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0038254, "supported_languages": null}, "macro.dbt.get_true_sql": {"name": "get_true_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.get_true_sql", "macro_sql": "{% macro get_true_sql() %}\n  {{ adapter.dispatch('get_true_sql', 'dbt')() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_true_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0040178, "supported_languages": null}, "macro.dbt.default__get_true_sql": {"name": "default__get_true_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.default__get_true_sql", "macro_sql": "{% macro default__get_true_sql() %}\n    {{ return('TRUE') }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0041761, "supported_languages": null}, "macro.dbt.snapshot_staging_table": {"name": "snapshot_staging_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.snapshot_staging_table", "macro_sql": "{% macro snapshot_staging_table(strategy, source_sql, target_relation) -%}\n  {{ adapter.dispatch('snapshot_staging_table', 'dbt')(strategy, source_sql, target_relation) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__snapshot_staging_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.00444, "supported_languages": null}, "macro.dbt.get_snapshot_table_column_names": {"name": "get_snapshot_table_column_names", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.get_snapshot_table_column_names", "macro_sql": "{% macro get_snapshot_table_column_names() %}\n    {{ return({'dbt_valid_to': 'dbt_valid_to', 'dbt_valid_from': 'dbt_valid_from', 'dbt_scd_id': 'dbt_scd_id', 'dbt_updated_at': 'dbt_updated_at', 'dbt_is_deleted': 'dbt_is_deleted'}) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0047555, "supported_languages": null}, "macro.dbt.default__snapshot_staging_table": {"name": "default__snapshot_staging_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.default__snapshot_staging_table", "macro_sql": "{% macro default__snapshot_staging_table(strategy, source_sql, target_relation) -%}\n    {% set columns = config.get('snapshot_table_column_names') or get_snapshot_table_column_names() %}\n    {% if strategy.hard_deletes == 'new_record' %}\n        {% set new_scd_id = snapshot_hash_arguments([columns.dbt_scd_id, snapshot_get_time()]) %}\n    {% endif %}\n    with snapshot_query as (\n\n        {{ source_sql }}\n\n    ),\n\n    snapshotted_data as (\n\n        select *, {{ unique_key_fields(strategy.unique_key) }}\n        from {{ target_relation }}\n        where\n            {% if config.get('dbt_valid_to_current') %}\n\t\t{% set source_unique_key = columns.dbt_valid_to | trim %}\n\t\t{% set target_unique_key = config.get('dbt_valid_to_current') | trim %}\n\n\t\t{# The exact equals semantics between NULL values depends on the current behavior flag set. Also, update records if the source field is null #}\n                ( {{ equals(source_unique_key, target_unique_key) }} or {{ source_unique_key }} is null )\n            {% else %}\n                {{ columns.dbt_valid_to }} is null\n            {% endif %}\n\n    ),\n\n    insertions_source_data as (\n\n        select *, {{ unique_key_fields(strategy.unique_key) }},\n            {{ strategy.updated_at }} as {{ columns.dbt_updated_at }},\n            {{ strategy.updated_at }} as {{ columns.dbt_valid_from }},\n            {{ get_dbt_valid_to_current(strategy, columns) }},\n            {{ strategy.scd_id }} as {{ columns.dbt_scd_id }}\n\n        from snapshot_query\n    ),\n\n    updates_source_data as (\n\n        select *, {{ unique_key_fields(strategy.unique_key) }},\n            {{ strategy.updated_at }} as {{ columns.dbt_updated_at }},\n            {{ strategy.updated_at }} as {{ columns.dbt_valid_from }},\n            {{ strategy.updated_at }} as {{ columns.dbt_valid_to }}\n\n        from snapshot_query\n    ),\n\n    {%- if strategy.hard_deletes == 'invalidate' or strategy.hard_deletes == 'new_record' %}\n\n    deletes_source_data as (\n\n        select *, {{ unique_key_fields(strategy.unique_key) }}\n        from snapshot_query\n    ),\n    {% endif %}\n\n    insertions as (\n\n        select\n            'insert' as dbt_change_type,\n            source_data.*\n          {%- if strategy.hard_deletes == 'new_record' -%}\n            ,'False' as {{ columns.dbt_is_deleted }}\n          {%- endif %}\n\n        from insertions_source_data as source_data\n        left outer join snapshotted_data\n            on {{ unique_key_join_on(strategy.unique_key, \"snapshotted_data\", \"source_data\") }}\n            where {{ unique_key_is_null(strategy.unique_key, \"snapshotted_data\") }}\n            or ({{ unique_key_is_not_null(strategy.unique_key, \"snapshotted_data\") }} and ({{ strategy.row_changed }})\n\n        )\n\n    ),\n\n    updates as (\n\n        select\n            'update' as dbt_change_type,\n            source_data.*,\n            snapshotted_data.{{ columns.dbt_scd_id }}\n          {%- if strategy.hard_deletes == 'new_record' -%}\n            , snapshotted_data.{{ columns.dbt_is_deleted }}\n          {%- endif %}\n\n        from updates_source_data as source_data\n        join snapshotted_data\n            on {{ unique_key_join_on(strategy.unique_key, \"snapshotted_data\", \"source_data\") }}\n        where (\n            {{ strategy.row_changed }}\n        )\n    )\n\n    {%- if strategy.hard_deletes == 'invalidate' or strategy.hard_deletes == 'new_record' %}\n    ,\n    deletes as (\n\n        select\n            'delete' as dbt_change_type,\n            source_data.*,\n            {{ snapshot_get_time() }} as {{ columns.dbt_valid_from }},\n            {{ snapshot_get_time() }} as {{ columns.dbt_updated_at }},\n            {{ snapshot_get_time() }} as {{ columns.dbt_valid_to }},\n            snapshotted_data.{{ columns.dbt_scd_id }}\n          {%- if strategy.hard_deletes == 'new_record' -%}\n            , snapshotted_data.{{ columns.dbt_is_deleted }}\n          {%- endif %}\n        from snapshotted_data\n        left join deletes_source_data as source_data\n            on {{ unique_key_join_on(strategy.unique_key, \"snapshotted_data\", \"source_data\") }}\n            where {{ unique_key_is_null(strategy.unique_key, \"source_data\") }}\n    )\n    {%- endif %}\n\n    {%- if strategy.hard_deletes == 'new_record' %}\n        {% set source_sql_cols = get_column_schema_from_query(source_sql) %}\n    ,\n    deletion_records as (\n\n        select\n            'insert' as dbt_change_type,\n            {%- for col in source_sql_cols -%}\n            snapshotted_data.{{ adapter.quote(col.column) }},\n            {% endfor -%}\n            {%- if strategy.unique_key | is_list -%}\n                {%- for key in strategy.unique_key -%}\n            snapshotted_data.{{ key }} as dbt_unique_key_{{ loop.index }},\n                {% endfor -%}\n            {%- else -%}\n            snapshotted_data.dbt_unique_key as dbt_unique_key,\n            {% endif -%}\n            {{ snapshot_get_time() }} as {{ columns.dbt_valid_from }},\n            {{ snapshot_get_time() }} as {{ columns.dbt_updated_at }},\n            snapshotted_data.{{ columns.dbt_valid_to }} as {{ columns.dbt_valid_to }},\n            {{ new_scd_id }} as {{ columns.dbt_scd_id }},\n            'True' as {{ columns.dbt_is_deleted }}\n        from snapshotted_data\n        left join deletes_source_data as source_data\n            on {{ unique_key_join_on(strategy.unique_key, \"snapshotted_data\", \"source_data\") }}\n        where {{ unique_key_is_null(strategy.unique_key, \"source_data\") }}\n\n    )\n    {%- endif %}\n\n    select * from insertions\n    union all\n    select * from updates\n    {%- if strategy.hard_deletes == 'invalidate' or strategy.hard_deletes == 'new_record' %}\n    union all\n    select * from deletes\n    {%- endif %}\n    {%- if strategy.hard_deletes == 'new_record' %}\n    union all\n    select * from deletion_records\n    {%- endif %}\n\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_snapshot_table_column_names", "macro.dbt.snapshot_hash_arguments", "macro.dbt.snapshot_get_time", "macro.dbt.unique_key_fields", "macro.dbt.equals", "macro.dbt.get_dbt_valid_to_current", "macro.dbt.unique_key_join_on", "macro.dbt.unique_key_is_null", "macro.dbt.unique_key_is_not_null", "macro.dbt.get_column_schema_from_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0097415, "supported_languages": null}, "macro.dbt.build_snapshot_table": {"name": "build_snapshot_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.build_snapshot_table", "macro_sql": "{% macro build_snapshot_table(strategy, sql) -%}\n  {{ adapter.dispatch('build_snapshot_table', 'dbt')(strategy, sql) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__build_snapshot_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0100443, "supported_languages": null}, "macro.dbt.default__build_snapshot_table": {"name": "default__build_snapshot_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.default__build_snapshot_table", "macro_sql": "{% macro default__build_snapshot_table(strategy, sql) %}\n    {% set columns = config.get('snapshot_table_column_names') or get_snapshot_table_column_names() %}\n\n    select *,\n        {{ strategy.scd_id }} as {{ columns.dbt_scd_id }},\n        {{ strategy.updated_at }} as {{ columns.dbt_updated_at }},\n        {{ strategy.updated_at }} as {{ columns.dbt_valid_from }},\n        {{ get_dbt_valid_to_current(strategy, columns) }}\n      {%- if strategy.hard_deletes == 'new_record' -%}\n        , 'False' as {{ columns.dbt_is_deleted }}\n      {% endif -%}\n    from (\n        {{ sql }}\n    ) sbq\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_snapshot_table_column_names", "macro.dbt.get_dbt_valid_to_current"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0107188, "supported_languages": null}, "macro.dbt.build_snapshot_staging_table": {"name": "build_snapshot_staging_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.build_snapshot_staging_table", "macro_sql": "{% macro build_snapshot_staging_table(strategy, sql, target_relation) %}\n    {% set temp_relation = make_temp_relation(target_relation) %}\n\n    {% set select = snapshot_staging_table(strategy, sql, target_relation) %}\n\n    {% call statement('build_snapshot_staging_relation') %}\n        {{ create_table_as(True, temp_relation, select) }}\n    {% endcall %}\n\n    {% do return(temp_relation) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.make_temp_relation", "macro.dbt.snapshot_staging_table", "macro.dbt.statement", "macro.dbt.create_table_as"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0112782, "supported_languages": null}, "macro.dbt.get_updated_at_column_data_type": {"name": "get_updated_at_column_data_type", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.get_updated_at_column_data_type", "macro_sql": "{% macro get_updated_at_column_data_type(snapshot_sql) %}\n    {% set snapshot_sql_column_schema = get_column_schema_from_query(snapshot_sql) %}\n    {% set dbt_updated_at_data_type = null %}\n    {% set ns = namespace() -%} {#-- handle for-loop scoping with a namespace --#}\n    {% set ns.dbt_updated_at_data_type = null -%}\n    {% for column in snapshot_sql_column_schema %}\n    {%   if ((column.column == 'dbt_updated_at') or (column.column == 'DBT_UPDATED_AT')) %}\n    {%     set ns.dbt_updated_at_data_type = column.dtype %}\n    {%   endif %}\n    {% endfor %}\n    {{ return(ns.dbt_updated_at_data_type or none)  }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_column_schema_from_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0122085, "supported_languages": null}, "macro.dbt.check_time_data_types": {"name": "check_time_data_types", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.check_time_data_types", "macro_sql": "{% macro check_time_data_types(sql) %}\n  {% set dbt_updated_at_data_type = get_updated_at_column_data_type(sql) %}\n  {% set snapshot_get_time_data_type = get_snapshot_get_time_data_type() %}\n  {% if snapshot_get_time_data_type is not none and dbt_updated_at_data_type is not none and snapshot_get_time_data_type != dbt_updated_at_data_type %}\n  {%   if exceptions.warn_snapshot_timestamp_data_types %}\n  {{     exceptions.warn_snapshot_timestamp_data_types(snapshot_get_time_data_type, dbt_updated_at_data_type) }}\n  {%   endif %}\n  {% endif %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_updated_at_column_data_type", "macro.dbt.get_snapshot_get_time_data_type"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0129163, "supported_languages": null}, "macro.dbt.get_dbt_valid_to_current": {"name": "get_dbt_valid_to_current", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.get_dbt_valid_to_current", "macro_sql": "{% macro get_dbt_valid_to_current(strategy, columns) %}\n  {% set dbt_valid_to_current = config.get('dbt_valid_to_current') or \"null\" %}\n  coalesce(nullif({{ strategy.updated_at }}, {{ strategy.updated_at }}), {{dbt_valid_to_current}})\n  as {{ columns.dbt_valid_to }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0133786, "supported_languages": null}, "macro.dbt.unique_key_fields": {"name": "unique_key_fields", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.unique_key_fields", "macro_sql": "{% macro unique_key_fields(unique_key) %}\n    {% if unique_key | is_list %}\n        {% for key in unique_key %}\n            {{ key }} as dbt_unique_key_{{ loop.index }}\n            {%- if not loop.last %} , {%- endif %}\n        {% endfor %}\n    {% else %}\n        {{ unique_key }} as dbt_unique_key\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0139844, "supported_languages": null}, "macro.dbt.unique_key_join_on": {"name": "unique_key_join_on", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.unique_key_join_on", "macro_sql": "{% macro unique_key_join_on(unique_key, identifier, from_identifier) %}\n    {% if unique_key | is_list %}\n        {% for key in unique_key %}\n\t    {% set source_unique_key = (identifier ~ \".dbt_unique_key_\" ~ loop.index) | trim %}\n\t    {% set target_unique_key = (from_identifier ~ \".dbt_unique_key_\" ~ loop.index) | trim %}\n\t    {{ equals(source_unique_key, target_unique_key) }}\n            {%- if not loop.last %} and {%- endif %}\n        {% endfor %}\n    {% else %}\n        {{ identifier }}.dbt_unique_key = {{ from_identifier }}.dbt_unique_key\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.equals"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0149531, "supported_languages": null}, "macro.dbt.unique_key_is_null": {"name": "unique_key_is_null", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.unique_key_is_null", "macro_sql": "{% macro unique_key_is_null(unique_key, identifier) %}\n    {% if unique_key | is_list %}\n        {{ identifier }}.dbt_unique_key_1 is null\n    {% else %}\n        {{ identifier }}.dbt_unique_key is null\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0153074, "supported_languages": null}, "macro.dbt.unique_key_is_not_null": {"name": "unique_key_is_not_null", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/helpers.sql", "original_file_path": "macros/materializations/snapshots/helpers.sql", "unique_id": "macro.dbt.unique_key_is_not_null", "macro_sql": "{% macro unique_key_is_not_null(unique_key, identifier) %}\n    {% if unique_key | is_list %}\n        {{ identifier }}.dbt_unique_key_1 is not null\n    {% else %}\n        {{ identifier }}.dbt_unique_key is not null\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0156646, "supported_languages": null}, "macro.dbt.materialization_snapshot_default": {"name": "materialization_snapshot_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/snapshots/snapshot.sql", "original_file_path": "macros/materializations/snapshots/snapshot.sql", "unique_id": "macro.dbt.materialization_snapshot_default", "macro_sql": "{% materialization snapshot, default %}\n\n  {%- set target_table = model.get('alias', model.get('name')) -%}\n\n  {%- set strategy_name = config.get('strategy') -%}\n  {%- set unique_key = config.get('unique_key') %}\n  -- grab current tables grants config for comparision later on\n  {%- set grant_config = config.get('grants') -%}\n\n  {% set target_relation_exists, target_relation = get_or_create_relation(\n          database=model.database,\n          schema=model.schema,\n          identifier=target_table,\n          type='table') -%}\n\n  {%- if not target_relation.is_table -%}\n    {% do exceptions.relation_wrong_type(target_relation, 'table') %}\n  {%- endif -%}\n\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  {% set strategy_macro = strategy_dispatch(strategy_name) %}\n  {# The model['config'] parameter below is no longer used, but passing anyway for compatibility #}\n  {# It was a dictionary of config, instead of the config object from the context #}\n  {% set strategy = strategy_macro(model, \"snapshotted_data\", \"source_data\", model['config'], target_relation_exists) %}\n\n  {% if not target_relation_exists %}\n\n      {% set build_sql = build_snapshot_table(strategy, model['compiled_code']) %}\n      {% set build_or_select_sql = build_sql %}\n      {% set final_sql = create_table_as(False, target_relation, build_sql) %}\n\n  {% else %}\n\n      {% set columns = config.get(\"snapshot_table_column_names\") or get_snapshot_table_column_names() %}\n\n      {{ adapter.assert_valid_snapshot_target_given_strategy(target_relation, columns, strategy) }}\n\n      {% set build_or_select_sql = snapshot_staging_table(strategy, sql, target_relation) %}\n      {% set staging_table = build_snapshot_staging_table(strategy, sql, target_relation) %}\n\n      -- this may no-op if the database does not require column expansion\n      {% do adapter.expand_target_column_types(from_relation=staging_table,\n                                               to_relation=target_relation) %}\n\n      {% set remove_columns = ['dbt_change_type', 'DBT_CHANGE_TYPE', 'dbt_unique_key', 'DBT_UNIQUE_KEY'] %}\n      {% if unique_key | is_list %}\n          {% for key in strategy.unique_key %}\n              {{ remove_columns.append('dbt_unique_key_' + loop.index|string) }}\n              {{ remove_columns.append('DBT_UNIQUE_KEY_' + loop.index|string) }}\n          {% endfor %}\n      {% endif %}\n\n      {% set missing_columns = adapter.get_missing_columns(staging_table, target_relation)\n                                   | rejectattr('name', 'in', remove_columns)\n                                   | list %}\n\n      {% do create_columns(target_relation, missing_columns) %}\n\n      {% set source_columns = adapter.get_columns_in_relation(staging_table)\n                                   | rejectattr('name', 'in', remove_columns)\n                                   | list %}\n\n      {% set quoted_source_columns = [] %}\n      {% for column in source_columns %}\n        {% do quoted_source_columns.append(adapter.quote(column.name)) %}\n      {% endfor %}\n\n      {% set final_sql = snapshot_merge_sql(\n            target = target_relation,\n            source = staging_table,\n            insert_cols = quoted_source_columns\n         )\n      %}\n\n  {% endif %}\n\n\n  {{ check_time_data_types(build_or_select_sql) }}\n\n  {% call statement('main') %}\n      {{ final_sql }}\n  {% endcall %}\n\n  {% set should_revoke = should_revoke(target_relation_exists, full_refresh_mode=False) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {% do persist_docs(target_relation, model) %}\n\n  {% if not target_relation_exists %}\n    {% do create_indexes(target_relation) %}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {{ adapter.commit() }}\n\n  {% if staging_table is defined %}\n      {% do post_snapshot(staging_table) %}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n  {{ return({'relations': [target_relation]}) }}\n\n{% endmaterialization %}", "depends_on": {"macros": ["macro.dbt.get_or_create_relation", "macro.dbt.run_hooks", "macro.dbt.strategy_dispatch", "macro.dbt.build_snapshot_table", "macro.dbt.create_table_as", "macro.dbt.get_snapshot_table_column_names", "macro.dbt.snapshot_staging_table", "macro.dbt.build_snapshot_staging_table", "macro.dbt.create_columns", "macro.dbt.snapshot_merge_sql", "macro.dbt.check_time_data_types", "macro.dbt.statement", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs", "macro.dbt.create_indexes", "macro.dbt.post_snapshot"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0224671, "supported_languages": ["sql"]}, "macro.dbt.materialization_seed_default": {"name": "materialization_seed_default", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/seed.sql", "original_file_path": "macros/materializations/seeds/seed.sql", "unique_id": "macro.dbt.materialization_seed_default", "macro_sql": "{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (should_full_refresh()) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set grant_config = config.get('grants') -%}\n  {%- set agate_table = load_agate_table() -%}\n  -- grab current tables grants config for comparison later on\n\n  {%- do store_result('agate_table', response='OK', agate_table=agate_table) -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation.render())) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation, agate_table) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model, agate_table) %}\n  {% endif %}\n\n  {% set code = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set rows_affected = (agate_table.rows | length) %}\n  {% set sql = load_csv_rows(model, agate_table) %}\n\n  {% call noop_statement('main', code ~ ' ' ~ rows_affected, code, rows_affected) %}\n    {{ get_csv_sql(create_table_sql, sql) }};\n  {% endcall %}\n\n  {% set target_relation = this.incorporate(type='table') %}\n\n  {% set should_revoke = should_revoke(old_relation, full_refresh_mode) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {% do persist_docs(target_relation, model) %}\n\n  {% if full_refresh_mode or not exists_as_table %}\n    {% do create_indexes(target_relation) %}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n  {{ return({'relations': [target_relation]}) }}\n\n{% endmaterialization %}", "depends_on": {"macros": ["macro.dbt.should_full_refresh", "macro.dbt.run_hooks", "macro.dbt.reset_csv_table", "macro.dbt.create_csv_table", "macro.dbt.load_csv_rows", "macro.dbt.noop_statement", "macro.dbt.get_csv_sql", "macro.dbt.should_revoke", "macro.dbt.apply_grants", "macro.dbt.persist_docs", "macro.dbt.create_indexes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0263941, "supported_languages": ["sql"]}, "macro.dbt.create_csv_table": {"name": "create_csv_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.create_csv_table", "macro_sql": "{% macro create_csv_table(model, agate_table) -%}\n  {{ adapter.dispatch('create_csv_table', 'dbt')(model, agate_table) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__create_csv_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0275993, "supported_languages": null}, "macro.dbt.default__create_csv_table": {"name": "default__create_csv_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__create_csv_table", "macro_sql": "{% macro default__create_csv_table(model, agate_table) %}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n  {%- set quote_seed_column = model['config'].get('quote_columns', None) -%}\n\n  {% set sql %}\n    create table {{ this.render() }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {%- set column_name = (col_name | string) -%}\n            {{ adapter.quote_seed_column(column_name, quote_seed_column) }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0287535, "supported_languages": null}, "macro.dbt.reset_csv_table": {"name": "reset_csv_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.reset_csv_table", "macro_sql": "{% macro reset_csv_table(model, full_refresh, old_relation, agate_table) -%}\n  {{ adapter.dispatch('reset_csv_table', 'dbt')(model, full_refresh, old_relation, agate_table) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__reset_csv_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.029049, "supported_languages": null}, "macro.dbt.default__reset_csv_table": {"name": "default__reset_csv_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__reset_csv_table", "macro_sql": "{% macro default__reset_csv_table(model, full_refresh, old_relation, agate_table) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model, agate_table) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation.render() %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.create_csv_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.029803, "supported_languages": null}, "macro.dbt.get_csv_sql": {"name": "get_csv_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.get_csv_sql", "macro_sql": "{% macro get_csv_sql(create_or_truncate_sql, insert_sql) %}\n    {{ adapter.dispatch('get_csv_sql', 'dbt')(create_or_truncate_sql, insert_sql) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_csv_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.030122, "supported_languages": null}, "macro.dbt.default__get_csv_sql": {"name": "default__get_csv_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__get_csv_sql", "macro_sql": "{% macro default__get_csv_sql(create_or_truncate_sql, insert_sql) %}\n    {{ create_or_truncate_sql }};\n    -- dbt seed --\n    {{ insert_sql }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0303457, "supported_languages": null}, "macro.dbt.get_binding_char": {"name": "get_binding_char", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.get_binding_char", "macro_sql": "{% macro get_binding_char() -%}\n  {{ adapter.dispatch('get_binding_char', 'dbt')() }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_binding_char"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0305765, "supported_languages": null}, "macro.dbt.default__get_binding_char": {"name": "default__get_binding_char", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__get_binding_char", "macro_sql": "{% macro default__get_binding_char() %}\n  {{ return('%s') }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.030767, "supported_languages": null}, "macro.dbt.get_batch_size": {"name": "get_batch_size", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.get_batch_size", "macro_sql": "{% macro get_batch_size() -%}\n  {{ return(adapter.dispatch('get_batch_size', 'dbt')()) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_batch_size"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0310318, "supported_languages": null}, "macro.dbt.default__get_batch_size": {"name": "default__get_batch_size", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__get_batch_size", "macro_sql": "{% macro default__get_batch_size() %}\n  {{ return(10000) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0312278, "supported_languages": null}, "macro.dbt.get_seed_column_quoted_csv": {"name": "get_seed_column_quoted_csv", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.get_seed_column_quoted_csv", "macro_sql": "{% macro get_seed_column_quoted_csv(model, column_names) %}\n  {%- set quote_seed_column = model['config'].get('quote_columns', None) -%}\n    {% set quoted = [] %}\n    {% for col in column_names -%}\n        {%- do quoted.append(adapter.quote_seed_column(col, quote_seed_column)) -%}\n    {%- endfor %}\n\n    {%- set dest_cols_csv = quoted | join(', ') -%}\n    {{ return(dest_cols_csv) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.032037, "supported_languages": null}, "macro.dbt.load_csv_rows": {"name": "load_csv_rows", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.load_csv_rows", "macro_sql": "{% macro load_csv_rows(model, agate_table) -%}\n  {{ adapter.dispatch('load_csv_rows', 'dbt')(model, agate_table) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__load_csv_rows"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0323422, "supported_languages": null}, "macro.dbt.default__load_csv_rows": {"name": "default__load_csv_rows", "resource_type": "macro", "package_name": "dbt", "path": "macros/materializations/seeds/helpers.sql", "original_file_path": "macros/materializations/seeds/helpers.sql", "unique_id": "macro.dbt.default__load_csv_rows", "macro_sql": "{% macro default__load_csv_rows(model, agate_table) %}\n\n  {% set batch_size = get_batch_size() %}\n\n  {% set cols_sql = get_seed_column_quoted_csv(model, agate_table.column_names) %}\n  {% set bindings = [] %}\n\n  {% set statements = [] %}\n\n  {% for chunk in agate_table.rows | batch(batch_size) %}\n      {% set bindings = [] %}\n\n      {% for row in chunk %}\n          {% do bindings.extend(row) %}\n      {% endfor %}\n\n      {% set sql %}\n          insert into {{ this.render() }} ({{ cols_sql }}) values\n          {% for row in chunk -%}\n              ({%- for column in agate_table.column_names -%}\n                  {{ get_binding_char() }}\n                  {%- if not loop.last%},{%- endif %}\n              {%- endfor -%})\n              {%- if not loop.last%},{%- endif %}\n          {%- endfor %}\n      {% endset %}\n\n      {% do adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n      {% if loop.index0 == 0 %}\n          {% do statements.append(sql) %}\n      {% endif %}\n  {% endfor %}\n\n  {# Return SQL so we can render it out into the compiled files #}\n  {{ return(statements[0]) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_batch_size", "macro.dbt.get_seed_column_quoted_csv", "macro.dbt.get_binding_char"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0344489, "supported_languages": null}, "macro.dbt.statement": {"name": "statement", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/statement.sql", "original_file_path": "macros/etc/statement.sql", "unique_id": "macro.dbt.statement", "macro_sql": "\n{%- macro statement(name=None, fetch_result=False, auto_begin=True, language='sql') -%}\n  {%- if execute: -%}\n    {%- set compiled_code = caller() -%}\n\n    {%- if name == 'main' -%}\n      {{ log('Writing runtime {} for node \"{}\"'.format(language, model['unique_id'])) }}\n      {{ write(compiled_code) }}\n    {%- endif -%}\n    {%- if language == 'sql'-%}\n      {%- set res, table = adapter.execute(compiled_code, auto_begin=auto_begin, fetch=fetch_result) -%}\n    {%- elif language == 'python' -%}\n      {%- set res = submit_python_job(model, compiled_code) -%}\n      {#-- TODO: What should table be for python models? --#}\n      {%- set table = None -%}\n    {%- else -%}\n      {% do exceptions.raise_compiler_error(\"statement macro didn't get supported language\") %}\n    {%- endif -%}\n\n    {%- if name is not none -%}\n      {{ store_result(name, response=res, agate_table=table) }}\n    {%- endif -%}\n\n  {%- endif -%}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0362988, "supported_languages": null}, "macro.dbt.noop_statement": {"name": "noop_statement", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/statement.sql", "original_file_path": "macros/etc/statement.sql", "unique_id": "macro.dbt.noop_statement", "macro_sql": "{% macro noop_statement(name=None, message=None, code=None, rows_affected=None, res=None) -%}\n  {%- set sql = caller() -%}\n\n  {%- if name == 'main' -%}\n    {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n    {{ write(sql) }}\n  {%- endif -%}\n\n  {%- if name is not none -%}\n    {{ store_raw_result(name, message=message, code=code, rows_affected=rows_affected, agate_table=res) }}\n  {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.037263, "supported_languages": null}, "macro.dbt.run_query": {"name": "run_query", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/statement.sql", "original_file_path": "macros/etc/statement.sql", "unique_id": "macro.dbt.run_query", "macro_sql": "{% macro run_query(sql) %}\n  {% call statement(\"run_query_statement\", fetch_result=true, auto_begin=false) %}\n    {{ sql }}\n  {% endcall %}\n\n  {% do return(load_result(\"run_query_statement\").table) %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.037689, "supported_languages": null}, "macro.dbt.convert_datetime": {"name": "convert_datetime", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.convert_datetime", "macro_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0385985, "supported_languages": null}, "macro.dbt.dates_in_range": {"name": "dates_in_range", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.dates_in_range", "macro_sql": "{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partition start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.convert_datetime"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.040117, "supported_languages": null}, "macro.dbt.partition_range": {"name": "partition_range", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.partition_range", "macro_sql": "{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.dates_in_range"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0410752, "supported_languages": null}, "macro.dbt.py_current_timestring": {"name": "py_current_timestring", "resource_type": "macro", "package_name": "dbt", "path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "unique_id": "macro.dbt.py_current_timestring", "macro_sql": "{% macro py_current_timestring() %}\n    {% set dt = modules.datetime.datetime.now() %}\n    {% do return(dt.strftime(\"%Y%m%d%H%M%S%f\")) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0413733, "supported_languages": null}, "macro.dbt.get_fixture_sql": {"name": "get_fixture_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/unit_test_sql/get_fixture_sql.sql", "original_file_path": "macros/unit_test_sql/get_fixture_sql.sql", "unique_id": "macro.dbt.get_fixture_sql", "macro_sql": "{% macro get_fixture_sql(rows, column_name_to_data_types) %}\n-- Fixture for {{ model.name }}\n{% set default_row = {} %}\n\n{%- if not column_name_to_data_types -%}\n{#-- Use defer_relation IFF it is available in the manifest and 'this' is missing from the database --#}\n{%-   set this_or_defer_relation = defer_relation if (defer_relation and not load_relation(this)) else this -%}\n{%-   set columns_in_relation = adapter.get_columns_in_relation(this_or_defer_relation) -%}\n\n{%-   set column_name_to_data_types = {} -%}\n{%-   for column in columns_in_relation -%}\n{#-- This needs to be a case-insensitive comparison --#}\n{%-     do column_name_to_data_types.update({column.name|lower: column.data_type}) -%}\n{%-   endfor -%}\n{%- endif -%}\n\n{%- if not column_name_to_data_types -%}\n    {{ exceptions.raise_compiler_error(\"Not able to get columns for unit test '\" ~ model.name ~ \"' from relation \" ~ this ~ \" because the relation doesn't exist\") }}\n{%- endif -%}\n\n{%- for column_name, column_type in column_name_to_data_types.items() -%}\n    {%- do default_row.update({column_name: (safe_cast(\"null\", column_type) | trim )}) -%}\n{%- endfor -%}\n\n{{ validate_fixture_rows(rows, row_number) }}\n\n{%- for row in rows -%}\n{%-   set formatted_row = format_row(row, column_name_to_data_types) -%}\n{%-   set default_row_copy = default_row.copy() -%}\n{%-   do default_row_copy.update(formatted_row) -%}\nselect\n{%-   for column_name, column_value in default_row_copy.items() %} {{ column_value }} as {{ column_name }}{% if not loop.last -%}, {%- endif %}\n{%-   endfor %}\n{%-   if not loop.last %}\nunion all\n{%    endif %}\n{%- endfor -%}\n\n{%- if (rows | length) == 0 -%}\n    select\n    {%- for column_name, column_value in default_row.items() %} {{ column_value }} as {{ column_name }}{% if not loop.last -%},{%- endif %}\n    {%- endfor %}\n    limit 0\n{%- endif -%}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.load_relation", "macro.dbt.safe_cast", "macro.dbt.validate_fixture_rows", "macro.dbt.format_row"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0444176, "supported_languages": null}, "macro.dbt.get_expected_sql": {"name": "get_expected_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/unit_test_sql/get_fixture_sql.sql", "original_file_path": "macros/unit_test_sql/get_fixture_sql.sql", "unique_id": "macro.dbt.get_expected_sql", "macro_sql": "{% macro get_expected_sql(rows, column_name_to_data_types) %}\n\n{%- if (rows | length) == 0 -%}\n    select * from dbt_internal_unit_test_actual\n    limit 0\n{%- else -%}\n{%- for row in rows -%}\n{%- set formatted_row = format_row(row, column_name_to_data_types) -%}\nselect\n{%- for column_name, column_value in formatted_row.items() %} {{ column_value }} as {{ column_name }}{% if not loop.last -%}, {%- endif %}\n{%- endfor %}\n{%- if not loop.last %}\nunion all\n{% endif %}\n{%- endfor -%}\n{%- endif -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.format_row"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0452242, "supported_languages": null}, "macro.dbt.format_row": {"name": "format_row", "resource_type": "macro", "package_name": "dbt", "path": "macros/unit_test_sql/get_fixture_sql.sql", "original_file_path": "macros/unit_test_sql/get_fixture_sql.sql", "unique_id": "macro.dbt.format_row", "macro_sql": "\n\n{%- macro format_row(row, column_name_to_data_types) -%}\n    {#-- generate case-insensitive formatted row --#}\n    {% set formatted_row = {} %}\n    {%- for column_name, column_value in row.items() -%}\n        {% set column_name = column_name|lower %}\n\n        {%- if column_name not in column_name_to_data_types %}\n            {#-- if user-provided row contains column name that relation does not contain, raise an error --#}\n            {% set fixture_name = \"expected output\" if model.resource_type == 'unit_test' else (\"'\" ~ model.name ~ \"'\") %}\n            {{ exceptions.raise_compiler_error(\n                \"Invalid column name: '\" ~ column_name ~ \"' in unit test fixture for \" ~ fixture_name ~ \".\"\n                \"\\nAccepted columns for \" ~ fixture_name ~ \" are: \" ~ (column_name_to_data_types.keys()|list)\n            ) }}\n        {%- endif -%}\n\n        {%- set column_type = column_name_to_data_types[column_name] %}\n\n        {#-- sanitize column_value: wrap yaml strings in quotes, apply cast --#}\n        {%- set column_value_clean = column_value -%}\n        {%- if column_value is string -%}\n            {%- set column_value_clean = dbt.string_literal(dbt.escape_single_quotes(column_value)) -%}\n        {%- elif column_value is none -%}\n            {%- set column_value_clean = 'null' -%}\n        {%- endif -%}\n\n        {%- set row_update = {column_name: safe_cast(column_value_clean, column_type) } -%}\n        {%- do formatted_row.update(row_update) -%}\n    {%- endfor -%}\n    {{ return(formatted_row) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.string_literal", "macro.dbt.escape_single_quotes", "macro.dbt.safe_cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0466678, "supported_languages": null}, "macro.dbt.validate_fixture_rows": {"name": "validate_fixture_rows", "resource_type": "macro", "package_name": "dbt", "path": "macros/unit_test_sql/get_fixture_sql.sql", "original_file_path": "macros/unit_test_sql/get_fixture_sql.sql", "unique_id": "macro.dbt.validate_fixture_rows", "macro_sql": "{%- macro validate_fixture_rows(rows, row_number) -%}\n  {{ return(adapter.dispatch('validate_fixture_rows', 'dbt')(rows, row_number)) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__validate_fixture_rows"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0469446, "supported_languages": null}, "macro.dbt.default__validate_fixture_rows": {"name": "default__validate_fixture_rows", "resource_type": "macro", "package_name": "dbt", "path": "macros/unit_test_sql/get_fixture_sql.sql", "original_file_path": "macros/unit_test_sql/get_fixture_sql.sql", "unique_id": "macro.dbt.default__validate_fixture_rows", "macro_sql": "{%- macro default__validate_fixture_rows(rows, row_number) -%}\n  {# This is an abstract method for adapter overrides as needed #}\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0470722, "supported_languages": null}, "macro.dbt.make_intermediate_relation": {"name": "make_intermediate_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.make_intermediate_relation", "macro_sql": "{% macro make_intermediate_relation(base_relation, suffix='__dbt_tmp') %}\n  {{ return(adapter.dispatch('make_intermediate_relation', 'dbt')(base_relation, suffix)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_intermediate_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0479424, "supported_languages": null}, "macro.dbt.default__make_intermediate_relation": {"name": "default__make_intermediate_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.default__make_intermediate_relation", "macro_sql": "{% macro default__make_intermediate_relation(base_relation, suffix) %}\n    {{ return(default__make_temp_relation(base_relation, suffix)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__make_temp_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0481648, "supported_languages": null}, "macro.dbt.make_temp_relation": {"name": "make_temp_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.make_temp_relation", "macro_sql": "{% macro make_temp_relation(base_relation, suffix='__dbt_tmp') %}\n  {#-- This ensures microbatch batches get unique temp relations to avoid clobbering --#}\n  {% if suffix == '__dbt_tmp' and model.batch %}\n    {% set suffix = suffix ~ '_' ~ model.batch.id %}\n  {% endif %}\n\n  {{ return(adapter.dispatch('make_temp_relation', 'dbt')(base_relation, suffix)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_temp_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0486588, "supported_languages": null}, "macro.dbt.default__make_temp_relation": {"name": "default__make_temp_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.default__make_temp_relation", "macro_sql": "{% macro default__make_temp_relation(base_relation, suffix) %}\n    {%- set temp_identifier = base_relation.identifier ~ suffix -%}\n    {%- set temp_relation = base_relation.incorporate(\n                                path={\"identifier\": temp_identifier}) -%}\n\n    {{ return(temp_relation) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0490322, "supported_languages": null}, "macro.dbt.make_backup_relation": {"name": "make_backup_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.make_backup_relation", "macro_sql": "{% macro make_backup_relation(base_relation, backup_relation_type, suffix='__dbt_backup') %}\n    {{ return(adapter.dispatch('make_backup_relation', 'dbt')(base_relation, backup_relation_type, suffix)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__make_backup_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0493424, "supported_languages": null}, "macro.dbt.default__make_backup_relation": {"name": "default__make_backup_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.default__make_backup_relation", "macro_sql": "{% macro default__make_backup_relation(base_relation, backup_relation_type, suffix) %}\n    {%- set backup_identifier = base_relation.identifier ~ suffix -%}\n    {%- set backup_relation = base_relation.incorporate(\n                                  path={\"identifier\": backup_identifier},\n                                  type=backup_relation_type\n    ) -%}\n    {{ return(backup_relation) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0497618, "supported_languages": null}, "macro.dbt.truncate_relation": {"name": "truncate_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.truncate_relation", "macro_sql": "{% macro truncate_relation(relation) -%}\n  {{ return(adapter.dispatch('truncate_relation', 'dbt')(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__truncate_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0499997, "supported_languages": null}, "macro.dbt.default__truncate_relation": {"name": "default__truncate_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.default__truncate_relation", "macro_sql": "{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation.render() }}\n  {%- endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0502334, "supported_languages": null}, "macro.dbt.get_or_create_relation": {"name": "get_or_create_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.get_or_create_relation", "macro_sql": "{% macro get_or_create_relation(database, schema, identifier, type) -%}\n  {{ return(adapter.dispatch('get_or_create_relation', 'dbt')(database, schema, identifier, type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_or_create_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0505397, "supported_languages": null}, "macro.dbt.default__get_or_create_relation": {"name": "default__get_or_create_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.default__get_or_create_relation", "macro_sql": "{% macro default__get_or_create_relation(database, schema, identifier, type) %}\n  {%- set target_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) %}\n\n  {% if target_relation %}\n    {% do return([true, target_relation]) %}\n  {% endif %}\n\n  {%- set new_relation = api.Relation.create(\n      database=database,\n      schema=schema,\n      identifier=identifier,\n      type=type\n  ) -%}\n  {% do return([false, new_relation]) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.051225, "supported_languages": null}, "macro.dbt.load_cached_relation": {"name": "load_cached_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.load_cached_relation", "macro_sql": "{% macro load_cached_relation(relation) %}\n  {% do return(adapter.get_relation(\n    database=relation.database,\n    schema=relation.schema,\n    identifier=relation.identifier\n  )) -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0515065, "supported_languages": null}, "macro.dbt.load_relation": {"name": "load_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/relation.sql", "original_file_path": "macros/adapters/relation.sql", "unique_id": "macro.dbt.load_relation", "macro_sql": "{% macro load_relation(relation) %}\n    {{ return(load_cached_relation(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.load_cached_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0516937, "supported_languages": null}, "macro.dbt.create_schema": {"name": "create_schema", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/schema.sql", "original_file_path": "macros/adapters/schema.sql", "unique_id": "macro.dbt.create_schema", "macro_sql": "{% macro create_schema(relation) -%}\n  {{ adapter.dispatch('create_schema', 'dbt')(relation) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__create_schema"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.052107, "supported_languages": null}, "macro.dbt.default__create_schema": {"name": "default__create_schema", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/schema.sql", "original_file_path": "macros/adapters/schema.sql", "unique_id": "macro.dbt.default__create_schema", "macro_sql": "{% macro default__create_schema(relation) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ relation.without_identifier() }}\n  {% endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0523524, "supported_languages": null}, "macro.dbt.drop_schema": {"name": "drop_schema", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/schema.sql", "original_file_path": "macros/adapters/schema.sql", "unique_id": "macro.dbt.drop_schema", "macro_sql": "{% macro drop_schema(relation) -%}\n  {{ adapter.dispatch('drop_schema', 'dbt')(relation) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__drop_schema"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0525634, "supported_languages": null}, "macro.dbt.default__drop_schema": {"name": "default__drop_schema", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/schema.sql", "original_file_path": "macros/adapters/schema.sql", "unique_id": "macro.dbt.default__drop_schema", "macro_sql": "{% macro default__drop_schema(relation) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ relation.without_identifier() }} cascade\n  {% endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0527997, "supported_languages": null}, "macro.dbt.get_show_sql": {"name": "get_show_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/show.sql", "original_file_path": "macros/adapters/show.sql", "unique_id": "macro.dbt.get_show_sql", "macro_sql": "{% macro get_show_sql(compiled_code, sql_header, limit) -%}\n  {%- if sql_header is not none -%}\n  {{ sql_header }}\n  {%- endif %}\n  {{ get_limit_subquery_sql(compiled_code, limit) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_limit_subquery_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0532804, "supported_languages": null}, "macro.dbt.get_limit_subquery_sql": {"name": "get_limit_subquery_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/show.sql", "original_file_path": "macros/adapters/show.sql", "unique_id": "macro.dbt.get_limit_subquery_sql", "macro_sql": "\n{%- macro get_limit_subquery_sql(sql, limit) -%}\n  {{ adapter.dispatch('get_limit_sql', 'dbt')(sql, limit) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__get_limit_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.053535, "supported_languages": null}, "macro.dbt.default__get_limit_sql": {"name": "default__get_limit_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/show.sql", "original_file_path": "macros/adapters/show.sql", "unique_id": "macro.dbt.default__get_limit_sql", "macro_sql": "{% macro default__get_limit_sql(sql, limit) %}\n  {{ sql }}\n  {% if limit is not none %}\n  limit {{ limit }}\n  {%- endif -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.05388, "supported_languages": null}, "macro.dbt.validate_sql": {"name": "validate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/validate_sql.sql", "original_file_path": "macros/adapters/validate_sql.sql", "unique_id": "macro.dbt.validate_sql", "macro_sql": "{% macro validate_sql(sql) -%}\n  {{ return(adapter.dispatch('validate_sql', 'dbt')(sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__validate_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.054244, "supported_languages": null}, "macro.dbt.default__validate_sql": {"name": "default__validate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/validate_sql.sql", "original_file_path": "macros/adapters/validate_sql.sql", "unique_id": "macro.dbt.default__validate_sql", "macro_sql": "{% macro default__validate_sql(sql) -%}\n  {% call statement('validate_sql') -%}\n    explain {{ sql }}\n  {% endcall %}\n  {{ return(load_result('validate_sql')) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0545387, "supported_languages": null}, "macro.dbt.current_timestamp": {"name": "current_timestamp", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.current_timestamp", "macro_sql": "{%- macro current_timestamp() -%}\n    {{ adapter.dispatch('current_timestamp', 'dbt')() }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_postgres.postgres__current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0551, "supported_languages": null}, "macro.dbt.default__current_timestamp": {"name": "default__current_timestamp", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.default__current_timestamp", "macro_sql": "{% macro default__current_timestamp() -%}\n  {{ exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter ' + adapter.type()) }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0552983, "supported_languages": null}, "macro.dbt.snapshot_get_time": {"name": "snapshot_get_time", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.snapshot_get_time", "macro_sql": "\n\n{%- macro snapshot_get_time() -%}\n    {{ adapter.dispatch('snapshot_get_time', 'dbt')() }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_postgres.postgres__snapshot_get_time"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0554872, "supported_languages": null}, "macro.dbt.default__snapshot_get_time": {"name": "default__snapshot_get_time", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.default__snapshot_get_time", "macro_sql": "{% macro default__snapshot_get_time() %}\n    {{ current_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0556355, "supported_languages": null}, "macro.dbt.get_snapshot_get_time_data_type": {"name": "get_snapshot_get_time_data_type", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.get_snapshot_get_time_data_type", "macro_sql": "{% macro get_snapshot_get_time_data_type() %}\n    {% set snapshot_time = adapter.dispatch('snapshot_get_time', 'dbt')() %}\n    {% set time_data_type_sql = 'select ' ~ snapshot_time ~ ' as dbt_snapshot_time' %}\n    {% set snapshot_time_column_schema = get_column_schema_from_query(time_data_type_sql) %}\n    {% set time_data_type = snapshot_time_column_schema[0].dtype %}\n    {{ return(time_data_type or none) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.snapshot_get_time", "macro.dbt_postgres.postgres__snapshot_get_time", "macro.dbt.get_column_schema_from_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0561612, "supported_languages": null}, "macro.dbt.current_timestamp_backcompat": {"name": "current_timestamp_backcompat", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.current_timestamp_backcompat", "macro_sql": "{% macro current_timestamp_backcompat() %}\n    {{ return(adapter.dispatch('current_timestamp_backcompat', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__current_timestamp_backcompat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.056373, "supported_languages": null}, "macro.dbt.default__current_timestamp_backcompat": {"name": "default__current_timestamp_backcompat", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.default__current_timestamp_backcompat", "macro_sql": "{% macro default__current_timestamp_backcompat() %}\n    current_timestamp::timestamp\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.056474, "supported_languages": null}, "macro.dbt.current_timestamp_in_utc_backcompat": {"name": "current_timestamp_in_utc_backcompat", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.current_timestamp_in_utc_backcompat", "macro_sql": "{% macro current_timestamp_in_utc_backcompat() %}\n    {{ return(adapter.dispatch('current_timestamp_in_utc_backcompat', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__current_timestamp_in_utc_backcompat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0566826, "supported_languages": null}, "macro.dbt.default__current_timestamp_in_utc_backcompat": {"name": "default__current_timestamp_in_utc_backcompat", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/timestamps.sql", "original_file_path": "macros/adapters/timestamps.sql", "unique_id": "macro.dbt.default__current_timestamp_in_utc_backcompat", "macro_sql": "{% macro default__current_timestamp_in_utc_backcompat() %}\n    {{ return(adapter.dispatch('current_timestamp_backcompat', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.current_timestamp_backcompat", "macro.dbt_postgres.postgres__current_timestamp_backcompat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0568898, "supported_languages": null}, "macro.dbt.collect_freshness": {"name": "collect_freshness", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/freshness.sql", "original_file_path": "macros/adapters/freshness.sql", "unique_id": "macro.dbt.collect_freshness", "macro_sql": "{% macro collect_freshness(source, loaded_at_field, filter) %}\n  {{ return(adapter.dispatch('collect_freshness', 'dbt')(source, loaded_at_field, filter))}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__collect_freshness"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.057469, "supported_languages": null}, "macro.dbt.default__collect_freshness": {"name": "default__collect_freshness", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/freshness.sql", "original_file_path": "macros/adapters/freshness.sql", "unique_id": "macro.dbt.default__collect_freshness", "macro_sql": "{% macro default__collect_freshness(source, loaded_at_field, filter) %}\n  {% call statement('collect_freshness', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n    {% if filter %}\n    where {{ filter }}\n    {% endif %}\n  {% endcall %}\n  {{ return(load_result('collect_freshness')) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0580046, "supported_languages": null}, "macro.dbt.collect_freshness_custom_sql": {"name": "collect_freshness_custom_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/freshness.sql", "original_file_path": "macros/adapters/freshness.sql", "unique_id": "macro.dbt.collect_freshness_custom_sql", "macro_sql": "{% macro collect_freshness_custom_sql(source, loaded_at_query) %}\n  {{ return(adapter.dispatch('collect_freshness_custom_sql', 'dbt')(source, loaded_at_query))}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__collect_freshness_custom_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.058282, "supported_languages": null}, "macro.dbt.default__collect_freshness_custom_sql": {"name": "default__collect_freshness_custom_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/freshness.sql", "original_file_path": "macros/adapters/freshness.sql", "unique_id": "macro.dbt.default__collect_freshness_custom_sql", "macro_sql": "{% macro default__collect_freshness_custom_sql(source, loaded_at_query) %}\n  {% call statement('collect_freshness_custom_sql', fetch_result=True, auto_begin=False) -%}\n  with source_query as (\n    {{ loaded_at_query }}\n  )\n  select\n    (select * from source_query) as max_loaded_at,\n    {{ current_timestamp() }} as snapshotted_at\n  {% endcall %}\n  {{ return(load_result('collect_freshness_custom_sql')) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0586889, "supported_languages": null}, "macro.dbt.get_columns_in_relation": {"name": "get_columns_in_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.get_columns_in_relation", "macro_sql": "{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter.dispatch('get_columns_in_relation', 'dbt')(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_columns_in_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0600522, "supported_languages": null}, "macro.dbt.default__get_columns_in_relation": {"name": "default__get_columns_in_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__get_columns_in_relation", "macro_sql": "{% macro default__get_columns_in_relation(relation) -%}\n  {{ exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.060259, "supported_languages": null}, "macro.dbt.sql_convert_columns_in_relation": {"name": "sql_convert_columns_in_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.sql_convert_columns_in_relation", "macro_sql": "{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.060733, "supported_languages": null}, "macro.dbt.get_empty_subquery_sql": {"name": "get_empty_subquery_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.get_empty_subquery_sql", "macro_sql": "{% macro get_empty_subquery_sql(select_sql, select_sql_header=none) -%}\n  {{ return(adapter.dispatch('get_empty_subquery_sql', 'dbt')(select_sql, select_sql_header)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_empty_subquery_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0610104, "supported_languages": null}, "macro.dbt.default__get_empty_subquery_sql": {"name": "default__get_empty_subquery_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__get_empty_subquery_sql", "macro_sql": "{% macro default__get_empty_subquery_sql(select_sql, select_sql_header=none) %}\n    {%- if select_sql_header is not none -%}\n    {{ select_sql_header }}\n    {%- endif -%}\n    select * from (\n        {{ select_sql }}\n    ) as __dbt_sbq\n    where false\n    limit 0\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0612752, "supported_languages": null}, "macro.dbt.get_empty_schema_sql": {"name": "get_empty_schema_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.get_empty_schema_sql", "macro_sql": "{% macro get_empty_schema_sql(columns) -%}\n  {{ return(adapter.dispatch('get_empty_schema_sql', 'dbt')(columns)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_empty_schema_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0615206, "supported_languages": null}, "macro.dbt.default__get_empty_schema_sql": {"name": "default__get_empty_schema_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__get_empty_schema_sql", "macro_sql": "{% macro default__get_empty_schema_sql(columns) %}\n    {%- set col_err = [] -%}\n    {%- set col_naked_numeric = [] -%}\n    select\n    {% for i in columns %}\n      {%- set col = columns[i] -%}\n      {%- if col['data_type'] is not defined -%}\n        {%- do col_err.append(col['name']) -%}\n      {#-- If this column's type is just 'numeric' then it is missing precision/scale, raise a warning --#}\n      {%- elif col['data_type'].strip().lower() in ('numeric', 'decimal', 'number') -%}\n        {%- do col_naked_numeric.append(col['name']) -%}\n      {%- endif -%}\n      {% set col_name = adapter.quote(col['name']) if col.get('quote') else col['name'] %}\n      {{ cast('null', col['data_type']) }} as {{ col_name }}{{ \", \" if not loop.last }}\n    {%- endfor -%}\n    {%- if (col_err | length) > 0 -%}\n      {{ exceptions.column_type_missing(column_names=col_err) }}\n    {%- elif (col_naked_numeric | length) > 0 -%}\n      {{ exceptions.warn(\"Detected columns with numeric type and unspecified precision/scale, this can lead to unintended rounding: \" ~ col_naked_numeric ~ \"`\") }}\n    {%- endif -%}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0630147, "supported_languages": null}, "macro.dbt.get_column_schema_from_query": {"name": "get_column_schema_from_query", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.get_column_schema_from_query", "macro_sql": "{% macro get_column_schema_from_query(select_sql, select_sql_header=none) -%}\n    {% set columns = [] %}\n    {# -- Using an 'empty subquery' here to get the same schema as the given select_sql statement, without necessitating a data scan.#}\n    {% set sql = get_empty_subquery_sql(select_sql, select_sql_header) %}\n    {% set column_schema = adapter.get_column_schema_from_query(sql) %}\n    {{ return(column_schema) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_empty_subquery_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0634649, "supported_languages": null}, "macro.dbt.get_columns_in_query": {"name": "get_columns_in_query", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.get_columns_in_query", "macro_sql": "{% macro get_columns_in_query(select_sql) -%}\n  {{ return(adapter.dispatch('get_columns_in_query', 'dbt')(select_sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_columns_in_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0637736, "supported_languages": null}, "macro.dbt.default__get_columns_in_query": {"name": "default__get_columns_in_query", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__get_columns_in_query", "macro_sql": "{% macro default__get_columns_in_query(select_sql) %}\n    {% call statement('get_columns_in_query', fetch_result=True, auto_begin=False) -%}\n        {{ get_empty_subquery_sql(select_sql) }}\n    {% endcall %}\n    {{ return(load_result('get_columns_in_query').table.columns | map(attribute='name') | list) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.get_empty_subquery_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0643482, "supported_languages": null}, "macro.dbt.alter_column_type": {"name": "alter_column_type", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.alter_column_type", "macro_sql": "{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter.dispatch('alter_column_type', 'dbt')(relation, column_name, new_column_type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__alter_column_type"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0647297, "supported_languages": null}, "macro.dbt.default__alter_column_type": {"name": "default__alter_column_type", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__alter_column_type", "macro_sql": "{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation.render() }} add column {{ adapter.quote(tmp_column) }} {{ new_column_type }};\n    update {{ relation.render() }} set {{ adapter.quote(tmp_column) }} = {{ adapter.quote(column_name) }};\n    alter table {{ relation.render() }} drop column {{ adapter.quote(column_name) }} cascade;\n    alter table {{ relation.render() }} rename column {{ adapter.quote(tmp_column) }} to {{ adapter.quote(column_name) }}\n  {% endcall %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0657477, "supported_languages": null}, "macro.dbt.alter_relation_add_remove_columns": {"name": "alter_relation_add_remove_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.alter_relation_add_remove_columns", "macro_sql": "{% macro alter_relation_add_remove_columns(relation, add_columns = none, remove_columns = none) -%}\n  {{ return(adapter.dispatch('alter_relation_add_remove_columns', 'dbt')(relation, add_columns, remove_columns)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__alter_relation_add_remove_columns"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0660744, "supported_languages": null}, "macro.dbt.default__alter_relation_add_remove_columns": {"name": "default__alter_relation_add_remove_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/columns.sql", "original_file_path": "macros/adapters/columns.sql", "unique_id": "macro.dbt.default__alter_relation_add_remove_columns", "macro_sql": "{% macro default__alter_relation_add_remove_columns(relation, add_columns, remove_columns) %}\n\n  {% if add_columns is none %}\n    {% set add_columns = [] %}\n  {% endif %}\n  {% if remove_columns is none %}\n    {% set remove_columns = [] %}\n  {% endif %}\n\n  {% set sql -%}\n\n     alter {{ relation.type }} {{ relation.render() }}\n\n            {% for column in add_columns %}\n               add column {{ column.name }} {{ column.data_type }}{{ ',' if not loop.last }}\n            {% endfor %}{{ ',' if add_columns and remove_columns }}\n\n            {% for column in remove_columns %}\n                drop column {{ column.name }}{{ ',' if not loop.last }}\n            {% endfor %}\n\n  {%- endset -%}\n\n  {% do run_query(sql) %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0671012, "supported_languages": null}, "macro.dbt.alter_column_comment": {"name": "alter_column_comment", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.alter_column_comment", "macro_sql": "{% macro alter_column_comment(relation, column_dict) -%}\n  {{ return(adapter.dispatch('alter_column_comment', 'dbt')(relation, column_dict)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__alter_column_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0676732, "supported_languages": null}, "macro.dbt.default__alter_column_comment": {"name": "default__alter_column_comment", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.default__alter_column_comment", "macro_sql": "{% macro default__alter_column_comment(relation, column_dict) -%}\n  {{ exceptions.raise_not_implemented(\n    'alter_column_comment macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0678964, "supported_languages": null}, "macro.dbt.alter_relation_comment": {"name": "alter_relation_comment", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.alter_relation_comment", "macro_sql": "{% macro alter_relation_comment(relation, relation_comment) -%}\n  {{ return(adapter.dispatch('alter_relation_comment', 'dbt')(relation, relation_comment)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__alter_relation_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0681581, "supported_languages": null}, "macro.dbt.default__alter_relation_comment": {"name": "default__alter_relation_comment", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.default__alter_relation_comment", "macro_sql": "{% macro default__alter_relation_comment(relation, relation_comment) -%}\n  {{ exceptions.raise_not_implemented(\n    'alter_relation_comment macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0683737, "supported_languages": null}, "macro.dbt.persist_docs": {"name": "persist_docs", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.persist_docs", "macro_sql": "{% macro persist_docs(relation, model, for_relation=true, for_columns=true) -%}\n  {{ return(adapter.dispatch('persist_docs', 'dbt')(relation, model, for_relation, for_columns)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__persist_docs"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0687132, "supported_languages": null}, "macro.dbt.default__persist_docs": {"name": "default__persist_docs", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/persist_docs.sql", "original_file_path": "macros/adapters/persist_docs.sql", "unique_id": "macro.dbt.default__persist_docs", "macro_sql": "{% macro default__persist_docs(relation, model, for_relation, for_columns) -%}\n  {% if for_relation and config.persist_relation_docs() and model.description %}\n    {% do run_query(alter_relation_comment(relation, model.description)) %}\n  {% endif %}\n\n  {% if for_columns and config.persist_column_docs() and model.columns %}\n    {% do run_query(alter_column_comment(relation, model.columns)) %}\n  {% endif %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_query", "macro.dbt.alter_relation_comment", "macro.dbt.alter_column_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0693955, "supported_languages": null}, "macro.dbt.get_catalog_relations": {"name": "get_catalog_relations", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.get_catalog_relations", "macro_sql": "{% macro get_catalog_relations(information_schema, relations) -%}\n  {{ return(adapter.dispatch('get_catalog_relations', 'dbt')(information_schema, relations)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_catalog_relations"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0704286, "supported_languages": null}, "macro.dbt.default__get_catalog_relations": {"name": "default__get_catalog_relations", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__get_catalog_relations", "macro_sql": "{% macro default__get_catalog_relations(information_schema, relations) -%}\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog_relations not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0707722, "supported_languages": null}, "macro.dbt.get_catalog": {"name": "get_catalog", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.get_catalog", "macro_sql": "{% macro get_catalog(information_schema, schemas) -%}\n  {{ return(adapter.dispatch('get_catalog', 'dbt')(information_schema, schemas)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_catalog"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0710323, "supported_languages": null}, "macro.dbt.default__get_catalog": {"name": "default__get_catalog", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__get_catalog", "macro_sql": "{% macro default__get_catalog(information_schema, schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0713627, "supported_languages": null}, "macro.dbt.information_schema_name": {"name": "information_schema_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.information_schema_name", "macro_sql": "{% macro information_schema_name(database) %}\n  {{ return(adapter.dispatch('information_schema_name', 'dbt')(database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__information_schema_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0716107, "supported_languages": null}, "macro.dbt.default__information_schema_name": {"name": "default__information_schema_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__information_schema_name", "macro_sql": "{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ database }}.INFORMATION_SCHEMA\n  {%- else -%}\n    INFORMATION_SCHEMA\n  {%- endif -%}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.071823, "supported_languages": null}, "macro.dbt.list_schemas": {"name": "list_schemas", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.list_schemas", "macro_sql": "{% macro list_schemas(database) -%}\n  {{ return(adapter.dispatch('list_schemas', 'dbt')(database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__list_schemas"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0720546, "supported_languages": null}, "macro.dbt.default__list_schemas": {"name": "default__list_schemas", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__list_schemas", "macro_sql": "{% macro default__list_schemas(database) -%}\n  {% set sql %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.SCHEMATA\n    where catalog_name ilike '{{ database }}'\n  {% endset %}\n  {{ return(run_query(sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.information_schema_name", "macro.dbt.run_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0723712, "supported_languages": null}, "macro.dbt.check_schema_exists": {"name": "check_schema_exists", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.check_schema_exists", "macro_sql": "{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter.dispatch('check_schema_exists', 'dbt')(information_schema, schema)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__check_schema_exists"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0726292, "supported_languages": null}, "macro.dbt.default__check_schema_exists": {"name": "default__check_schema_exists", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__check_schema_exists", "macro_sql": "{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% set sql -%}\n        select count(*)\n        from {{ information_schema.replace(information_schema_view='SCHEMATA') }}\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endset %}\n  {{ return(run_query(sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.replace", "macro.dbt.run_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0730083, "supported_languages": null}, "macro.dbt.list_relations_without_caching": {"name": "list_relations_without_caching", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.list_relations_without_caching", "macro_sql": "{% macro list_relations_without_caching(schema_relation) %}\n  {{ return(adapter.dispatch('list_relations_without_caching', 'dbt')(schema_relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__list_relations_without_caching"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0732398, "supported_languages": null}, "macro.dbt.default__list_relations_without_caching": {"name": "default__list_relations_without_caching", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__list_relations_without_caching", "macro_sql": "{% macro default__list_relations_without_caching(schema_relation) %}\n  {{ exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0734565, "supported_languages": null}, "macro.dbt.get_catalog_for_single_relation": {"name": "get_catalog_for_single_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.get_catalog_for_single_relation", "macro_sql": "{% macro get_catalog_for_single_relation(relation) %}\n  {{ return(adapter.dispatch('get_catalog_for_single_relation', 'dbt')(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_catalog_for_single_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0736933, "supported_languages": null}, "macro.dbt.default__get_catalog_for_single_relation": {"name": "default__get_catalog_for_single_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__get_catalog_for_single_relation", "macro_sql": "{% macro default__get_catalog_for_single_relation(relation) %}\n  {{ exceptions.raise_not_implemented(\n    'get_catalog_for_single_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0738919, "supported_languages": null}, "macro.dbt.get_relations": {"name": "get_relations", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.get_relations", "macro_sql": "{% macro get_relations() %}\n  {{ return(adapter.dispatch('get_relations', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_relations"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.074098, "supported_languages": null}, "macro.dbt.default__get_relations": {"name": "default__get_relations", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__get_relations", "macro_sql": "{% macro default__get_relations() %}\n  {{ exceptions.raise_not_implemented(\n    'get_relations macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0742874, "supported_languages": null}, "macro.dbt.get_relation_last_modified": {"name": "get_relation_last_modified", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.get_relation_last_modified", "macro_sql": "{% macro get_relation_last_modified(information_schema, relations) %}\n  {{ return(adapter.dispatch('get_relation_last_modified', 'dbt')(information_schema, relations)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_relation_last_modified"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0745447, "supported_languages": null}, "macro.dbt.default__get_relation_last_modified": {"name": "default__get_relation_last_modified", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/metadata.sql", "original_file_path": "macros/adapters/metadata.sql", "unique_id": "macro.dbt.default__get_relation_last_modified", "macro_sql": "{% macro default__get_relation_last_modified(information_schema, relations) %}\n  {{ exceptions.raise_not_implemented(\n    'get_relation_last_modified macro not implemented for adapter ' + adapter.type()) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0748293, "supported_languages": null}, "macro.dbt.get_create_index_sql": {"name": "get_create_index_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.get_create_index_sql", "macro_sql": "{% macro get_create_index_sql(relation, index_dict) -%}\n  {{ return(adapter.dispatch('get_create_index_sql', 'dbt')(relation, index_dict)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_create_index_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0754385, "supported_languages": null}, "macro.dbt.default__get_create_index_sql": {"name": "default__get_create_index_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.default__get_create_index_sql", "macro_sql": "{% macro default__get_create_index_sql(relation, index_dict) -%}\n  {% do return(None) %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0756276, "supported_languages": null}, "macro.dbt.create_indexes": {"name": "create_indexes", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.create_indexes", "macro_sql": "{% macro create_indexes(relation) -%}\n  {{ adapter.dispatch('create_indexes', 'dbt')(relation) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__create_indexes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0758307, "supported_languages": null}, "macro.dbt.default__create_indexes": {"name": "default__create_indexes", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.default__create_indexes", "macro_sql": "{% macro default__create_indexes(relation) -%}\n  {%- set _indexes = config.get('indexes', default=[]) -%}\n\n  {% for _index_dict in _indexes %}\n    {% set create_index_sql = get_create_index_sql(relation, _index_dict) %}\n    {% if create_index_sql %}\n      {% do run_query(create_index_sql) %}\n    {% endif %}\n  {% endfor %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_create_index_sql", "macro.dbt.run_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0763392, "supported_languages": null}, "macro.dbt.get_drop_index_sql": {"name": "get_drop_index_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.get_drop_index_sql", "macro_sql": "{% macro get_drop_index_sql(relation, index_name) -%}\n    {{ adapter.dispatch('get_drop_index_sql', 'dbt')(relation, index_name) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_drop_index_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.076573, "supported_languages": null}, "macro.dbt.default__get_drop_index_sql": {"name": "default__get_drop_index_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.default__get_drop_index_sql", "macro_sql": "{% macro default__get_drop_index_sql(relation, index_name) -%}\n    {{ exceptions.raise_compiler_error(\"`get_drop_index_sql has not been implemented for this adapter.\") }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0767496, "supported_languages": null}, "macro.dbt.get_show_indexes_sql": {"name": "get_show_indexes_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.get_show_indexes_sql", "macro_sql": "{% macro get_show_indexes_sql(relation) -%}\n    {{ adapter.dispatch('get_show_indexes_sql', 'dbt')(relation) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_show_indexes_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0769467, "supported_languages": null}, "macro.dbt.default__get_show_indexes_sql": {"name": "default__get_show_indexes_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/indexes.sql", "original_file_path": "macros/adapters/indexes.sql", "unique_id": "macro.dbt.default__get_show_indexes_sql", "macro_sql": "{% macro default__get_show_indexes_sql(relation) -%}\n    {{ exceptions.raise_compiler_error(\"`get_show_indexes_sql has not been implemented for this adapter.\") }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0771065, "supported_languages": null}, "macro.dbt.copy_grants": {"name": "copy_grants", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.copy_grants", "macro_sql": "{% macro copy_grants() %}\n    {{ return(adapter.dispatch('copy_grants', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__copy_grants"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0784838, "supported_languages": null}, "macro.dbt.default__copy_grants": {"name": "default__copy_grants", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__copy_grants", "macro_sql": "{% macro default__copy_grants() %}\n    {{ return(True) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0786448, "supported_languages": null}, "macro.dbt.support_multiple_grantees_per_dcl_statement": {"name": "support_multiple_grantees_per_dcl_statement", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.support_multiple_grantees_per_dcl_statement", "macro_sql": "{% macro support_multiple_grantees_per_dcl_statement() %}\n    {{ return(adapter.dispatch('support_multiple_grantees_per_dcl_statement', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__support_multiple_grantees_per_dcl_statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0788605, "supported_languages": null}, "macro.dbt.default__support_multiple_grantees_per_dcl_statement": {"name": "default__support_multiple_grantees_per_dcl_statement", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__support_multiple_grantees_per_dcl_statement", "macro_sql": "\n\n{%- macro default__support_multiple_grantees_per_dcl_statement() -%}\n    {{ return(True) }}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0790105, "supported_languages": null}, "macro.dbt.should_revoke": {"name": "should_revoke", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.should_revoke", "macro_sql": "{% macro should_revoke(existing_relation, full_refresh_mode=True) %}\n\n    {% if not existing_relation %}\n        {#-- The table doesn't already exist, so no grants to copy over --#}\n        {{ return(False) }}\n    {% elif full_refresh_mode %}\n        {#-- The object is being REPLACED -- whether grants are copied over depends on the value of user config --#}\n        {{ return(copy_grants()) }}\n    {% else %}\n        {#-- The table is being merged/upserted/inserted -- grants will be carried over --#}\n        {{ return(True) }}\n    {% endif %}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.copy_grants"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0794494, "supported_languages": null}, "macro.dbt.get_show_grant_sql": {"name": "get_show_grant_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.get_show_grant_sql", "macro_sql": "{% macro get_show_grant_sql(relation) %}\n    {{ return(adapter.dispatch(\"get_show_grant_sql\", \"dbt\")(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_show_grant_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.079694, "supported_languages": null}, "macro.dbt.default__get_show_grant_sql": {"name": "default__get_show_grant_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__get_show_grant_sql", "macro_sql": "{% macro default__get_show_grant_sql(relation) %}\n    show grants on {{ relation.render() }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0798533, "supported_languages": null}, "macro.dbt.get_grant_sql": {"name": "get_grant_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.get_grant_sql", "macro_sql": "{% macro get_grant_sql(relation, privilege, grantees) %}\n    {{ return(adapter.dispatch('get_grant_sql', 'dbt')(relation, privilege, grantees)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_grant_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0801406, "supported_languages": null}, "macro.dbt.default__get_grant_sql": {"name": "default__get_grant_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__get_grant_sql", "macro_sql": "\n\n{%- macro default__get_grant_sql(relation, privilege, grantees) -%}\n    grant {{ privilege }} on {{ relation.render() }} to {{ grantees | join(', ') }}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0804853, "supported_languages": null}, "macro.dbt.get_revoke_sql": {"name": "get_revoke_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.get_revoke_sql", "macro_sql": "{% macro get_revoke_sql(relation, privilege, grantees) %}\n    {{ return(adapter.dispatch('get_revoke_sql', 'dbt')(relation, privilege, grantees)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_revoke_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0807738, "supported_languages": null}, "macro.dbt.default__get_revoke_sql": {"name": "default__get_revoke_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__get_revoke_sql", "macro_sql": "\n\n{%- macro default__get_revoke_sql(relation, privilege, grantees) -%}\n    revoke {{ privilege }} on {{ relation.render() }} from {{ grantees | join(', ') }}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.081035, "supported_languages": null}, "macro.dbt.get_dcl_statement_list": {"name": "get_dcl_statement_list", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.get_dcl_statement_list", "macro_sql": "{% macro get_dcl_statement_list(relation, grant_config, get_dcl_macro) %}\n    {{ return(adapter.dispatch('get_dcl_statement_list', 'dbt')(relation, grant_config, get_dcl_macro)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_dcl_statement_list"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0813205, "supported_languages": null}, "macro.dbt.default__get_dcl_statement_list": {"name": "default__get_dcl_statement_list", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__get_dcl_statement_list", "macro_sql": "\n\n{%- macro default__get_dcl_statement_list(relation, grant_config, get_dcl_macro) -%}\n    {#\n      -- Unpack grant_config into specific privileges and the set of users who need them granted/revoked.\n      -- Depending on whether this database supports multiple grantees per statement, pass in the list of\n      -- all grantees per privilege, or (if not) template one statement per privilege-grantee pair.\n      -- `get_dcl_macro` will be either `get_grant_sql` or `get_revoke_sql`\n    #}\n    {%- set dcl_statements = [] -%}\n    {%- for privilege, grantees in grant_config.items() %}\n        {%- if support_multiple_grantees_per_dcl_statement() and grantees -%}\n          {%- set dcl = get_dcl_macro(relation, privilege, grantees) -%}\n          {%- do dcl_statements.append(dcl) -%}\n        {%- else -%}\n          {%- for grantee in grantees -%}\n              {% set dcl = get_dcl_macro(relation, privilege, [grantee]) %}\n              {%- do dcl_statements.append(dcl) -%}\n          {% endfor -%}\n        {%- endif -%}\n    {%- endfor -%}\n    {{ return(dcl_statements) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.support_multiple_grantees_per_dcl_statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.082209, "supported_languages": null}, "macro.dbt.call_dcl_statements": {"name": "call_dcl_statements", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.call_dcl_statements", "macro_sql": "{% macro call_dcl_statements(dcl_statement_list) %}\n    {{ return(adapter.dispatch(\"call_dcl_statements\", \"dbt\")(dcl_statement_list)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__call_dcl_statements"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0824609, "supported_languages": null}, "macro.dbt.default__call_dcl_statements": {"name": "default__call_dcl_statements", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__call_dcl_statements", "macro_sql": "{% macro default__call_dcl_statements(dcl_statement_list) %}\n    {#\n      -- By default, supply all grant + revoke statements in a single semicolon-separated block,\n      -- so that they're all processed together.\n\n      -- Some databases do not support this. Those adapters will need to override this macro\n      -- to run each statement individually.\n    #}\n    {% call statement('grants') %}\n        {% for dcl_statement in dcl_statement_list %}\n            {{ dcl_statement }};\n        {% endfor %}\n    {% endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0827854, "supported_languages": null}, "macro.dbt.apply_grants": {"name": "apply_grants", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.apply_grants", "macro_sql": "{% macro apply_grants(relation, grant_config, should_revoke) %}\n    {{ return(adapter.dispatch(\"apply_grants\", \"dbt\")(relation, grant_config, should_revoke)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__apply_grants"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0830731, "supported_languages": null}, "macro.dbt.default__apply_grants": {"name": "default__apply_grants", "resource_type": "macro", "package_name": "dbt", "path": "macros/adapters/apply_grants.sql", "original_file_path": "macros/adapters/apply_grants.sql", "unique_id": "macro.dbt.default__apply_grants", "macro_sql": "{% macro default__apply_grants(relation, grant_config, should_revoke=True) %}\n    {#-- If grant_config is {} or None, this is a no-op --#}\n    {% if grant_config %}\n        {% if should_revoke %}\n            {#-- We think previous grants may have carried over --#}\n            {#-- Show current grants and calculate diffs --#}\n            {% set current_grants_table = run_query(get_show_grant_sql(relation)) %}\n            {% set current_grants_dict = adapter.standardize_grants_dict(current_grants_table) %}\n            {% set needs_granting = diff_of_two_dicts(grant_config, current_grants_dict) %}\n            {% set needs_revoking = diff_of_two_dicts(current_grants_dict, grant_config) %}\n            {% if not (needs_granting or needs_revoking) %}\n                {{ log('On ' ~ relation.render() ~': All grants are in place, no revocation or granting needed.')}}\n            {% endif %}\n        {% else %}\n            {#-- We don't think there's any chance of previous grants having carried over. --#}\n            {#-- Jump straight to granting what the user has configured. --#}\n            {% set needs_revoking = {} %}\n            {% set needs_granting = grant_config %}\n        {% endif %}\n        {% if needs_granting or needs_revoking %}\n            {% set revoke_statement_list = get_dcl_statement_list(relation, needs_revoking, get_revoke_sql) %}\n            {% set grant_statement_list = get_dcl_statement_list(relation, needs_granting, get_grant_sql) %}\n            {% set dcl_statement_list = revoke_statement_list + grant_statement_list %}\n            {% if dcl_statement_list %}\n                {{ call_dcl_statements(dcl_statement_list) }}\n            {% endif %}\n        {% endif %}\n    {% endif %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_query", "macro.dbt.get_show_grant_sql", "macro.dbt.get_dcl_statement_list", "macro.dbt.call_dcl_statements"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0845556, "supported_languages": null}, "macro.dbt.generate_database_name": {"name": "generate_database_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_database.sql", "original_file_path": "macros/get_custom_name/get_custom_database.sql", "unique_id": "macro.dbt.generate_database_name", "macro_sql": "{% macro generate_database_name(custom_database_name=none, node=none) -%}\n    {% do return(adapter.dispatch('generate_database_name', 'dbt')(custom_database_name, node)) %}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__generate_database_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0850432, "supported_languages": null}, "macro.dbt.default__generate_database_name": {"name": "default__generate_database_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_database.sql", "original_file_path": "macros/get_custom_name/get_custom_database.sql", "unique_id": "macro.dbt.default__generate_database_name", "macro_sql": "{% macro default__generate_database_name(custom_database_name=none, node=none) -%}\n    {%- set default_database = target.database -%}\n    {%- if custom_database_name is none -%}\n\n        {{ default_database }}\n\n    {%- else -%}\n\n        {{ custom_database_name }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0853784, "supported_languages": null}, "macro.dbt.generate_schema_name": {"name": "generate_schema_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_schema.sql", "original_file_path": "macros/get_custom_name/get_custom_schema.sql", "unique_id": "macro.dbt.generate_schema_name", "macro_sql": "{% macro generate_schema_name(custom_schema_name=none, node=none) -%}\n    {{ return(adapter.dispatch('generate_schema_name', 'dbt')(custom_schema_name, node)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__generate_schema_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0859468, "supported_languages": null}, "macro.dbt.default__generate_schema_name": {"name": "default__generate_schema_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_schema.sql", "original_file_path": "macros/get_custom_name/get_custom_schema.sql", "unique_id": "macro.dbt.default__generate_schema_name", "macro_sql": "{% macro default__generate_schema_name(custom_schema_name, node) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if custom_schema_name is none -%}\n\n        {{ default_schema }}\n\n    {%- else -%}\n\n        {{ default_schema }}_{{ custom_schema_name | trim }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.086297, "supported_languages": null}, "macro.dbt.generate_schema_name_for_env": {"name": "generate_schema_name_for_env", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_schema.sql", "original_file_path": "macros/get_custom_name/get_custom_schema.sql", "unique_id": "macro.dbt.generate_schema_name_for_env", "macro_sql": "{% macro generate_schema_name_for_env(custom_schema_name, node) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if target.name == 'prod' and custom_schema_name is not none -%}\n\n        {{ custom_schema_name | trim }}\n\n    {%- else -%}\n\n        {{ default_schema }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0866652, "supported_languages": null}, "macro.dbt.generate_alias_name": {"name": "generate_alias_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_alias.sql", "original_file_path": "macros/get_custom_name/get_custom_alias.sql", "unique_id": "macro.dbt.generate_alias_name", "macro_sql": "{% macro generate_alias_name(custom_alias_name=none, node=none) -%}\n    {% do return(adapter.dispatch('generate_alias_name', 'dbt')(custom_alias_name, node)) %}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__generate_alias_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0871296, "supported_languages": null}, "macro.dbt.default__generate_alias_name": {"name": "default__generate_alias_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/get_custom_name/get_custom_alias.sql", "original_file_path": "macros/get_custom_name/get_custom_alias.sql", "unique_id": "macro.dbt.default__generate_alias_name", "macro_sql": "{% macro default__generate_alias_name(custom_alias_name=none, node=none) -%}\n\n    {%- if custom_alias_name -%}\n\n        {{ custom_alias_name | trim }}\n\n    {%- elif node.version -%}\n\n        {{ return(node.name ~ \"_v\" ~ (node.version | replace(\".\", \"_\"))) }}\n\n    {%- else -%}\n\n        {{ node.name }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0876338, "supported_languages": null}, "macro.dbt.resolve_model_name": {"name": "resolve_model_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.resolve_model_name", "macro_sql": "{% macro resolve_model_name(input_model_name) %}\n    {{ return(adapter.dispatch('resolve_model_name', 'dbt')(input_model_name)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__resolve_model_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.088471, "supported_languages": null}, "macro.dbt.default__resolve_model_name": {"name": "default__resolve_model_name", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.default__resolve_model_name", "macro_sql": "\n\n{%- macro default__resolve_model_name(input_model_name) -%}\n    {{  input_model_name | string | replace('\"', '\\\"') }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0886815, "supported_languages": null}, "macro.dbt.build_ref_function": {"name": "build_ref_function", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.build_ref_function", "macro_sql": "{% macro build_ref_function(model) %}\n\n    {%- set ref_dict = {} -%}\n    {%- for _ref in model.refs -%}\n        {% set _ref_args = [_ref.get('package'), _ref['name']] if _ref.get('package') else [_ref['name'],] %}\n        {%- set resolved = ref(*_ref_args, v=_ref.get('version')) -%}\n        {%- if _ref.get('version') -%}\n            {% do _ref_args.extend([\"v\" ~ _ref['version']]) %}\n        {%- endif -%}\n       {%- do ref_dict.update({_ref_args | join('.'): resolve_model_name(resolved)}) -%}\n    {%- endfor -%}\n\ndef ref(*args, **kwargs):\n    refs = {{ ref_dict | tojson }}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.resolve_model_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0898306, "supported_languages": null}, "macro.dbt.build_source_function": {"name": "build_source_function", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.build_source_function", "macro_sql": "{% macro build_source_function(model) %}\n\n    {%- set source_dict = {} -%}\n    {%- for _source in model.sources -%}\n        {%- set resolved = source(*_source) -%}\n        {%- do source_dict.update({_source | join('.'): resolve_model_name(resolved)}) -%}\n    {%- endfor -%}\n\ndef source(*args, dbt_load_df_function):\n    sources = {{ source_dict | tojson }}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.resolve_model_name"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0903537, "supported_languages": null}, "macro.dbt.build_config_dict": {"name": "build_config_dict", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.build_config_dict", "macro_sql": "{% macro build_config_dict(model) %}\n    {%- set config_dict = {} -%}\n    {% set config_dbt_used = zip(model.config.config_keys_used, model.config.config_keys_defaults) | list %}\n    {%- for key, default in config_dbt_used -%}\n        {# weird type testing with enum, would be much easier to write this logic in Python! #}\n        {%- if key == \"language\" -%}\n          {%- set value = \"python\" -%}\n        {%- endif -%}\n        {%- set value = model.config.get(key, default) -%}\n        {%- do config_dict.update({key: value}) -%}\n    {%- endfor -%}\nconfig_dict = {{ config_dict }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.091102, "supported_languages": null}, "macro.dbt.py_script_postfix": {"name": "py_script_postfix", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.py_script_postfix", "macro_sql": "{% macro py_script_postfix(model) %}\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\n{{ build_ref_function(model ) }}\n{{ build_source_function(model ) }}\n{{ build_config_dict(model) }}\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"{{ this.database }}\"\n    schema = \"{{ this.schema }}\"\n    identifier = \"{{ this.identifier }}\"\n    {% set this_relation_name = resolve_model_name(this) %}\n    def __repr__(self):\n        return '{{ this_relation_name  }}'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = {{ is_incremental() }}\n\n# COMMAND ----------\n{{py_script_comment()}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.build_ref_function", "macro.dbt.build_source_function", "macro.dbt.build_config_dict", "macro.dbt.resolve_model_name", "macro.dbt.is_incremental", "macro.dbt.py_script_comment"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.091803, "supported_languages": null}, "macro.dbt.py_script_comment": {"name": "py_script_comment", "resource_type": "macro", "package_name": "dbt", "path": "macros/python_model/python.sql", "original_file_path": "macros/python_model/python.sql", "unique_id": "macro.dbt.py_script_comment", "macro_sql": "{%macro py_script_comment()%}\n{%endmacro%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0919347, "supported_languages": null}, "macro.dbt.get_create_intermediate_sql": {"name": "get_create_intermediate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create_intermediate.sql", "original_file_path": "macros/relations/create_intermediate.sql", "unique_id": "macro.dbt.get_create_intermediate_sql", "macro_sql": "{%- macro get_create_intermediate_sql(relation, sql) -%}\n    {{- log('Applying CREATE INTERMEDIATE to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_create_intermediate_sql', 'dbt')(relation, sql) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_create_intermediate_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0924833, "supported_languages": null}, "macro.dbt.default__get_create_intermediate_sql": {"name": "default__get_create_intermediate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create_intermediate.sql", "original_file_path": "macros/relations/create_intermediate.sql", "unique_id": "macro.dbt.default__get_create_intermediate_sql", "macro_sql": "{%- macro default__get_create_intermediate_sql(relation, sql) -%}\n\n    -- get the standard intermediate name\n    {% set intermediate_relation = make_intermediate_relation(relation) %}\n\n    -- drop any pre-existing intermediate\n    {{ get_drop_sql(intermediate_relation) }};\n\n    {{ get_create_sql(intermediate_relation, sql) }}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt.make_intermediate_relation", "macro.dbt.get_drop_sql", "macro.dbt.get_create_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0929024, "supported_languages": null}, "macro.dbt.drop_schema_named": {"name": "drop_schema_named", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/schema.sql", "original_file_path": "macros/relations/schema.sql", "unique_id": "macro.dbt.drop_schema_named", "macro_sql": "{% macro drop_schema_named(schema_name) %}\n    {{ return(adapter.dispatch('drop_schema_named', 'dbt') (schema_name)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__drop_schema_named"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.09332, "supported_languages": null}, "macro.dbt.default__drop_schema_named": {"name": "default__drop_schema_named", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/schema.sql", "original_file_path": "macros/relations/schema.sql", "unique_id": "macro.dbt.default__drop_schema_named", "macro_sql": "{% macro default__drop_schema_named(schema_name) %}\n  {% set schema_relation = api.Relation.create(schema=schema_name) %}\n  {{ adapter.drop_schema(schema_relation) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0936282, "supported_languages": null}, "macro.dbt.get_rename_intermediate_sql": {"name": "get_rename_intermediate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename_intermediate.sql", "original_file_path": "macros/relations/rename_intermediate.sql", "unique_id": "macro.dbt.get_rename_intermediate_sql", "macro_sql": "{%- macro get_rename_intermediate_sql(relation) -%}\n    {{- log('Applying RENAME INTERMEDIATE to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_rename_intermediate_sql', 'dbt')(relation) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_rename_intermediate_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0940068, "supported_languages": null}, "macro.dbt.default__get_rename_intermediate_sql": {"name": "default__get_rename_intermediate_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename_intermediate.sql", "original_file_path": "macros/relations/rename_intermediate.sql", "unique_id": "macro.dbt.default__get_rename_intermediate_sql", "macro_sql": "{%- macro default__get_rename_intermediate_sql(relation) -%}\n\n    -- get the standard intermediate name\n    {% set intermediate_relation = make_intermediate_relation(relation) %}\n\n    {{ get_rename_sql(intermediate_relation, relation.identifier) }}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt.make_intermediate_relation", "macro.dbt.get_rename_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0942736, "supported_languages": null}, "macro.dbt.get_create_backup_sql": {"name": "get_create_backup_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create_backup.sql", "original_file_path": "macros/relations/create_backup.sql", "unique_id": "macro.dbt.get_create_backup_sql", "macro_sql": "{%- macro get_create_backup_sql(relation) -%}\n    {{- log('Applying CREATE BACKUP to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_create_backup_sql', 'dbt')(relation) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_create_backup_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0946555, "supported_languages": null}, "macro.dbt.default__get_create_backup_sql": {"name": "default__get_create_backup_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create_backup.sql", "original_file_path": "macros/relations/create_backup.sql", "unique_id": "macro.dbt.default__get_create_backup_sql", "macro_sql": "{%- macro default__get_create_backup_sql(relation) -%}\n\n    -- get the standard backup name\n    {% set backup_relation = make_backup_relation(relation, relation.type) %}\n\n    -- drop any pre-existing backup\n    {{ get_drop_sql(backup_relation) }};\n\n    {{ get_rename_sql(relation, backup_relation.identifier) }}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt.make_backup_relation", "macro.dbt.get_drop_sql", "macro.dbt.get_rename_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0950038, "supported_languages": null}, "macro.dbt.get_replace_sql": {"name": "get_replace_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/replace.sql", "original_file_path": "macros/relations/replace.sql", "unique_id": "macro.dbt.get_replace_sql", "macro_sql": "{% macro get_replace_sql(existing_relation, target_relation, sql) %}\n    {{- log('Applying REPLACE to: ' ~ existing_relation) -}}\n    {{- adapter.dispatch('get_replace_sql', 'dbt')(existing_relation, target_relation, sql) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_replace_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.095701, "supported_languages": null}, "macro.dbt.default__get_replace_sql": {"name": "default__get_replace_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/replace.sql", "original_file_path": "macros/relations/replace.sql", "unique_id": "macro.dbt.default__get_replace_sql", "macro_sql": "{% macro default__get_replace_sql(existing_relation, target_relation, sql) %}\n\n    {# /* use a create or replace statement if possible */ #}\n\n    {% set is_replaceable = existing_relation.type == target_relation.type and existing_relation.can_be_replaced %}\n\n    {% if is_replaceable and existing_relation.is_view %}\n        {{ get_replace_view_sql(target_relation, sql) }}\n\n    {% elif is_replaceable and existing_relation.is_table %}\n        {{ get_replace_table_sql(target_relation, sql) }}\n\n    {% elif is_replaceable and existing_relation.is_materialized_view %}\n        {{ get_replace_materialized_view_sql(target_relation, sql) }}\n\n    {# /* a create or replace statement is not possible, so try to stage and/or backup to be safe */ #}\n\n    {# /* create target_relation as an intermediate relation, then swap it out with the existing one using a backup */ #}\n    {%- elif target_relation.can_be_renamed and existing_relation.can_be_renamed -%}\n        {{ get_create_intermediate_sql(target_relation, sql) }};\n        {{ get_create_backup_sql(existing_relation) }};\n        {{ get_rename_intermediate_sql(target_relation) }};\n        {{ get_drop_backup_sql(existing_relation) }}\n\n    {# /* create target_relation as an intermediate relation, then swap it out with the existing one without using a backup */ #}\n    {%- elif target_relation.can_be_renamed -%}\n        {{ get_create_intermediate_sql(target_relation, sql) }};\n        {{ get_drop_sql(existing_relation) }};\n        {{ get_rename_intermediate_sql(target_relation) }}\n\n    {# /* create target_relation in place by first backing up the existing relation */ #}\n    {%- elif existing_relation.can_be_renamed -%}\n        {{ get_create_backup_sql(existing_relation) }};\n        {{ get_create_sql(target_relation, sql) }};\n        {{ get_drop_backup_sql(existing_relation) }}\n\n    {# /* no renaming is allowed, so just drop and create */ #}\n    {%- else -%}\n        {{ get_drop_sql(existing_relation) }};\n        {{ get_create_sql(target_relation, sql) }}\n\n    {%- endif -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_replace_view_sql", "macro.dbt.get_replace_table_sql", "macro.dbt.get_replace_materialized_view_sql", "macro.dbt.get_create_intermediate_sql", "macro.dbt.get_create_backup_sql", "macro.dbt.get_rename_intermediate_sql", "macro.dbt.get_drop_backup_sql", "macro.dbt.get_drop_sql", "macro.dbt.get_create_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0973365, "supported_languages": null}, "macro.dbt.get_drop_backup_sql": {"name": "get_drop_backup_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop_backup.sql", "original_file_path": "macros/relations/drop_backup.sql", "unique_id": "macro.dbt.get_drop_backup_sql", "macro_sql": "{%- macro get_drop_backup_sql(relation) -%}\n    {{- log('Applying DROP BACKUP to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_drop_backup_sql', 'dbt')(relation) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_drop_backup_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0977633, "supported_languages": null}, "macro.dbt.default__get_drop_backup_sql": {"name": "default__get_drop_backup_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop_backup.sql", "original_file_path": "macros/relations/drop_backup.sql", "unique_id": "macro.dbt.default__get_drop_backup_sql", "macro_sql": "{%- macro default__get_drop_backup_sql(relation) -%}\n\n    -- get the standard backup name\n    {% set backup_relation = make_backup_relation(relation, relation.type) %}\n\n    {{ get_drop_sql(backup_relation) }}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt.make_backup_relation", "macro.dbt.get_drop_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0980437, "supported_languages": null}, "macro.dbt.get_drop_sql": {"name": "get_drop_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop.sql", "original_file_path": "macros/relations/drop.sql", "unique_id": "macro.dbt.get_drop_sql", "macro_sql": "{%- macro get_drop_sql(relation) -%}\n    {{- log('Applying DROP to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_drop_sql', 'dbt')(relation) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_drop_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0985973, "supported_languages": null}, "macro.dbt.default__get_drop_sql": {"name": "default__get_drop_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop.sql", "original_file_path": "macros/relations/drop.sql", "unique_id": "macro.dbt.default__get_drop_sql", "macro_sql": "{%- macro default__get_drop_sql(relation) -%}\n\n    {%- if relation.is_view -%}\n        {{ drop_view(relation) }}\n\n    {%- elif relation.is_table -%}\n        {{ drop_table(relation) }}\n\n    {%- elif relation.is_materialized_view -%}\n        {{ drop_materialized_view(relation) }}\n\n    {%- else -%}\n        drop {{ relation.type }} if exists {{ relation.render() }} cascade\n\n    {%- endif -%}\n\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.drop_view", "macro.dbt.drop_table", "macro.dbt.drop_materialized_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.099095, "supported_languages": null}, "macro.dbt.drop_relation": {"name": "drop_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop.sql", "original_file_path": "macros/relations/drop.sql", "unique_id": "macro.dbt.drop_relation", "macro_sql": "{% macro drop_relation(relation) -%}\n    {{ return(adapter.dispatch('drop_relation', 'dbt')(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__drop_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0993237, "supported_languages": null}, "macro.dbt.default__drop_relation": {"name": "default__drop_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop.sql", "original_file_path": "macros/relations/drop.sql", "unique_id": "macro.dbt.default__drop_relation", "macro_sql": "{% macro default__drop_relation(relation) -%}\n    {% call statement('drop_relation', auto_begin=False) -%}\n        {{ get_drop_sql(relation) }}\n    {%- endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.get_drop_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.0996015, "supported_languages": null}, "macro.dbt.drop_relation_if_exists": {"name": "drop_relation_if_exists", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/drop.sql", "original_file_path": "macros/relations/drop.sql", "unique_id": "macro.dbt.drop_relation_if_exists", "macro_sql": "{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.09992, "supported_languages": null}, "macro.dbt.get_rename_sql": {"name": "get_rename_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename.sql", "original_file_path": "macros/relations/rename.sql", "unique_id": "macro.dbt.get_rename_sql", "macro_sql": "{%- macro get_rename_sql(relation, new_name) -%}\n    {{- log('Applying RENAME to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_rename_sql', 'dbt')(relation, new_name) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_rename_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1006596, "supported_languages": null}, "macro.dbt.default__get_rename_sql": {"name": "default__get_rename_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename.sql", "original_file_path": "macros/relations/rename.sql", "unique_id": "macro.dbt.default__get_rename_sql", "macro_sql": "{%- macro default__get_rename_sql(relation, new_name) -%}\n\n    {%- if relation.is_view -%}\n        {{ get_rename_view_sql(relation, new_name) }}\n\n    {%- elif relation.is_table -%}\n        {{ get_rename_table_sql(relation, new_name) }}\n\n    {%- elif relation.is_materialized_view -%}\n        {{ get_rename_materialized_view_sql(relation, new_name) }}\n\n    {%- else -%}\n        {{- exceptions.raise_compiler_error(\"`get_rename_sql` has not been implemented for: \" ~ relation.type ) -}}\n\n    {%- endif -%}\n\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.get_rename_view_sql", "macro.dbt.get_rename_table_sql", "macro.dbt.get_rename_materialized_view_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1013863, "supported_languages": null}, "macro.dbt.rename_relation": {"name": "rename_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename.sql", "original_file_path": "macros/relations/rename.sql", "unique_id": "macro.dbt.rename_relation", "macro_sql": "{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter.dispatch('rename_relation', 'dbt')(from_relation, to_relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__rename_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1016786, "supported_languages": null}, "macro.dbt.default__rename_relation": {"name": "default__rename_relation", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/rename.sql", "original_file_path": "macros/relations/rename.sql", "unique_id": "macro.dbt.default__rename_relation", "macro_sql": "{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation.render() }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1020703, "supported_languages": null}, "macro.dbt.get_create_sql": {"name": "get_create_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create.sql", "original_file_path": "macros/relations/create.sql", "unique_id": "macro.dbt.get_create_sql", "macro_sql": "{%- macro get_create_sql(relation, sql) -%}\n    {{- log('Applying CREATE to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_create_sql', 'dbt')(relation, sql) -}}\n{%- endmacro -%}\n\n\n", "depends_on": {"macros": ["macro.dbt.default__get_create_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1025379, "supported_languages": null}, "macro.dbt.default__get_create_sql": {"name": "default__get_create_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/create.sql", "original_file_path": "macros/relations/create.sql", "unique_id": "macro.dbt.default__get_create_sql", "macro_sql": "{%- macro default__get_create_sql(relation, sql) -%}\n\n    {%- if relation.is_view -%}\n        {{ get_create_view_as_sql(relation, sql) }}\n\n    {%- elif relation.is_table -%}\n        {{ get_create_table_as_sql(False, relation, sql) }}\n\n    {%- elif relation.is_materialized_view -%}\n        {{ get_create_materialized_view_as_sql(relation, sql) }}\n\n    {%- else -%}\n        {{- exceptions.raise_compiler_error(\"`get_create_sql` has not been implemented for: \" ~ relation.type ) -}}\n\n    {%- endif -%}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt.get_create_view_as_sql", "macro.dbt.get_create_table_as_sql", "macro.dbt.get_create_materialized_view_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1031172, "supported_languages": null}, "macro.dbt.get_replace_table_sql": {"name": "get_replace_table_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/replace.sql", "original_file_path": "macros/relations/table/replace.sql", "unique_id": "macro.dbt.get_replace_table_sql", "macro_sql": "{% macro get_replace_table_sql(relation, sql) %}\n    {{- adapter.dispatch('get_replace_table_sql', 'dbt')(relation, sql) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_replace_table_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1034677, "supported_languages": null}, "macro.dbt.default__get_replace_table_sql": {"name": "default__get_replace_table_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/replace.sql", "original_file_path": "macros/relations/table/replace.sql", "unique_id": "macro.dbt.default__get_replace_table_sql", "macro_sql": "{% macro default__get_replace_table_sql(relation, sql) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_replace_table_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1036868, "supported_languages": null}, "macro.dbt.drop_table": {"name": "drop_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/drop.sql", "original_file_path": "macros/relations/table/drop.sql", "unique_id": "macro.dbt.drop_table", "macro_sql": "{% macro drop_table(relation) -%}\n    {{- adapter.dispatch('drop_table', 'dbt')(relation) -}}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__drop_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.103999, "supported_languages": null}, "macro.dbt.default__drop_table": {"name": "default__drop_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/drop.sql", "original_file_path": "macros/relations/table/drop.sql", "unique_id": "macro.dbt.default__drop_table", "macro_sql": "{% macro default__drop_table(relation) -%}\n    drop table if exists {{ relation.render() }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1041615, "supported_languages": null}, "macro.dbt.get_rename_table_sql": {"name": "get_rename_table_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/rename.sql", "original_file_path": "macros/relations/table/rename.sql", "unique_id": "macro.dbt.get_rename_table_sql", "macro_sql": "{% macro get_rename_table_sql(relation, new_name) %}\n    {{- adapter.dispatch('get_rename_table_sql', 'dbt')(relation, new_name) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_rename_table_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1044881, "supported_languages": null}, "macro.dbt.default__get_rename_table_sql": {"name": "default__get_rename_table_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/rename.sql", "original_file_path": "macros/relations/table/rename.sql", "unique_id": "macro.dbt.default__get_rename_table_sql", "macro_sql": "{% macro default__get_rename_table_sql(relation, new_name) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_rename_table_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1047606, "supported_languages": null}, "macro.dbt.get_create_table_as_sql": {"name": "get_create_table_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.get_create_table_as_sql", "macro_sql": "{% macro get_create_table_as_sql(temporary, relation, sql) -%}\n  {{ adapter.dispatch('get_create_table_as_sql', 'dbt')(temporary, relation, sql) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_create_table_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1055508, "supported_languages": null}, "macro.dbt.default__get_create_table_as_sql": {"name": "default__get_create_table_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.default__get_create_table_as_sql", "macro_sql": "{% macro default__get_create_table_as_sql(temporary, relation, sql) -%}\n  {{ return(create_table_as(temporary, relation, sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.create_table_as"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1057975, "supported_languages": null}, "macro.dbt.create_table_as": {"name": "create_table_as", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.create_table_as", "macro_sql": "{% macro create_table_as(temporary, relation, compiled_code, language='sql') -%}\n  {# backward compatibility for create_table_as that does not support language #}\n  {% if language == \"sql\" %}\n    {{ adapter.dispatch('create_table_as', 'dbt')(temporary, relation, compiled_code)}}\n  {% else %}\n    {{ adapter.dispatch('create_table_as', 'dbt')(temporary, relation, compiled_code, language) }}\n  {% endif %}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__create_table_as"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1063542, "supported_languages": null}, "macro.dbt.default__create_table_as": {"name": "default__create_table_as", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.default__create_table_as", "macro_sql": "{% macro default__create_table_as(temporary, relation, sql) -%}\n  {%- set sql_header = config.get('sql_header', none) -%}\n\n  {{ sql_header if sql_header is not none }}\n\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  {% set contract_config = config.get('contract') %}\n  {% if contract_config.enforced and (not temporary) %}\n    {{ get_assert_columns_equivalent(sql) }}\n    {{ get_table_columns_and_constraints() }}\n    {%- set sql = get_select_subquery(sql) %}\n  {% endif %}\n  as (\n    {{ sql }}\n  );\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_assert_columns_equivalent", "macro.dbt.get_table_columns_and_constraints", "macro.dbt.get_select_subquery"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1072395, "supported_languages": null}, "macro.dbt.default__get_column_names": {"name": "default__get_column_names", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.default__get_column_names", "macro_sql": "{% macro default__get_column_names() %}\n  {#- loop through user_provided_columns to get column names -#}\n    {%- set user_provided_columns = model['columns'] -%}\n    {%- for i in user_provided_columns %}\n      {%- set col = user_provided_columns[i] -%}\n      {%- set col_name = adapter.quote(col['name']) if col.get('quote') else col['name'] -%}\n      {{ col_name }}{{ \", \" if not loop.last }}\n    {%- endfor -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1079493, "supported_languages": null}, "macro.dbt.get_select_subquery": {"name": "get_select_subquery", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.get_select_subquery", "macro_sql": "{% macro get_select_subquery(sql) %}\n  {{ return(adapter.dispatch('get_select_subquery', 'dbt')(sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_select_subquery"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1082597, "supported_languages": null}, "macro.dbt.default__get_select_subquery": {"name": "default__get_select_subquery", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/table/create.sql", "original_file_path": "macros/relations/table/create.sql", "unique_id": "macro.dbt.default__get_select_subquery", "macro_sql": "{% macro default__get_select_subquery(sql) %}\n    select {{ adapter.dispatch('get_column_names', 'dbt')() }}\n    from (\n        {{ sql }}\n    ) as model_subq\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_column_names"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1085548, "supported_languages": null}, "macro.dbt.get_alter_materialized_view_as_sql": {"name": "get_alter_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt.get_alter_materialized_view_as_sql", "macro_sql": "{% macro get_alter_materialized_view_as_sql(\n    relation,\n    configuration_changes,\n    sql,\n    existing_relation,\n    backup_relation,\n    intermediate_relation\n) %}\n    {{- log('Applying ALTER to: ' ~ relation) -}}\n    {{- adapter.dispatch('get_alter_materialized_view_as_sql', 'dbt')(\n        relation,\n        configuration_changes,\n        sql,\n        existing_relation,\n        backup_relation,\n        intermediate_relation\n    ) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_alter_materialized_view_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.109399, "supported_languages": null}, "macro.dbt.default__get_alter_materialized_view_as_sql": {"name": "default__get_alter_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt.default__get_alter_materialized_view_as_sql", "macro_sql": "{% macro default__get_alter_materialized_view_as_sql(\n    relation,\n    configuration_changes,\n    sql,\n    existing_relation,\n    backup_relation,\n    intermediate_relation\n) %}\n    {{ exceptions.raise_compiler_error(\"Materialized views have not been implemented for this adapter.\") }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1096585, "supported_languages": null}, "macro.dbt.get_materialized_view_configuration_changes": {"name": "get_materialized_view_configuration_changes", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt.get_materialized_view_configuration_changes", "macro_sql": "{% macro get_materialized_view_configuration_changes(existing_relation, new_config) %}\n    /* {#\n    It's recommended that configuration changes be formatted as follows:\n    {\"<change_category>\": [{\"action\": \"<name>\", \"context\": ...}]}\n\n    For example:\n    {\n        \"indexes\": [\n            {\"action\": \"drop\", \"context\": \"index_abc\"},\n            {\"action\": \"create\", \"context\": {\"columns\": [\"column_1\", \"column_2\"], \"type\": \"hash\", \"unique\": True}},\n        ],\n    }\n\n    Either way, `get_materialized_view_configuration_changes` needs to align with `get_alter_materialized_view_as_sql`.\n    #} */\n    {{- log('Determining configuration changes on: ' ~ existing_relation) -}}\n    {%- do return(adapter.dispatch('get_materialized_view_configuration_changes', 'dbt')(existing_relation, new_config)) -%}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_materialized_view_configuration_changes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.110021, "supported_languages": null}, "macro.dbt.default__get_materialized_view_configuration_changes": {"name": "default__get_materialized_view_configuration_changes", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/alter.sql", "original_file_path": "macros/relations/materialized_view/alter.sql", "unique_id": "macro.dbt.default__get_materialized_view_configuration_changes", "macro_sql": "{% macro default__get_materialized_view_configuration_changes(existing_relation, new_config) %}\n    {{ exceptions.raise_compiler_error(\"Materialized views have not been implemented for this adapter.\") }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1102154, "supported_languages": null}, "macro.dbt.refresh_materialized_view": {"name": "refresh_materialized_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/refresh.sql", "original_file_path": "macros/relations/materialized_view/refresh.sql", "unique_id": "macro.dbt.refresh_materialized_view", "macro_sql": "{% macro refresh_materialized_view(relation) %}\n    {{- log('Applying REFRESH to: ' ~ relation) -}}\n    {{- adapter.dispatch('refresh_materialized_view', 'dbt')(relation) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__refresh_materialized_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1105998, "supported_languages": null}, "macro.dbt.default__refresh_materialized_view": {"name": "default__refresh_materialized_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/refresh.sql", "original_file_path": "macros/relations/materialized_view/refresh.sql", "unique_id": "macro.dbt.default__refresh_materialized_view", "macro_sql": "{% macro default__refresh_materialized_view(relation) %}\n    {{ exceptions.raise_compiler_error(\"`refresh_materialized_view` has not been implemented for this adapter.\") }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.110777, "supported_languages": null}, "macro.dbt.get_replace_materialized_view_sql": {"name": "get_replace_materialized_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/replace.sql", "original_file_path": "macros/relations/materialized_view/replace.sql", "unique_id": "macro.dbt.get_replace_materialized_view_sql", "macro_sql": "{% macro get_replace_materialized_view_sql(relation, sql) %}\n    {{- adapter.dispatch('get_replace_materialized_view_sql', 'dbt')(relation, sql) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_replace_materialized_view_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1111078, "supported_languages": null}, "macro.dbt.default__get_replace_materialized_view_sql": {"name": "default__get_replace_materialized_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/replace.sql", "original_file_path": "macros/relations/materialized_view/replace.sql", "unique_id": "macro.dbt.default__get_replace_materialized_view_sql", "macro_sql": "{% macro default__get_replace_materialized_view_sql(relation, sql) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_replace_materialized_view_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1112971, "supported_languages": null}, "macro.dbt.drop_materialized_view": {"name": "drop_materialized_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/drop.sql", "original_file_path": "macros/relations/materialized_view/drop.sql", "unique_id": "macro.dbt.drop_materialized_view", "macro_sql": "{% macro drop_materialized_view(relation) -%}\n    {{- adapter.dispatch('drop_materialized_view', 'dbt')(relation) -}}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__drop_materialized_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1116369, "supported_languages": null}, "macro.dbt.default__drop_materialized_view": {"name": "default__drop_materialized_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/drop.sql", "original_file_path": "macros/relations/materialized_view/drop.sql", "unique_id": "macro.dbt.default__drop_materialized_view", "macro_sql": "{% macro default__drop_materialized_view(relation) -%}\n    drop materialized view if exists {{ relation.render() }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.111843, "supported_languages": null}, "macro.dbt.get_rename_materialized_view_sql": {"name": "get_rename_materialized_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/rename.sql", "original_file_path": "macros/relations/materialized_view/rename.sql", "unique_id": "macro.dbt.get_rename_materialized_view_sql", "macro_sql": "{% macro get_rename_materialized_view_sql(relation, new_name) %}\n    {{- adapter.dispatch('get_rename_materialized_view_sql', 'dbt')(relation, new_name) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_rename_materialized_view_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.11226, "supported_languages": null}, "macro.dbt.default__get_rename_materialized_view_sql": {"name": "default__get_rename_materialized_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/rename.sql", "original_file_path": "macros/relations/materialized_view/rename.sql", "unique_id": "macro.dbt.default__get_rename_materialized_view_sql", "macro_sql": "{% macro default__get_rename_materialized_view_sql(relation, new_name) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_rename_materialized_view_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.112589, "supported_languages": null}, "macro.dbt.get_create_materialized_view_as_sql": {"name": "get_create_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/create.sql", "original_file_path": "macros/relations/materialized_view/create.sql", "unique_id": "macro.dbt.get_create_materialized_view_as_sql", "macro_sql": "{% macro get_create_materialized_view_as_sql(relation, sql) -%}\n    {{- adapter.dispatch('get_create_materialized_view_as_sql', 'dbt')(relation, sql) -}}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_create_materialized_view_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.113014, "supported_languages": null}, "macro.dbt.default__get_create_materialized_view_as_sql": {"name": "default__get_create_materialized_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/materialized_view/create.sql", "original_file_path": "macros/relations/materialized_view/create.sql", "unique_id": "macro.dbt.default__get_create_materialized_view_as_sql", "macro_sql": "{% macro default__get_create_materialized_view_as_sql(relation, sql) -%}\n    {{ exceptions.raise_compiler_error(\n        \"`get_create_materialized_view_as_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1132498, "supported_languages": null}, "macro.dbt.get_table_columns_and_constraints": {"name": "get_table_columns_and_constraints", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.get_table_columns_and_constraints", "macro_sql": "{%- macro get_table_columns_and_constraints() -%}\n  {{ adapter.dispatch('get_table_columns_and_constraints', 'dbt')() }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__get_table_columns_and_constraints"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1142166, "supported_languages": null}, "macro.dbt.default__get_table_columns_and_constraints": {"name": "default__get_table_columns_and_constraints", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.default__get_table_columns_and_constraints", "macro_sql": "{% macro default__get_table_columns_and_constraints() -%}\n  {{ return(table_columns_and_constraints()) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.table_columns_and_constraints"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1143725, "supported_languages": null}, "macro.dbt.table_columns_and_constraints": {"name": "table_columns_and_constraints", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.table_columns_and_constraints", "macro_sql": "{% macro table_columns_and_constraints() %}\n  {# loop through user_provided_columns to create DDL with data types and constraints #}\n    {%- set raw_column_constraints = adapter.render_raw_columns_constraints(raw_columns=model['columns']) -%}\n    {%- set raw_model_constraints = adapter.render_raw_model_constraints(raw_constraints=model['constraints']) -%}\n    (\n    {% for c in raw_column_constraints -%}\n      {{ c }}{{ \",\" if not loop.last or raw_model_constraints }}\n    {% endfor %}\n    {% for c in raw_model_constraints -%}\n        {{ c }}{{ \",\" if not loop.last }}\n    {% endfor -%}\n    )\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.115045, "supported_languages": null}, "macro.dbt.get_assert_columns_equivalent": {"name": "get_assert_columns_equivalent", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.get_assert_columns_equivalent", "macro_sql": "\n\n{%- macro get_assert_columns_equivalent(sql) -%}\n  {{ adapter.dispatch('get_assert_columns_equivalent', 'dbt')(sql) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__get_assert_columns_equivalent"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1152577, "supported_languages": null}, "macro.dbt.default__get_assert_columns_equivalent": {"name": "default__get_assert_columns_equivalent", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.default__get_assert_columns_equivalent", "macro_sql": "{% macro default__get_assert_columns_equivalent(sql) -%}\n  {{ return(assert_columns_equivalent(sql)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.assert_columns_equivalent"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.115432, "supported_languages": null}, "macro.dbt.assert_columns_equivalent": {"name": "assert_columns_equivalent", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.assert_columns_equivalent", "macro_sql": "{% macro assert_columns_equivalent(sql) %}\n\n  {#-- First ensure the user has defined 'columns' in yaml specification --#}\n  {%- set user_defined_columns = model['columns'] -%}\n  {%- if not user_defined_columns -%}\n      {{ exceptions.raise_contract_error([], []) }}\n  {%- endif -%}\n\n  {#-- Obtain the column schema provided by sql file. #}\n  {%- set sql_file_provided_columns = get_column_schema_from_query(sql, config.get('sql_header', none)) -%}\n  {#--Obtain the column schema provided by the schema file by generating an 'empty schema' query from the model's columns. #}\n  {%- set schema_file_provided_columns = get_column_schema_from_query(get_empty_schema_sql(user_defined_columns)) -%}\n\n  {#-- create dictionaries with name and formatted data type and strings for exception #}\n  {%- set sql_columns = format_columns(sql_file_provided_columns) -%}\n  {%- set yaml_columns = format_columns(schema_file_provided_columns)  -%}\n\n  {%- if sql_columns|length != yaml_columns|length -%}\n    {%- do exceptions.raise_contract_error(yaml_columns, sql_columns) -%}\n  {%- endif -%}\n\n  {%- for sql_col in sql_columns -%}\n    {%- set yaml_col = [] -%}\n    {%- for this_col in yaml_columns -%}\n      {%- if this_col['name'] == sql_col['name'] -%}\n        {%- do yaml_col.append(this_col) -%}\n        {%- break -%}\n      {%- endif -%}\n    {%- endfor -%}\n    {%- if not yaml_col -%}\n      {#-- Column with name not found in yaml #}\n      {%- do exceptions.raise_contract_error(yaml_columns, sql_columns) -%}\n    {%- endif -%}\n    {%- if sql_col['formatted'] != yaml_col[0]['formatted'] -%}\n      {#-- Column data types don't match #}\n      {%- do exceptions.raise_contract_error(yaml_columns, sql_columns) -%}\n    {%- endif -%}\n  {%- endfor -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_column_schema_from_query", "macro.dbt.get_empty_schema_sql", "macro.dbt.format_columns"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.117502, "supported_languages": null}, "macro.dbt.format_columns": {"name": "format_columns", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.format_columns", "macro_sql": "{% macro format_columns(columns) %}\n  {% set formatted_columns = [] %}\n  {% for column in columns %}\n    {%- set formatted_column = adapter.dispatch('format_column', 'dbt')(column) -%}\n    {%- do formatted_columns.append(formatted_column) -%}\n  {% endfor %}\n  {{ return(formatted_columns) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__format_column"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.117986, "supported_languages": null}, "macro.dbt.default__format_column": {"name": "default__format_column", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/column/columns_spec_ddl.sql", "original_file_path": "macros/relations/column/columns_spec_ddl.sql", "unique_id": "macro.dbt.default__format_column", "macro_sql": "{% macro default__format_column(column) -%}\n  {% set data_type = column.dtype %}\n  {% set formatted = column.column.lower() ~ \" \" ~ data_type %}\n  {{ return({'name': column.name, 'data_type': data_type, 'formatted': formatted}) }}\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1184099, "supported_languages": null}, "macro.dbt.get_replace_view_sql": {"name": "get_replace_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt.get_replace_view_sql", "macro_sql": "{% macro get_replace_view_sql(relation, sql) %}\n    {{- adapter.dispatch('get_replace_view_sql', 'dbt')(relation, sql) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_replace_view_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1190517, "supported_languages": null}, "macro.dbt.default__get_replace_view_sql": {"name": "default__get_replace_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt.default__get_replace_view_sql", "macro_sql": "{% macro default__get_replace_view_sql(relation, sql) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_replace_view_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1192405, "supported_languages": null}, "macro.dbt.create_or_replace_view": {"name": "create_or_replace_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt.create_or_replace_view", "macro_sql": "{% macro create_or_replace_view() %}\n  {%- set identifier = model['alias'] -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n  {% set grant_config = config.get('grants') %}\n\n  {{ run_hooks(pre_hooks) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(should_full_refresh(), old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% call statement('main') -%}\n    {{ get_create_view_as_sql(target_relation, sql) }}\n  {%- endcall %}\n\n  {% set should_revoke = should_revoke(exists_as_view, full_refresh_mode=True) %}\n  {% do apply_grants(target_relation, grant_config, should_revoke=should_revoke) %}\n\n  {{ run_hooks(post_hooks) }}\n\n  {{ return({'relations': [target_relation]}) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_hooks", "macro.dbt.handle_existing_table", "macro.dbt.should_full_refresh", "macro.dbt.statement", "macro.dbt.get_create_view_as_sql", "macro.dbt.should_revoke", "macro.dbt.apply_grants"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.12108, "supported_languages": null}, "macro.dbt.handle_existing_table": {"name": "handle_existing_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt.handle_existing_table", "macro_sql": "{% macro handle_existing_table(full_refresh, old_relation) %}\n    {{ adapter.dispatch('handle_existing_table', 'dbt')(full_refresh, old_relation) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__handle_existing_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1214113, "supported_languages": null}, "macro.dbt.default__handle_existing_table": {"name": "default__handle_existing_table", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/replace.sql", "original_file_path": "macros/relations/view/replace.sql", "unique_id": "macro.dbt.default__handle_existing_table", "macro_sql": "{% macro default__handle_existing_table(full_refresh, old_relation) %}\n    {{ log(\"Dropping relation \" ~ old_relation.render() ~ \" because it is of type \" ~ old_relation.type) }}\n    {{ adapter.drop_relation(old_relation) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1217356, "supported_languages": null}, "macro.dbt.drop_view": {"name": "drop_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/drop.sql", "original_file_path": "macros/relations/view/drop.sql", "unique_id": "macro.dbt.drop_view", "macro_sql": "{% macro drop_view(relation) -%}\n    {{- adapter.dispatch('drop_view', 'dbt')(relation) -}}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__drop_view"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1220527, "supported_languages": null}, "macro.dbt.default__drop_view": {"name": "default__drop_view", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/drop.sql", "original_file_path": "macros/relations/view/drop.sql", "unique_id": "macro.dbt.default__drop_view", "macro_sql": "{% macro default__drop_view(relation) -%}\n    drop view if exists {{ relation.render() }} cascade\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1222155, "supported_languages": null}, "macro.dbt.get_rename_view_sql": {"name": "get_rename_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/rename.sql", "original_file_path": "macros/relations/view/rename.sql", "unique_id": "macro.dbt.get_rename_view_sql", "macro_sql": "{% macro get_rename_view_sql(relation, new_name) %}\n    {{- adapter.dispatch('get_rename_view_sql', 'dbt')(relation, new_name) -}}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__get_rename_view_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1225493, "supported_languages": null}, "macro.dbt.default__get_rename_view_sql": {"name": "default__get_rename_view_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/rename.sql", "original_file_path": "macros/relations/view/rename.sql", "unique_id": "macro.dbt.default__get_rename_view_sql", "macro_sql": "{% macro default__get_rename_view_sql(relation, new_name) %}\n    {{ exceptions.raise_compiler_error(\n        \"`get_rename_view_sql` has not been implemented for this adapter.\"\n    ) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1227405, "supported_languages": null}, "macro.dbt.get_create_view_as_sql": {"name": "get_create_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/create.sql", "original_file_path": "macros/relations/view/create.sql", "unique_id": "macro.dbt.get_create_view_as_sql", "macro_sql": "{% macro get_create_view_as_sql(relation, sql) -%}\n  {{ adapter.dispatch('get_create_view_as_sql', 'dbt')(relation, sql) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_create_view_as_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.123189, "supported_languages": null}, "macro.dbt.default__get_create_view_as_sql": {"name": "default__get_create_view_as_sql", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/create.sql", "original_file_path": "macros/relations/view/create.sql", "unique_id": "macro.dbt.default__get_create_view_as_sql", "macro_sql": "{% macro default__get_create_view_as_sql(relation, sql) -%}\n  {{ return(create_view_as(relation, sql)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.create_view_as"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.123394, "supported_languages": null}, "macro.dbt.create_view_as": {"name": "create_view_as", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/create.sql", "original_file_path": "macros/relations/view/create.sql", "unique_id": "macro.dbt.create_view_as", "macro_sql": "{% macro create_view_as(relation, sql) -%}\n  {{ adapter.dispatch('create_view_as', 'dbt')(relation, sql) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__create_view_as"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1236265, "supported_languages": null}, "macro.dbt.default__create_view_as": {"name": "default__create_view_as", "resource_type": "macro", "package_name": "dbt", "path": "macros/relations/view/create.sql", "original_file_path": "macros/relations/view/create.sql", "unique_id": "macro.dbt.default__create_view_as", "macro_sql": "{% macro default__create_view_as(relation, sql) -%}\n  {%- set sql_header = config.get('sql_header', none) -%}\n\n  {{ sql_header if sql_header is not none }}\n  create view {{ relation.render() }}\n    {% set contract_config = config.get('contract') %}\n    {% if contract_config.enforced %}\n      {{ get_assert_columns_equivalent(sql) }}\n    {%- endif %}\n  as (\n    {{ sql }}\n  );\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.get_assert_columns_equivalent"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1241784, "supported_languages": null}, "macro.dbt.cast_bool_to_text": {"name": "cast_bool_to_text", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/cast_bool_to_text.sql", "original_file_path": "macros/utils/cast_bool_to_text.sql", "unique_id": "macro.dbt.cast_bool_to_text", "macro_sql": "{% macro cast_bool_to_text(field) %}\n  {{ adapter.dispatch('cast_bool_to_text', 'dbt') (field) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__cast_bool_to_text"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1244836, "supported_languages": null}, "macro.dbt.default__cast_bool_to_text": {"name": "default__cast_bool_to_text", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/cast_bool_to_text.sql", "original_file_path": "macros/utils/cast_bool_to_text.sql", "unique_id": "macro.dbt.default__cast_bool_to_text", "macro_sql": "{% macro default__cast_bool_to_text(field) %}\n    cast({{ field }} as {{ api.Column.translate_type('string') }})\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1246862, "supported_languages": null}, "macro.dbt.get_powers_of_two": {"name": "get_powers_of_two", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/generate_series.sql", "original_file_path": "macros/utils/generate_series.sql", "unique_id": "macro.dbt.get_powers_of_two", "macro_sql": "{% macro get_powers_of_two(upper_bound) %}\n    {{ return(adapter.dispatch('get_powers_of_two', 'dbt')(upper_bound)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_powers_of_two"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1252258, "supported_languages": null}, "macro.dbt.default__get_powers_of_two": {"name": "default__get_powers_of_two", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/generate_series.sql", "original_file_path": "macros/utils/generate_series.sql", "unique_id": "macro.dbt.default__get_powers_of_two", "macro_sql": "{% macro default__get_powers_of_two(upper_bound) %}\n\n    {% if upper_bound <= 0 %}\n    {{ exceptions.raise_compiler_error(\"upper bound must be positive\") }}\n    {% endif %}\n\n    {% for _ in range(1, 100) %}\n       {% if upper_bound <= 2 ** loop.index %}{{ return(loop.index) }}{% endif %}\n    {% endfor %}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.12578, "supported_languages": null}, "macro.dbt.generate_series": {"name": "generate_series", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/generate_series.sql", "original_file_path": "macros/utils/generate_series.sql", "unique_id": "macro.dbt.generate_series", "macro_sql": "{% macro generate_series(upper_bound) %}\n    {{ return(adapter.dispatch('generate_series', 'dbt')(upper_bound)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__generate_series"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1260238, "supported_languages": null}, "macro.dbt.default__generate_series": {"name": "default__generate_series", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/generate_series.sql", "original_file_path": "macros/utils/generate_series.sql", "unique_id": "macro.dbt.default__generate_series", "macro_sql": "{% macro default__generate_series(upper_bound) %}\n\n    {% set n = dbt.get_powers_of_two(upper_bound) %}\n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    {% for i in range(n) %}\n    p{{i}}.generated_number * power(2, {{i}})\n    {% if not loop.last %} + {% endif %}\n    {% endfor %}\n    + 1\n    as generated_number\n\n    from\n\n    {% for i in range(n) %}\n    p as p{{i}}\n    {% if not loop.last %} cross join {% endif %}\n    {% endfor %}\n\n    )\n\n    select *\n    from unioned\n    where generated_number <= {{upper_bound}}\n    order by generated_number\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.get_powers_of_two"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1266816, "supported_languages": null}, "macro.dbt.cast": {"name": "cast", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/cast.sql", "original_file_path": "macros/utils/cast.sql", "unique_id": "macro.dbt.cast", "macro_sql": "{% macro cast(field, type) %}\n  {{ return(adapter.dispatch('cast', 'dbt') (field, type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1270328, "supported_languages": null}, "macro.dbt.default__cast": {"name": "default__cast", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/cast.sql", "original_file_path": "macros/utils/cast.sql", "unique_id": "macro.dbt.default__cast", "macro_sql": "{% macro default__cast(field, type) %}\n    cast({{field}} as {{type}})\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1272006, "supported_languages": null}, "macro.dbt.length": {"name": "length", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/length.sql", "original_file_path": "macros/utils/length.sql", "unique_id": "macro.dbt.length", "macro_sql": "{% macro length(expression) -%}\n    {{ return(adapter.dispatch('length', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__length"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1275287, "supported_languages": null}, "macro.dbt.default__length": {"name": "default__length", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/length.sql", "original_file_path": "macros/utils/length.sql", "unique_id": "macro.dbt.default__length", "macro_sql": "{% macro default__length(expression) %}\n\n    length(\n        {{ expression }}\n    )\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1277142, "supported_languages": null}, "macro.dbt.string_literal": {"name": "string_literal", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/literal.sql", "original_file_path": "macros/utils/literal.sql", "unique_id": "macro.dbt.string_literal", "macro_sql": "{%- macro string_literal(value) -%}\n  {{ return(adapter.dispatch('string_literal', 'dbt') (value)) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__string_literal"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1283696, "supported_languages": null}, "macro.dbt.default__string_literal": {"name": "default__string_literal", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/literal.sql", "original_file_path": "macros/utils/literal.sql", "unique_id": "macro.dbt.default__string_literal", "macro_sql": "{% macro default__string_literal(value) -%}\n    '{{ value }}'\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1285481, "supported_languages": null}, "macro.dbt.escape_single_quotes": {"name": "escape_single_quotes", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/escape_single_quotes.sql", "original_file_path": "macros/utils/escape_single_quotes.sql", "unique_id": "macro.dbt.escape_single_quotes", "macro_sql": "{% macro escape_single_quotes(expression) %}\n      {{ return(adapter.dispatch('escape_single_quotes', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__escape_single_quotes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1289735, "supported_languages": null}, "macro.dbt.default__escape_single_quotes": {"name": "default__escape_single_quotes", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/escape_single_quotes.sql", "original_file_path": "macros/utils/escape_single_quotes.sql", "unique_id": "macro.dbt.default__escape_single_quotes", "macro_sql": "{% macro default__escape_single_quotes(expression) -%}\n{{ expression | replace(\"'\",\"''\") }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1292028, "supported_languages": null}, "macro.dbt.split_part": {"name": "split_part", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/split_part.sql", "original_file_path": "macros/utils/split_part.sql", "unique_id": "macro.dbt.split_part", "macro_sql": "{% macro split_part(string_text, delimiter_text, part_number) %}\n  {{ return(adapter.dispatch('split_part', 'dbt') (string_text, delimiter_text, part_number)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__split_part"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1297197, "supported_languages": null}, "macro.dbt.default__split_part": {"name": "default__split_part", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/split_part.sql", "original_file_path": "macros/utils/split_part.sql", "unique_id": "macro.dbt.default__split_part", "macro_sql": "{% macro default__split_part(string_text, delimiter_text, part_number) %}\n\n    split_part(\n        {{ string_text }},\n        {{ delimiter_text }},\n        {{ part_number }}\n        )\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1299403, "supported_languages": null}, "macro.dbt._split_part_negative": {"name": "_split_part_negative", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/split_part.sql", "original_file_path": "macros/utils/split_part.sql", "unique_id": "macro.dbt._split_part_negative", "macro_sql": "{% macro _split_part_negative(string_text, delimiter_text, part_number) %}\n\n    split_part(\n        {{ string_text }},\n        {{ delimiter_text }},\n          length({{ string_text }})\n          - length(\n              replace({{ string_text }},  {{ delimiter_text }}, '')\n          ) + 2 + {{ part_number }}\n        )\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1302323, "supported_languages": null}, "macro.dbt.array_construct": {"name": "array_construct", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_construct.sql", "original_file_path": "macros/utils/array_construct.sql", "unique_id": "macro.dbt.array_construct", "macro_sql": "{% macro array_construct(inputs=[], data_type=api.Column.translate_type('integer')) -%}\n  {{ return(adapter.dispatch('array_construct', 'dbt')(inputs, data_type)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__array_construct"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.130695, "supported_languages": null}, "macro.dbt.default__array_construct": {"name": "default__array_construct", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_construct.sql", "original_file_path": "macros/utils/array_construct.sql", "unique_id": "macro.dbt.default__array_construct", "macro_sql": "{% macro default__array_construct(inputs, data_type) -%}\n    {% if inputs|length > 0 %}\n    array[ {{ inputs|join(' , ') }} ]\n    {% else %}\n    array[]::{{data_type}}[]\n    {% endif %}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1310027, "supported_languages": null}, "macro.dbt.right": {"name": "right", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/right.sql", "original_file_path": "macros/utils/right.sql", "unique_id": "macro.dbt.right", "macro_sql": "{% macro right(string_text, length_expression) -%}\n    {{ return(adapter.dispatch('right', 'dbt') (string_text, length_expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__right"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1313474, "supported_languages": null}, "macro.dbt.default__right": {"name": "default__right", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/right.sql", "original_file_path": "macros/utils/right.sql", "unique_id": "macro.dbt.default__right", "macro_sql": "{% macro default__right(string_text, length_expression) %}\n\n    right(\n        {{ string_text }},\n        {{ length_expression }}\n    )\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1315303, "supported_languages": null}, "macro.dbt.any_value": {"name": "any_value", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/any_value.sql", "original_file_path": "macros/utils/any_value.sql", "unique_id": "macro.dbt.any_value", "macro_sql": "{% macro any_value(expression) -%}\n    {{ return(adapter.dispatch('any_value', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__any_value"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1318333, "supported_languages": null}, "macro.dbt.default__any_value": {"name": "default__any_value", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/any_value.sql", "original_file_path": "macros/utils/any_value.sql", "unique_id": "macro.dbt.default__any_value", "macro_sql": "{% macro default__any_value(expression) -%}\n\n    any_value({{ expression }})\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1319742, "supported_languages": null}, "macro.dbt.concat": {"name": "concat", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/concat.sql", "original_file_path": "macros/utils/concat.sql", "unique_id": "macro.dbt.concat", "macro_sql": "{% macro concat(fields) -%}\n  {{ return(adapter.dispatch('concat', 'dbt')(fields)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1322849, "supported_languages": null}, "macro.dbt.default__concat": {"name": "default__concat", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/concat.sql", "original_file_path": "macros/utils/concat.sql", "unique_id": "macro.dbt.default__concat", "macro_sql": "{% macro default__concat(fields) -%}\n    {{ fields|join(' || ') }}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1324532, "supported_languages": null}, "macro.dbt.date": {"name": "date", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date.sql", "original_file_path": "macros/utils/date.sql", "unique_id": "macro.dbt.date", "macro_sql": "{% macro date(year, month, day) %}\n  {{ return(adapter.dispatch('date', 'dbt') (year, month, day)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__date"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.132849, "supported_languages": null}, "macro.dbt.default__date": {"name": "default__date", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date.sql", "original_file_path": "macros/utils/date.sql", "unique_id": "macro.dbt.default__date", "macro_sql": "{% macro default__date(year, month, day) -%}\n    {%- set dt = modules.datetime.date(year, month, day) -%}\n    {%- set iso_8601_formatted_date = dt.strftime('%Y-%m-%d') -%}\n    to_date('{{ iso_8601_formatted_date }}', 'YYYY-MM-DD')\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1332145, "supported_languages": null}, "macro.dbt.array_append": {"name": "array_append", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_append.sql", "original_file_path": "macros/utils/array_append.sql", "unique_id": "macro.dbt.array_append", "macro_sql": "{% macro array_append(array, new_element) -%}\n  {{ return(adapter.dispatch('array_append', 'dbt')(array, new_element)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__array_append"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1335795, "supported_languages": null}, "macro.dbt.default__array_append": {"name": "default__array_append", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_append.sql", "original_file_path": "macros/utils/array_append.sql", "unique_id": "macro.dbt.default__array_append", "macro_sql": "{% macro default__array_append(array, new_element) -%}\n    array_append({{ array }}, {{ new_element }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1337576, "supported_languages": null}, "macro.dbt.datediff": {"name": "datediff", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/datediff.sql", "original_file_path": "macros/utils/datediff.sql", "unique_id": "macro.dbt.datediff", "macro_sql": "{% macro datediff(first_date, second_date, datepart) %}\n  {{ return(adapter.dispatch('datediff', 'dbt')(first_date, second_date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1341438, "supported_languages": null}, "macro.dbt.default__datediff": {"name": "default__datediff", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/datediff.sql", "original_file_path": "macros/utils/datediff.sql", "unique_id": "macro.dbt.default__datediff", "macro_sql": "{% macro default__datediff(first_date, second_date, datepart) -%}\n\n    datediff(\n        {{ datepart }},\n        {{ first_date }},\n        {{ second_date }}\n        )\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.134436, "supported_languages": null}, "macro.dbt.safe_cast": {"name": "safe_cast", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/safe_cast.sql", "original_file_path": "macros/utils/safe_cast.sql", "unique_id": "macro.dbt.safe_cast", "macro_sql": "{% macro safe_cast(field, type) %}\n  {{ return(adapter.dispatch('safe_cast', 'dbt') (field, type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__safe_cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.134802, "supported_languages": null}, "macro.dbt.default__safe_cast": {"name": "default__safe_cast", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/safe_cast.sql", "original_file_path": "macros/utils/safe_cast.sql", "unique_id": "macro.dbt.default__safe_cast", "macro_sql": "{% macro default__safe_cast(field, type) %}\n    {# most databases don't support this function yet\n    so we just need to use cast #}\n    cast({{field}} as {{type}})\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1349857, "supported_languages": null}, "macro.dbt.type_string": {"name": "type_string", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_string", "macro_sql": "\n\n{%- macro type_string() -%}\n  {{ return(adapter.dispatch('type_string', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1358593, "supported_languages": null}, "macro.dbt.default__type_string": {"name": "default__type_string", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_string", "macro_sql": "{% macro default__type_string() %}\n    {{ return(api.Column.translate_type(\"string\")) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1360614, "supported_languages": null}, "macro.dbt.type_timestamp": {"name": "type_timestamp", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_timestamp", "macro_sql": "\n\n{%- macro type_timestamp() -%}\n  {{ return(adapter.dispatch('type_timestamp', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1362705, "supported_languages": null}, "macro.dbt.default__type_timestamp": {"name": "default__type_timestamp", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_timestamp", "macro_sql": "{% macro default__type_timestamp() %}\n    {{ return(api.Column.translate_type(\"timestamp\")) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1364632, "supported_languages": null}, "macro.dbt.type_float": {"name": "type_float", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_float", "macro_sql": "\n\n{%- macro type_float() -%}\n  {{ return(adapter.dispatch('type_float', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_float"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1366642, "supported_languages": null}, "macro.dbt.default__type_float": {"name": "default__type_float", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_float", "macro_sql": "{% macro default__type_float() %}\n    {{ return(api.Column.translate_type(\"float\")) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1368554, "supported_languages": null}, "macro.dbt.type_numeric": {"name": "type_numeric", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_numeric", "macro_sql": "\n\n{%- macro type_numeric() -%}\n  {{ return(adapter.dispatch('type_numeric', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_numeric"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1370585, "supported_languages": null}, "macro.dbt.default__type_numeric": {"name": "default__type_numeric", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_numeric", "macro_sql": "{% macro default__type_numeric() %}\n    {{ return(api.Column.numeric_type(\"numeric\", 28, 6)) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.137279, "supported_languages": null}, "macro.dbt.type_bigint": {"name": "type_bigint", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_bigint", "macro_sql": "\n\n{%- macro type_bigint() -%}\n  {{ return(adapter.dispatch('type_bigint', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_bigint"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1374974, "supported_languages": null}, "macro.dbt.default__type_bigint": {"name": "default__type_bigint", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_bigint", "macro_sql": "{% macro default__type_bigint() %}\n    {{ return(api.Column.translate_type(\"bigint\")) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1376894, "supported_languages": null}, "macro.dbt.type_int": {"name": "type_int", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_int", "macro_sql": "\n\n{%- macro type_int() -%}\n  {{ return(adapter.dispatch('type_int', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_int"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1378908, "supported_languages": null}, "macro.dbt.default__type_int": {"name": "default__type_int", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_int", "macro_sql": "{%- macro default__type_int() -%}\n  {{ return(api.Column.translate_type(\"integer\")) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1380775, "supported_languages": null}, "macro.dbt.type_boolean": {"name": "type_boolean", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.type_boolean", "macro_sql": "\n\n{%- macro type_boolean() -%}\n  {{ return(adapter.dispatch('type_boolean', 'dbt')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.default__type_boolean"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1382804, "supported_languages": null}, "macro.dbt.default__type_boolean": {"name": "default__type_boolean", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/data_types.sql", "original_file_path": "macros/utils/data_types.sql", "unique_id": "macro.dbt.default__type_boolean", "macro_sql": "{%- macro default__type_boolean() -%}\n  {{ return(api.Column.translate_type(\"boolean\")) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.138462, "supported_languages": null}, "macro.dbt.get_intervals_between": {"name": "get_intervals_between", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_spine.sql", "original_file_path": "macros/utils/date_spine.sql", "unique_id": "macro.dbt.get_intervals_between", "macro_sql": "{% macro get_intervals_between(start_date, end_date, datepart) -%}\n    {{ return(adapter.dispatch('get_intervals_between', 'dbt')(start_date, end_date, datepart)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__get_intervals_between"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1390913, "supported_languages": null}, "macro.dbt.default__get_intervals_between": {"name": "default__get_intervals_between", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_spine.sql", "original_file_path": "macros/utils/date_spine.sql", "unique_id": "macro.dbt.default__get_intervals_between", "macro_sql": "{% macro default__get_intervals_between(start_date, end_date, datepart) -%}\n    {%- call statement('get_intervals_between', fetch_result=True) %}\n\n        select {{ dbt.datediff(start_date, end_date, datepart) }}\n\n    {%- endcall -%}\n\n    {%- set value_list = load_result('get_intervals_between') -%}\n\n    {%- if value_list and value_list['data'] -%}\n        {%- set values = value_list['data'] | map(attribute=0) | list %}\n        {{ return(values[0]) }}\n    {%- else -%}\n        {{ return(1) }}\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt.datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1399424, "supported_languages": null}, "macro.dbt.date_spine": {"name": "date_spine", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_spine.sql", "original_file_path": "macros/utils/date_spine.sql", "unique_id": "macro.dbt.date_spine", "macro_sql": "{% macro date_spine(datepart, start_date, end_date) %}\n    {{ return(adapter.dispatch('date_spine', 'dbt')(datepart, start_date, end_date)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__date_spine"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1402411, "supported_languages": null}, "macro.dbt.default__date_spine": {"name": "default__date_spine", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_spine.sql", "original_file_path": "macros/utils/date_spine.sql", "unique_id": "macro.dbt.default__date_spine", "macro_sql": "{% macro default__date_spine(datepart, start_date, end_date) %}\n\n\n    {# call as follows:\n\n    date_spine(\n        \"day\",\n        \"to_date('01/01/2016', 'mm/dd/yyyy')\",\n        \"dbt.dateadd(week, 1, current_date)\"\n    ) #}\n\n\n    with rawdata as (\n\n        {{dbt.generate_series(\n            dbt.get_intervals_between(start_date, end_date, datepart)\n        )}}\n\n    ),\n\n    all_periods as (\n\n        select (\n            {{\n                dbt.dateadd(\n                    datepart,\n                    \"row_number() over (order by 1) - 1\",\n                    start_date\n                )\n            }}\n        ) as date_{{datepart}}\n        from rawdata\n\n    ),\n\n    filtered as (\n\n        select *\n        from all_periods\n        where date_{{datepart}} <= {{ end_date }}\n\n    )\n\n    select * from filtered\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.generate_series", "macro.dbt.get_intervals_between", "macro.dbt.dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.14071, "supported_languages": null}, "macro.dbt.bool_or": {"name": "bool_or", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/bool_or.sql", "original_file_path": "macros/utils/bool_or.sql", "unique_id": "macro.dbt.bool_or", "macro_sql": "{% macro bool_or(expression) -%}\n    {{ return(adapter.dispatch('bool_or', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__bool_or"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1410306, "supported_languages": null}, "macro.dbt.default__bool_or": {"name": "default__bool_or", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/bool_or.sql", "original_file_path": "macros/utils/bool_or.sql", "unique_id": "macro.dbt.default__bool_or", "macro_sql": "{% macro default__bool_or(expression) -%}\n\n    bool_or({{ expression }})\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1411693, "supported_languages": null}, "macro.dbt.dateadd": {"name": "dateadd", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/dateadd.sql", "original_file_path": "macros/utils/dateadd.sql", "unique_id": "macro.dbt.dateadd", "macro_sql": "{% macro dateadd(datepart, interval, from_date_or_timestamp) %}\n  {{ return(adapter.dispatch('dateadd', 'dbt')(datepart, interval, from_date_or_timestamp)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1415918, "supported_languages": null}, "macro.dbt.default__dateadd": {"name": "default__dateadd", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/dateadd.sql", "original_file_path": "macros/utils/dateadd.sql", "unique_id": "macro.dbt.default__dateadd", "macro_sql": "{% macro default__dateadd(datepart, interval, from_date_or_timestamp) %}\n\n    dateadd(\n        {{ datepart }},\n        {{ interval }},\n        {{ from_date_or_timestamp }}\n        )\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1418164, "supported_languages": null}, "macro.dbt.listagg": {"name": "listagg", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/listagg.sql", "original_file_path": "macros/utils/listagg.sql", "unique_id": "macro.dbt.listagg", "macro_sql": "{% macro listagg(measure, delimiter_text=\"','\", order_by_clause=none, limit_num=none) -%}\n    {{ return(adapter.dispatch('listagg', 'dbt') (measure, delimiter_text, order_by_clause, limit_num)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__listagg"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1423748, "supported_languages": null}, "macro.dbt.default__listagg": {"name": "default__listagg", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/listagg.sql", "original_file_path": "macros/utils/listagg.sql", "unique_id": "macro.dbt.default__listagg", "macro_sql": "{% macro default__listagg(measure, delimiter_text, order_by_clause, limit_num) -%}\n\n    {% if limit_num -%}\n    array_to_string(\n        array_slice(\n            array_agg(\n                {{ measure }}\n            ){% if order_by_clause -%}\n            within group ({{ order_by_clause }})\n            {%- endif %}\n            ,0\n            ,{{ limit_num }}\n        ),\n        {{ delimiter_text }}\n        )\n    {%- else %}\n    listagg(\n        {{ measure }},\n        {{ delimiter_text }}\n        )\n        {% if order_by_clause -%}\n        within group ({{ order_by_clause }})\n        {%- endif %}\n    {%- endif %}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.142896, "supported_languages": null}, "macro.dbt.replace": {"name": "replace", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/replace.sql", "original_file_path": "macros/utils/replace.sql", "unique_id": "macro.dbt.replace", "macro_sql": "{% macro replace(field, old_chars, new_chars) -%}\n    {{ return(adapter.dispatch('replace', 'dbt') (field, old_chars, new_chars)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__replace"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.143275, "supported_languages": null}, "macro.dbt.default__replace": {"name": "default__replace", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/replace.sql", "original_file_path": "macros/utils/replace.sql", "unique_id": "macro.dbt.default__replace", "macro_sql": "{% macro default__replace(field, old_chars, new_chars) %}\n\n    replace(\n        {{ field }},\n        {{ old_chars }},\n        {{ new_chars }}\n    )\n\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.143488, "supported_languages": null}, "macro.dbt.except": {"name": "except", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/except.sql", "original_file_path": "macros/utils/except.sql", "unique_id": "macro.dbt.except", "macro_sql": "{% macro except() %}\n  {{ return(adapter.dispatch('except', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__except"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1437738, "supported_languages": null}, "macro.dbt.default__except": {"name": "default__except", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/except.sql", "original_file_path": "macros/utils/except.sql", "unique_id": "macro.dbt.default__except", "macro_sql": "{% macro default__except() %}\n\n    except\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1438782, "supported_languages": null}, "macro.dbt.hash": {"name": "hash", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/hash.sql", "original_file_path": "macros/utils/hash.sql", "unique_id": "macro.dbt.hash", "macro_sql": "{% macro hash(field) -%}\n  {{ return(adapter.dispatch('hash', 'dbt') (field)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__hash"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1441977, "supported_languages": null}, "macro.dbt.default__hash": {"name": "default__hash", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/hash.sql", "original_file_path": "macros/utils/hash.sql", "unique_id": "macro.dbt.default__hash", "macro_sql": "{% macro default__hash(field) -%}\n    md5(cast({{ field }} as {{ api.Column.translate_type('string') }}))\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1444046, "supported_languages": null}, "macro.dbt.last_day": {"name": "last_day", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/last_day.sql", "original_file_path": "macros/utils/last_day.sql", "unique_id": "macro.dbt.last_day", "macro_sql": "{% macro last_day(date, datepart) %}\n  {{ return(adapter.dispatch('last_day', 'dbt') (date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_postgres.postgres__last_day"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1447897, "supported_languages": null}, "macro.dbt.default_last_day": {"name": "default_last_day", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/last_day.sql", "original_file_path": "macros/utils/last_day.sql", "unique_id": "macro.dbt.default_last_day", "macro_sql": "\n\n{%- macro default_last_day(date, datepart) -%}\n    cast(\n        {{dbt.dateadd('day', '-1',\n        dbt.dateadd(datepart, '1', dbt.date_trunc(datepart, date))\n        )}}\n        as date)\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt.dateadd", "macro.dbt.date_trunc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1451206, "supported_languages": null}, "macro.dbt.default__last_day": {"name": "default__last_day", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/last_day.sql", "original_file_path": "macros/utils/last_day.sql", "unique_id": "macro.dbt.default__last_day", "macro_sql": "{% macro default__last_day(date, datepart) -%}\n    {{dbt.default_last_day(date, datepart)}}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default_last_day"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1453137, "supported_languages": null}, "macro.dbt.date_trunc": {"name": "date_trunc", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_trunc.sql", "original_file_path": "macros/utils/date_trunc.sql", "unique_id": "macro.dbt.date_trunc", "macro_sql": "{% macro date_trunc(datepart, date) -%}\n  {{ return(adapter.dispatch('date_trunc', 'dbt') (datepart, date)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__date_trunc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1456735, "supported_languages": null}, "macro.dbt.default__date_trunc": {"name": "default__date_trunc", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/date_trunc.sql", "original_file_path": "macros/utils/date_trunc.sql", "unique_id": "macro.dbt.default__date_trunc", "macro_sql": "{% macro default__date_trunc(datepart, date) -%}\n    date_trunc('{{datepart}}', {{date}})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.145847, "supported_languages": null}, "macro.dbt.intersect": {"name": "intersect", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/intersect.sql", "original_file_path": "macros/utils/intersect.sql", "unique_id": "macro.dbt.intersect", "macro_sql": "{% macro intersect() %}\n  {{ return(adapter.dispatch('intersect', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__intersect"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1461263, "supported_languages": null}, "macro.dbt.default__intersect": {"name": "default__intersect", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/intersect.sql", "original_file_path": "macros/utils/intersect.sql", "unique_id": "macro.dbt.default__intersect", "macro_sql": "{% macro default__intersect() %}\n\n    intersect\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.146307, "supported_languages": null}, "macro.dbt.equals": {"name": "equals", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/equals.sql", "original_file_path": "macros/utils/equals.sql", "unique_id": "macro.dbt.equals", "macro_sql": "{% macro equals(expr1, expr2) %}\n    {{ return(adapter.dispatch('equals', 'dbt') (expr1, expr2)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__equals"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1467116, "supported_languages": null}, "macro.dbt.default__equals": {"name": "default__equals", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/equals.sql", "original_file_path": "macros/utils/equals.sql", "unique_id": "macro.dbt.default__equals", "macro_sql": "{% macro default__equals(expr1, expr2) -%}\n{%- if adapter.behavior.enable_truthy_nulls_equals_macro.no_warn %}\n    case when (({{ expr1 }} = {{ expr2 }}) or ({{ expr1 }} is null and {{ expr2 }} is null))\n        then 0\n        else 1\n    end = 0\n{%- else -%}\n    ({{ expr1 }} = {{ expr2 }})\n{%- endif %}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1470876, "supported_languages": null}, "macro.dbt.position": {"name": "position", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/position.sql", "original_file_path": "macros/utils/position.sql", "unique_id": "macro.dbt.position", "macro_sql": "{% macro position(substring_text, string_text) -%}\n    {{ return(adapter.dispatch('position', 'dbt') (substring_text, string_text)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.default__position"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1474319, "supported_languages": null}, "macro.dbt.default__position": {"name": "default__position", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/position.sql", "original_file_path": "macros/utils/position.sql", "unique_id": "macro.dbt.default__position", "macro_sql": "{% macro default__position(substring_text, string_text) %}\n\n    position(\n        {{ substring_text }} in {{ string_text }}\n    )\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1476138, "supported_languages": null}, "macro.dbt.array_concat": {"name": "array_concat", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_concat.sql", "original_file_path": "macros/utils/array_concat.sql", "unique_id": "macro.dbt.array_concat", "macro_sql": "{% macro array_concat(array_1, array_2) -%}\n  {{ return(adapter.dispatch('array_concat', 'dbt')(array_1, array_2)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.default__array_concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.147944, "supported_languages": null}, "macro.dbt.default__array_concat": {"name": "default__array_concat", "resource_type": "macro", "package_name": "dbt", "path": "macros/utils/array_concat.sql", "original_file_path": "macros/utils/array_concat.sql", "unique_id": "macro.dbt.default__array_concat", "macro_sql": "{% macro default__array_concat(array_1, array_2) -%}\n    array_cat({{ array_1 }}, {{ array_2 }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1481242, "supported_languages": null}, "macro.dbt.test_unique": {"name": "test_unique", "resource_type": "macro", "package_name": "dbt", "path": "tests/generic/builtin.sql", "original_file_path": "tests/generic/builtin.sql", "unique_id": "macro.dbt.test_unique", "macro_sql": "{% test unique(model, column_name) %}\n    {% set macro = adapter.dispatch('test_unique', 'dbt') %}\n    {{ macro(model, column_name) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt.default__test_unique"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.148702, "supported_languages": null}, "macro.dbt.test_not_null": {"name": "test_not_null", "resource_type": "macro", "package_name": "dbt", "path": "tests/generic/builtin.sql", "original_file_path": "tests/generic/builtin.sql", "unique_id": "macro.dbt.test_not_null", "macro_sql": "{% test not_null(model, column_name) %}\n    {% set macro = adapter.dispatch('test_not_null', 'dbt') %}\n    {{ macro(model, column_name) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt.default__test_not_null"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1490366, "supported_languages": null}, "macro.dbt.test_accepted_values": {"name": "test_accepted_values", "resource_type": "macro", "package_name": "dbt", "path": "tests/generic/builtin.sql", "original_file_path": "tests/generic/builtin.sql", "unique_id": "macro.dbt.test_accepted_values", "macro_sql": "{% test accepted_values(model, column_name, values, quote=True) %}\n    {% set macro = adapter.dispatch('test_accepted_values', 'dbt') %}\n    {{ macro(model, column_name, values, quote) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt.default__test_accepted_values"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1494396, "supported_languages": null}, "macro.dbt.test_relationships": {"name": "test_relationships", "resource_type": "macro", "package_name": "dbt", "path": "tests/generic/builtin.sql", "original_file_path": "tests/generic/builtin.sql", "unique_id": "macro.dbt.test_relationships", "macro_sql": "{% test relationships(model, column_name, to, field) %}\n    {% set macro = adapter.dispatch('test_relationships', 'dbt') %}\n    {{ macro(model, column_name, to, field) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt.default__test_relationships"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1498172, "supported_languages": null}, "macro.dbt_utils.array_construct": {"name": "array_construct", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_construct.sql", "original_file_path": "macros/cross_db_utils/array_construct.sql", "unique_id": "macro.dbt_utils.array_construct", "macro_sql": "{% macro array_construct(inputs = [], data_type = api.Column.translate_type('integer')) -%}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('array_construct', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('array_construct', 'dbt_utils')(inputs, data_type)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.default__array_construct"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.150516, "supported_languages": null}, "macro.dbt_utils.default__array_construct": {"name": "default__array_construct", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_construct.sql", "original_file_path": "macros/cross_db_utils/array_construct.sql", "unique_id": "macro.dbt_utils.default__array_construct", "macro_sql": "{% macro default__array_construct(inputs, data_type) -%}\n    {% if inputs|length > 0 %}\n    array[ {{ inputs|join(' , ') }} ]\n    {% else %}\n    array[]::{{data_type}}[]\n    {% endif %}\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1508298, "supported_languages": null}, "macro.dbt_utils.snowflake__array_construct": {"name": "snowflake__array_construct", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_construct.sql", "original_file_path": "macros/cross_db_utils/array_construct.sql", "unique_id": "macro.dbt_utils.snowflake__array_construct", "macro_sql": "{% macro snowflake__array_construct(inputs, data_type) -%}\n    array_construct( {{ inputs|join(' , ') }} )\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1510172, "supported_languages": null}, "macro.dbt_utils.redshift__array_construct": {"name": "redshift__array_construct", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_construct.sql", "original_file_path": "macros/cross_db_utils/array_construct.sql", "unique_id": "macro.dbt_utils.redshift__array_construct", "macro_sql": "{% macro redshift__array_construct(inputs, data_type) -%}\n    array( {{ inputs|join(' , ') }} )\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1511962, "supported_languages": null}, "macro.dbt_utils.bigquery__array_construct": {"name": "bigquery__array_construct", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_construct.sql", "original_file_path": "macros/cross_db_utils/array_construct.sql", "unique_id": "macro.dbt_utils.bigquery__array_construct", "macro_sql": "{% macro bigquery__array_construct(inputs, data_type) -%}\n    [ {{ inputs|join(' , ') }} ]\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1513746, "supported_languages": null}, "macro.dbt_utils.array_append": {"name": "array_append", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_append.sql", "original_file_path": "macros/cross_db_utils/array_append.sql", "unique_id": "macro.dbt_utils.array_append", "macro_sql": "{% macro array_append(array, new_element) -%}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('array_append', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('array_append', 'dbt_utils')(array, new_element)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.default__array_append"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1519232, "supported_languages": null}, "macro.dbt_utils.default__array_append": {"name": "default__array_append", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_append.sql", "original_file_path": "macros/cross_db_utils/array_append.sql", "unique_id": "macro.dbt_utils.default__array_append", "macro_sql": "{% macro default__array_append(array, new_element) -%}\n    array_append({{ array }}, {{ new_element }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1521032, "supported_languages": null}, "macro.dbt_utils.bigquery__array_append": {"name": "bigquery__array_append", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_append.sql", "original_file_path": "macros/cross_db_utils/array_append.sql", "unique_id": "macro.dbt_utils.bigquery__array_append", "macro_sql": "{% macro bigquery__array_append(array, new_element) -%}\n    {{ dbt_utils.array_concat(array, dbt_utils.array_construct([new_element])) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.array_concat", "macro.dbt_utils.array_construct"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.152341, "supported_languages": null}, "macro.dbt_utils.redshift__array_append": {"name": "redshift__array_append", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_append.sql", "original_file_path": "macros/cross_db_utils/array_append.sql", "unique_id": "macro.dbt_utils.redshift__array_append", "macro_sql": "{% macro redshift__array_append(array, new_element) -%}\n    {{ dbt_utils.array_concat(array, dbt_utils.array_construct([new_element])) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.array_concat", "macro.dbt_utils.array_construct"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.152648, "supported_languages": null}, "macro.dbt_utils.current_timestamp": {"name": "current_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.current_timestamp", "macro_sql": "{% macro current_timestamp() -%}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('current_timestamp', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('current_timestamp', 'dbt_utils')()) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.default__current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.153277, "supported_languages": null}, "macro.dbt_utils.default__current_timestamp": {"name": "default__current_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.default__current_timestamp", "macro_sql": "{% macro default__current_timestamp() %}\n    current_timestamp::{{ type_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1534169, "supported_languages": null}, "macro.dbt_utils.redshift__current_timestamp": {"name": "redshift__current_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.redshift__current_timestamp", "macro_sql": "{% macro redshift__current_timestamp() %}\n    getdate()\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1535323, "supported_languages": null}, "macro.dbt_utils.bigquery__current_timestamp": {"name": "bigquery__current_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.bigquery__current_timestamp", "macro_sql": "{% macro bigquery__current_timestamp() %}\n    current_timestamp\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1536322, "supported_languages": null}, "macro.dbt_utils.current_timestamp_in_utc": {"name": "current_timestamp_in_utc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.current_timestamp_in_utc", "macro_sql": "{% macro current_timestamp_in_utc() -%}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('current_timestamp_in_utc', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('current_timestamp_in_utc', 'dbt_utils')()) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.postgres__current_timestamp_in_utc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1539571, "supported_languages": null}, "macro.dbt_utils.default__current_timestamp_in_utc": {"name": "default__current_timestamp_in_utc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.default__current_timestamp_in_utc", "macro_sql": "{% macro default__current_timestamp_in_utc() %}\n    {{ dbt_utils.current_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1541073, "supported_languages": null}, "macro.dbt_utils.snowflake__current_timestamp_in_utc": {"name": "snowflake__current_timestamp_in_utc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.snowflake__current_timestamp_in_utc", "macro_sql": "{% macro snowflake__current_timestamp_in_utc() %}\n    convert_timezone('UTC', {{ dbt_utils.current_timestamp() }})::{{ type_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.current_timestamp", "macro.dbt_utils.type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1542912, "supported_languages": null}, "macro.dbt_utils.postgres__current_timestamp_in_utc": {"name": "postgres__current_timestamp_in_utc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.postgres__current_timestamp_in_utc", "macro_sql": "{% macro postgres__current_timestamp_in_utc() %}\n    (current_timestamp at time zone 'utc')::{{ type_timestamp() }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1544297, "supported_languages": null}, "macro.dbt_utils.redshift__current_timestamp_in_utc": {"name": "redshift__current_timestamp_in_utc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/current_timestamp.sql", "original_file_path": "macros/cross_db_utils/current_timestamp.sql", "unique_id": "macro.dbt_utils.redshift__current_timestamp_in_utc", "macro_sql": "{% macro redshift__current_timestamp_in_utc() %}\n    {{ return(dbt_utils.default__current_timestamp_in_utc()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__current_timestamp_in_utc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.154595, "supported_languages": null}, "macro.dbt_utils.cast_array_to_string": {"name": "cast_array_to_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/cast_array_to_string.sql", "original_file_path": "macros/cross_db_utils/cast_array_to_string.sql", "unique_id": "macro.dbt_utils.cast_array_to_string", "macro_sql": "{% macro cast_array_to_string(array) %}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('cast_array_to_string', model.package_name, model.name) %}\n  {{ adapter.dispatch('cast_array_to_string', 'dbt_utils') (array) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.postgres__cast_array_to_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.155177, "supported_languages": null}, "macro.dbt_utils.default__cast_array_to_string": {"name": "default__cast_array_to_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/cast_array_to_string.sql", "original_file_path": "macros/cross_db_utils/cast_array_to_string.sql", "unique_id": "macro.dbt_utils.default__cast_array_to_string", "macro_sql": "{% macro default__cast_array_to_string(array) %}\n    cast({{ array }} as {{ type_string() }})\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1553502, "supported_languages": null}, "macro.dbt_utils.postgres__cast_array_to_string": {"name": "postgres__cast_array_to_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/cast_array_to_string.sql", "original_file_path": "macros/cross_db_utils/cast_array_to_string.sql", "unique_id": "macro.dbt_utils.postgres__cast_array_to_string", "macro_sql": "{% macro postgres__cast_array_to_string(array) %}\n    {%- set array_as_string -%}cast({{ array }} as {{ type_string() }}){%- endset -%}\n    {{ replace(replace(array_as_string,\"'}'\",\"']'\"),\"'{'\",\"'['\") }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_string", "macro.dbt_utils.replace"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.155776, "supported_languages": null}, "macro.dbt_utils.redshift__cast_array_to_string": {"name": "redshift__cast_array_to_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/cast_array_to_string.sql", "original_file_path": "macros/cross_db_utils/cast_array_to_string.sql", "unique_id": "macro.dbt_utils.redshift__cast_array_to_string", "macro_sql": "{% macro redshift__cast_array_to_string(array) %}\n    cast({{ array }} as {{ type_string() }})\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1560016, "supported_languages": null}, "macro.dbt_utils.bigquery__cast_array_to_string": {"name": "bigquery__cast_array_to_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/cast_array_to_string.sql", "original_file_path": "macros/cross_db_utils/cast_array_to_string.sql", "unique_id": "macro.dbt_utils.bigquery__cast_array_to_string", "macro_sql": "{% macro bigquery__cast_array_to_string(array) %}\n    '['||(select string_agg(cast(element as string), ',') from unnest({{ array }}) element)||']'\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.156184, "supported_languages": null}, "macro.dbt_utils.array_concat": {"name": "array_concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_concat.sql", "original_file_path": "macros/cross_db_utils/array_concat.sql", "unique_id": "macro.dbt_utils.array_concat", "macro_sql": "{% macro array_concat(array_1, array_2) -%}\n  {% do dbt_utils.xdb_deprecation_warning_without_replacement('array_concat', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('array_concat', 'dbt_utils')(array_1, array_2)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro.dbt_utils.default__array_concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1568792, "supported_languages": null}, "macro.dbt_utils.default__array_concat": {"name": "default__array_concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_concat.sql", "original_file_path": "macros/cross_db_utils/array_concat.sql", "unique_id": "macro.dbt_utils.default__array_concat", "macro_sql": "{% macro default__array_concat(array_1, array_2) -%}\n    array_cat({{ array_1 }}, {{ array_2 }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1571028, "supported_languages": null}, "macro.dbt_utils.bigquery__array_concat": {"name": "bigquery__array_concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_concat.sql", "original_file_path": "macros/cross_db_utils/array_concat.sql", "unique_id": "macro.dbt_utils.bigquery__array_concat", "macro_sql": "{% macro bigquery__array_concat(array_1, array_2) -%}\n    array_concat({{ array_1 }}, {{ array_2 }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1573207, "supported_languages": null}, "macro.dbt_utils.redshift__array_concat": {"name": "redshift__array_concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/array_concat.sql", "original_file_path": "macros/cross_db_utils/array_concat.sql", "unique_id": "macro.dbt_utils.redshift__array_concat", "macro_sql": "{% macro redshift__array_concat(array_1, array_2) -%}\n    array_concat({{ array_1 }}, {{ array_2 }})\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1575265, "supported_languages": null}, "macro.dbt_utils.cast_bool_to_text": {"name": "cast_bool_to_text", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/cast_bool_to_text.sql", "original_file_path": "macros/cross_db_utils/deprecated/cast_bool_to_text.sql", "unique_id": "macro.dbt_utils.cast_bool_to_text", "macro_sql": "{% macro cast_bool_to_text(field) %}\n  {{ adapter.dispatch('cast_bool_to_text', 'dbt_utils') (field) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__cast_bool_to_text"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.157847, "supported_languages": null}, "macro.dbt_utils.default__cast_bool_to_text": {"name": "default__cast_bool_to_text", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/cast_bool_to_text.sql", "original_file_path": "macros/cross_db_utils/deprecated/cast_bool_to_text.sql", "unique_id": "macro.dbt_utils.default__cast_bool_to_text", "macro_sql": "{% macro default__cast_bool_to_text(field) %}\n  {% do dbt_utils.xdb_deprecation_warning('cast_bool_to_text', model.package_name, model.name) %}\n  {{ adapter.dispatch('cast_bool_to_text', 'dbt') (field) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.cast_bool_to_text", "macro.dbt.default__cast_bool_to_text"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1582518, "supported_languages": null}, "macro.dbt_utils.length": {"name": "length", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/length.sql", "original_file_path": "macros/cross_db_utils/deprecated/length.sql", "unique_id": "macro.dbt_utils.length", "macro_sql": "{% macro length(expression) -%}\n    {{ return(adapter.dispatch('length', 'dbt_utils') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__length"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1585927, "supported_languages": null}, "macro.dbt_utils.default__length": {"name": "default__length", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/length.sql", "original_file_path": "macros/cross_db_utils/deprecated/length.sql", "unique_id": "macro.dbt_utils.default__length", "macro_sql": "{% macro default__length(expression) -%}\n    {% do dbt_utils.xdb_deprecation_warning('length', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('length', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.length", "macro.dbt.default__length"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1589398, "supported_languages": null}, "macro.dbt_utils.string_literal": {"name": "string_literal", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/literal.sql", "original_file_path": "macros/cross_db_utils/deprecated/literal.sql", "unique_id": "macro.dbt_utils.string_literal", "macro_sql": "{%- macro string_literal(value) -%}\n  {{ return(adapter.dispatch('string_literal', 'dbt_utils') (value)) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__string_literal"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.159278, "supported_languages": null}, "macro.dbt_utils.default__string_literal": {"name": "default__string_literal", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/literal.sql", "original_file_path": "macros/cross_db_utils/deprecated/literal.sql", "unique_id": "macro.dbt_utils.default__string_literal", "macro_sql": "{%- macro default__string_literal(value) -%}\n  {% do dbt_utils.xdb_deprecation_warning('string_literal', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('string_literal', 'dbt') (value)) }}\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.string_literal", "macro.dbt.default__string_literal"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1596878, "supported_languages": null}, "macro.dbt_utils.escape_single_quotes": {"name": "escape_single_quotes", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/escape_single_quotes.sql", "original_file_path": "macros/cross_db_utils/deprecated/escape_single_quotes.sql", "unique_id": "macro.dbt_utils.escape_single_quotes", "macro_sql": "{% macro escape_single_quotes(expression) %}\n      {{ return(adapter.dispatch('escape_single_quotes', 'dbt_utils') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__escape_single_quotes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.160134, "supported_languages": null}, "macro.dbt_utils.default__escape_single_quotes": {"name": "default__escape_single_quotes", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/escape_single_quotes.sql", "original_file_path": "macros/cross_db_utils/deprecated/escape_single_quotes.sql", "unique_id": "macro.dbt_utils.default__escape_single_quotes", "macro_sql": "{% macro default__escape_single_quotes(expression) %}\n      {% do dbt_utils.xdb_deprecation_warning('escape_single_quotes', model.package_name, model.name) %}\n      {{ return(adapter.dispatch('escape_single_quotes', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.escape_single_quotes", "macro.dbt.default__escape_single_quotes"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1605923, "supported_languages": null}, "macro.dbt_utils.split_part": {"name": "split_part", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/split_part.sql", "original_file_path": "macros/cross_db_utils/deprecated/split_part.sql", "unique_id": "macro.dbt_utils.split_part", "macro_sql": "{% macro split_part(string_text, delimiter_text, part_number) %}\n  {{ return(adapter.dispatch('split_part', 'dbt_utils') (string_text, delimiter_text, part_number)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__split_part"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1611006, "supported_languages": null}, "macro.dbt_utils.default__split_part": {"name": "default__split_part", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/split_part.sql", "original_file_path": "macros/cross_db_utils/deprecated/split_part.sql", "unique_id": "macro.dbt_utils.default__split_part", "macro_sql": "{% macro default__split_part(string_text, delimiter_text, part_number) %}\n  {% do dbt_utils.xdb_deprecation_warning('split_part', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('split_part', 'dbt') (string_text, delimiter_text, part_number)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.split_part", "macro.dbt_postgres.postgres__split_part"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1615918, "supported_languages": null}, "macro.dbt_utils.right": {"name": "right", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/right.sql", "original_file_path": "macros/cross_db_utils/deprecated/right.sql", "unique_id": "macro.dbt_utils.right", "macro_sql": "{% macro right(string_text, length_expression) -%}\n    {{ return(adapter.dispatch('right', 'dbt_utils') (string_text, length_expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__right"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1619627, "supported_languages": null}, "macro.dbt_utils.default__right": {"name": "default__right", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/right.sql", "original_file_path": "macros/cross_db_utils/deprecated/right.sql", "unique_id": "macro.dbt_utils.default__right", "macro_sql": "{% macro default__right(string_text, length_expression) -%}\n    {% do dbt_utils.xdb_deprecation_warning('right', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('right', 'dbt') (string_text, length_expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.right", "macro.dbt.default__right"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1623297, "supported_languages": null}, "macro.dbt_utils.any_value": {"name": "any_value", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/any_value.sql", "original_file_path": "macros/cross_db_utils/deprecated/any_value.sql", "unique_id": "macro.dbt_utils.any_value", "macro_sql": "{% macro any_value(expression) -%}\n    {{ return(adapter.dispatch('any_value', 'dbt_utils') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__any_value"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1626601, "supported_languages": null}, "macro.dbt_utils.default__any_value": {"name": "default__any_value", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/any_value.sql", "original_file_path": "macros/cross_db_utils/deprecated/any_value.sql", "unique_id": "macro.dbt_utils.default__any_value", "macro_sql": "{% macro default__any_value(expression) -%}\n    {% do dbt_utils.xdb_deprecation_warning('any_value', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('any_value', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.any_value", "macro.dbt_postgres.postgres__any_value"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.163005, "supported_languages": null}, "macro.dbt_utils.concat": {"name": "concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/concat.sql", "original_file_path": "macros/cross_db_utils/deprecated/concat.sql", "unique_id": "macro.dbt_utils.concat", "macro_sql": "{% macro concat(fields) -%}\n  {{ return(adapter.dispatch('concat', 'dbt_utils')(fields)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1633449, "supported_languages": null}, "macro.dbt_utils.default__concat": {"name": "default__concat", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/concat.sql", "original_file_path": "macros/cross_db_utils/deprecated/concat.sql", "unique_id": "macro.dbt_utils.default__concat", "macro_sql": "{% macro default__concat(fields) -%}\n  {% do dbt_utils.xdb_deprecation_warning('concat', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('concat', 'dbt')(fields)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.concat", "macro.dbt.default__concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1637566, "supported_languages": null}, "macro.dbt_utils.type_string": {"name": "type_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_string", "macro_sql": "\n\n{%- macro type_string() -%}\n    {{ return(adapter.dispatch('type_string', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1647246, "supported_languages": null}, "macro.dbt_utils.default__type_string": {"name": "default__type_string", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_string", "macro_sql": "{% macro default__type_string() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_string', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_string', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_string", "macro.dbt.default__type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1651607, "supported_languages": null}, "macro.dbt_utils.type_timestamp": {"name": "type_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_timestamp", "macro_sql": "\n\n{%- macro type_timestamp() -%}\n    {{ return(adapter.dispatch('type_timestamp', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.165435, "supported_languages": null}, "macro.dbt_utils.default__type_timestamp": {"name": "default__type_timestamp", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_timestamp", "macro_sql": "{% macro default__type_timestamp() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_timestamp', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_timestamp', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_timestamp", "macro.dbt.default__type_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1658454, "supported_languages": null}, "macro.dbt_utils.type_float": {"name": "type_float", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_float", "macro_sql": "\n\n{%- macro type_float() -%}\n    {{ return(adapter.dispatch('type_float', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_float"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.166057, "supported_languages": null}, "macro.dbt_utils.default__type_float": {"name": "default__type_float", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_float", "macro_sql": "{% macro default__type_float() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_float', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_float', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_float", "macro.dbt.default__type_float"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.16639, "supported_languages": null}, "macro.dbt_utils.type_numeric": {"name": "type_numeric", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_numeric", "macro_sql": "\n\n{%- macro type_numeric() -%}\n    {{ return(adapter.dispatch('type_numeric', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_numeric"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1665967, "supported_languages": null}, "macro.dbt_utils.default__type_numeric": {"name": "default__type_numeric", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_numeric", "macro_sql": "{% macro default__type_numeric() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_numeric', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_numeric', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_numeric", "macro.dbt.default__type_numeric"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.166923, "supported_languages": null}, "macro.dbt_utils.type_bigint": {"name": "type_bigint", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_bigint", "macro_sql": "\n\n{%- macro type_bigint() -%}\n    {{ return(adapter.dispatch('type_bigint', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_bigint"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1671312, "supported_languages": null}, "macro.dbt_utils.default__type_bigint": {"name": "default__type_bigint", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_bigint", "macro_sql": "{% macro default__type_bigint() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_bigint', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_bigint', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_bigint", "macro.dbt.default__type_bigint"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1674612, "supported_languages": null}, "macro.dbt_utils.type_int": {"name": "type_int", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.type_int", "macro_sql": "\n\n{%- macro type_int() -%}\n    {{ return(adapter.dispatch('type_int', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.default__type_int"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1677208, "supported_languages": null}, "macro.dbt_utils.default__type_int": {"name": "default__type_int", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datatypes.sql", "original_file_path": "macros/cross_db_utils/deprecated/datatypes.sql", "unique_id": "macro.dbt_utils.default__type_int", "macro_sql": "{% macro default__type_int() %}\n    {% do dbt_utils.xdb_deprecation_warning('type_int', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('type_int', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.type_int", "macro.dbt.default__type_int"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1681514, "supported_languages": null}, "macro.dbt_utils.datediff": {"name": "datediff", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datediff.sql", "original_file_path": "macros/cross_db_utils/deprecated/datediff.sql", "unique_id": "macro.dbt_utils.datediff", "macro_sql": "{% macro datediff(first_date, second_date, datepart) %}\n  {{ return(adapter.dispatch('datediff', 'dbt_utils')(first_date, second_date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1686702, "supported_languages": null}, "macro.dbt_utils.default__datediff": {"name": "default__datediff", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/datediff.sql", "original_file_path": "macros/cross_db_utils/deprecated/datediff.sql", "unique_id": "macro.dbt_utils.default__datediff", "macro_sql": "{% macro default__datediff(first_date, second_date, datepart) %}\n  {% do dbt_utils.xdb_deprecation_warning('datediff', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('datediff', 'dbt')(first_date, second_date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.datediff", "macro.dbt_postgres.postgres__datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1691978, "supported_languages": null}, "macro.dbt_utils.safe_cast": {"name": "safe_cast", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/safe_cast.sql", "original_file_path": "macros/cross_db_utils/deprecated/safe_cast.sql", "unique_id": "macro.dbt_utils.safe_cast", "macro_sql": "{% macro safe_cast(field, type) %}\n  {{ return(adapter.dispatch('safe_cast', 'dbt_utils') (field, type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__safe_cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.169643, "supported_languages": null}, "macro.dbt_utils.default__safe_cast": {"name": "default__safe_cast", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/safe_cast.sql", "original_file_path": "macros/cross_db_utils/deprecated/safe_cast.sql", "unique_id": "macro.dbt_utils.default__safe_cast", "macro_sql": "{% macro default__safe_cast(field, type) %}\n  {% do dbt_utils.xdb_deprecation_warning('safe_cast', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('safe_cast', 'dbt') (field, type)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.safe_cast", "macro.dbt.default__safe_cast"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1700284, "supported_languages": null}, "macro.dbt_utils.identifier": {"name": "identifier", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/identifier.sql", "original_file_path": "macros/cross_db_utils/deprecated/identifier.sql", "unique_id": "macro.dbt_utils.identifier", "macro_sql": "{% macro identifier(value) %}\t\n  {%- set error_message = '\n    Warning: the `identifier` macro is no longer supported and will be deprecated in a future release of dbt-utils. \\\n    Use `adapter.quote` instead. The {}.{} model triggered this warning. \\\n    '.format(model.package_name, model.name) -%}\n  {%- do exceptions.warn(error_message) -%}\n  {{ return(adapter.dispatch('identifier', 'dbt_utils') (value)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__identifier"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1705818, "supported_languages": null}, "macro.dbt_utils.default__identifier": {"name": "default__identifier", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/identifier.sql", "original_file_path": "macros/cross_db_utils/deprecated/identifier.sql", "unique_id": "macro.dbt_utils.default__identifier", "macro_sql": "{% macro default__identifier(value) -%}\t\n    \"{{ value }}\"\t\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1707225, "supported_languages": null}, "macro.dbt_utils.bigquery__identifier": {"name": "bigquery__identifier", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/identifier.sql", "original_file_path": "macros/cross_db_utils/deprecated/identifier.sql", "unique_id": "macro.dbt_utils.bigquery__identifier", "macro_sql": "{% macro bigquery__identifier(value) -%}\t\n    `{{ value }}`\t\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1708562, "supported_languages": null}, "macro.dbt_utils.bool_or": {"name": "bool_or", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/bool_or.sql", "original_file_path": "macros/cross_db_utils/deprecated/bool_or.sql", "unique_id": "macro.dbt_utils.bool_or", "macro_sql": "{% macro bool_or(expression) -%}\n    {{ return(adapter.dispatch('bool_or', 'dbt_utils') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__bool_or"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1711934, "supported_languages": null}, "macro.dbt_utils.default__bool_or": {"name": "default__bool_or", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/bool_or.sql", "original_file_path": "macros/cross_db_utils/deprecated/bool_or.sql", "unique_id": "macro.dbt_utils.default__bool_or", "macro_sql": "{% macro default__bool_or(expression) -%}\n    {% do dbt_utils.xdb_deprecation_warning('bool_or', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('bool_or', 'dbt') (expression)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.bool_or", "macro.dbt.default__bool_or"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1715612, "supported_languages": null}, "macro.dbt_utils.dateadd": {"name": "dateadd", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/dateadd.sql", "original_file_path": "macros/cross_db_utils/deprecated/dateadd.sql", "unique_id": "macro.dbt_utils.dateadd", "macro_sql": "{% macro dateadd(datepart, interval, from_date_or_timestamp) %}\n  {{ return(adapter.dispatch('dateadd', 'dbt_utils')(datepart, interval, from_date_or_timestamp)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1720753, "supported_languages": null}, "macro.dbt_utils.default__dateadd": {"name": "default__dateadd", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/dateadd.sql", "original_file_path": "macros/cross_db_utils/deprecated/dateadd.sql", "unique_id": "macro.dbt_utils.default__dateadd", "macro_sql": "{% macro default__dateadd(datepart, interval, from_date_or_timestamp) %}\n  {% do dbt_utils.xdb_deprecation_warning('dateadd', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('dateadd', 'dbt')(datepart, interval, from_date_or_timestamp)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.dateadd", "macro.dbt_postgres.postgres__dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1727152, "supported_languages": null}, "macro.dbt_utils.listagg": {"name": "listagg", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/listagg.sql", "original_file_path": "macros/cross_db_utils/deprecated/listagg.sql", "unique_id": "macro.dbt_utils.listagg", "macro_sql": "{% macro listagg(measure, delimiter_text=\"','\", order_by_clause=none, limit_num=none) -%}\n    {{ return(adapter.dispatch('listagg', 'dbt_utils') (measure, delimiter_text, order_by_clause, limit_num)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__listagg"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1733341, "supported_languages": null}, "macro.dbt_utils.default__listagg": {"name": "default__listagg", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/listagg.sql", "original_file_path": "macros/cross_db_utils/deprecated/listagg.sql", "unique_id": "macro.dbt_utils.default__listagg", "macro_sql": "{% macro default__listagg(measure, delimiter_text=\"','\", order_by_clause=none, limit_num=none) -%}\n    {% do dbt_utils.xdb_deprecation_warning('listagg', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('listagg', 'dbt') (measure, delimiter_text, order_by_clause, limit_num)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.listagg", "macro.dbt_postgres.postgres__listagg"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1738338, "supported_languages": null}, "macro.dbt_utils.replace": {"name": "replace", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/replace.sql", "original_file_path": "macros/cross_db_utils/deprecated/replace.sql", "unique_id": "macro.dbt_utils.replace", "macro_sql": "{% macro replace(field, old_chars, new_chars) -%}\n    {{ return(adapter.dispatch('replace', 'dbt_utils') (field, old_chars, new_chars)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__replace"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1742332, "supported_languages": null}, "macro.dbt_utils.default__replace": {"name": "default__replace", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/replace.sql", "original_file_path": "macros/cross_db_utils/deprecated/replace.sql", "unique_id": "macro.dbt_utils.default__replace", "macro_sql": "{% macro default__replace(field, old_chars, new_chars) -%}\n  {% do dbt_utils.xdb_deprecation_warning('replace', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('replace', 'dbt') (field, old_chars, new_chars)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.replace", "macro.dbt.default__replace"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.174634, "supported_languages": null}, "macro.dbt_utils.except": {"name": "except", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/except.sql", "original_file_path": "macros/cross_db_utils/deprecated/except.sql", "unique_id": "macro.dbt_utils.except", "macro_sql": "{% macro except() %}\n  {{ return(adapter.dispatch('except', 'dbt_utils')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__except"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1749475, "supported_languages": null}, "macro.dbt_utils.default__except": {"name": "default__except", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/except.sql", "original_file_path": "macros/cross_db_utils/deprecated/except.sql", "unique_id": "macro.dbt_utils.default__except", "macro_sql": "{% macro default__except() %}\n  {% do dbt_utils.xdb_deprecation_warning('except', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('except', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.except", "macro.dbt.default__except"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.175286, "supported_languages": null}, "macro.dbt_utils.hash": {"name": "hash", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/hash.sql", "original_file_path": "macros/cross_db_utils/deprecated/hash.sql", "unique_id": "macro.dbt_utils.hash", "macro_sql": "{% macro hash(field) -%}\n  {{ return(adapter.dispatch('hash', 'dbt_utils') (field)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__hash"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1756587, "supported_languages": null}, "macro.dbt_utils.default__hash": {"name": "default__hash", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/hash.sql", "original_file_path": "macros/cross_db_utils/deprecated/hash.sql", "unique_id": "macro.dbt_utils.default__hash", "macro_sql": "{% macro default__hash(field) -%}\n  {% do dbt_utils.xdb_deprecation_warning('hash', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('hash', 'dbt') (field)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.hash", "macro.dbt.default__hash"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1761029, "supported_languages": null}, "macro.dbt_utils.last_day": {"name": "last_day", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/last_day.sql", "original_file_path": "macros/cross_db_utils/deprecated/last_day.sql", "unique_id": "macro.dbt_utils.last_day", "macro_sql": "{% macro last_day(date, datepart) %}\n  {{ return(adapter.dispatch('last_day', 'dbt_utils') (date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__last_day"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.176575, "supported_languages": null}, "macro.dbt_utils.default__last_day": {"name": "default__last_day", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/last_day.sql", "original_file_path": "macros/cross_db_utils/deprecated/last_day.sql", "unique_id": "macro.dbt_utils.default__last_day", "macro_sql": "{% macro default__last_day(date, datepart) %}\n  {% do dbt_utils.xdb_deprecation_warning('last_day', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('last_day', 'dbt') (date, datepart)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.last_day", "macro.dbt_postgres.postgres__last_day"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1770663, "supported_languages": null}, "macro.dbt_utils.date_trunc": {"name": "date_trunc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/date_trunc.sql", "original_file_path": "macros/cross_db_utils/deprecated/date_trunc.sql", "unique_id": "macro.dbt_utils.date_trunc", "macro_sql": "{% macro date_trunc(datepart, date) -%}\n  {{ return(adapter.dispatch('date_trunc', 'dbt_utils') (datepart, date)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__date_trunc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1775177, "supported_languages": null}, "macro.dbt_utils.default__date_trunc": {"name": "default__date_trunc", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/date_trunc.sql", "original_file_path": "macros/cross_db_utils/deprecated/date_trunc.sql", "unique_id": "macro.dbt_utils.default__date_trunc", "macro_sql": "{% macro default__date_trunc(datepart, date) -%}\n  {% do dbt_utils.xdb_deprecation_warning('date_trunc', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('date_trunc', 'dbt') (datepart, date)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.date_trunc", "macro.dbt.default__date_trunc"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1778936, "supported_languages": null}, "macro.dbt_utils.intersect": {"name": "intersect", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/intersect.sql", "original_file_path": "macros/cross_db_utils/deprecated/intersect.sql", "unique_id": "macro.dbt_utils.intersect", "macro_sql": "{% macro intersect() %}\n  {{ return(adapter.dispatch('intersect', 'dbt_utils')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__intersect"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1782067, "supported_languages": null}, "macro.dbt_utils.default__intersect": {"name": "default__intersect", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/intersect.sql", "original_file_path": "macros/cross_db_utils/deprecated/intersect.sql", "unique_id": "macro.dbt_utils.default__intersect", "macro_sql": "{% macro default__intersect() %}\n  {% do dbt_utils.xdb_deprecation_warning('intersect', model.package_name, model.name) %}\n  {{ return(adapter.dispatch('intersect', 'dbt')()) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.intersect", "macro.dbt.default__intersect"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1785321, "supported_languages": null}, "macro.dbt_utils.xdb_deprecation_warning": {"name": "xdb_deprecation_warning", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/xdb_deprecation_warning.sql", "original_file_path": "macros/cross_db_utils/deprecated/xdb_deprecation_warning.sql", "unique_id": "macro.dbt_utils.xdb_deprecation_warning", "macro_sql": "{% macro xdb_deprecation_warning(macro, package, model) %}\n    {%- set error_message = \"Warning: the `\" ~ macro ~\"` macro is now provided in dbt Core. It is no longer available in dbt_utils and backwards compatibility will be removed in a future version of the package. Use `\" ~ macro ~ \"` (no prefix) instead. The \" ~ package ~ \".\" ~ model ~ \" model triggered this warning.\" -%}\n    {%- do exceptions.warn(error_message) -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1790056, "supported_languages": null}, "macro.dbt_utils.xdb_deprecation_warning_without_replacement": {"name": "xdb_deprecation_warning_without_replacement", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/xdb_deprecation_warning.sql", "original_file_path": "macros/cross_db_utils/deprecated/xdb_deprecation_warning.sql", "unique_id": "macro.dbt_utils.xdb_deprecation_warning_without_replacement", "macro_sql": "{% macro xdb_deprecation_warning_without_replacement(macro, package, model) %}\n    {%- set error_message = \"Warning: the `\" ~ macro ~\"` macro is deprecated and will be removed in a future version of the package, once equivalent functionality is implemented in dbt Core. The \" ~ package ~ \".\" ~ model ~ \" model triggered this warning.\" -%}\n    {%- do exceptions.warn(error_message) -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1793194, "supported_languages": null}, "macro.dbt_utils.position": {"name": "position", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/position.sql", "original_file_path": "macros/cross_db_utils/deprecated/position.sql", "unique_id": "macro.dbt_utils.position", "macro_sql": "{% macro position(substring_text, string_text) -%}\n    {{ return(adapter.dispatch('position', 'dbt_utils') (substring_text, string_text)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__position"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1797435, "supported_languages": null}, "macro.dbt_utils.default__position": {"name": "default__position", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/cross_db_utils/deprecated/position.sql", "original_file_path": "macros/cross_db_utils/deprecated/position.sql", "unique_id": "macro.dbt_utils.default__position", "macro_sql": "{% macro default__position(substring_text, string_text) -%}\n    {% do dbt_utils.xdb_deprecation_warning('position', model.package_name, model.name) %}\n    {{ return(adapter.dispatch('position', 'dbt') (substring_text, string_text)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.xdb_deprecation_warning", "macro.dbt_utils.position", "macro.dbt.default__position"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1803296, "supported_languages": null}, "macro.dbt_utils.get_period_boundaries": {"name": "get_period_boundaries", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/materializations/insert_by_period_materialization.sql", "original_file_path": "macros/materializations/insert_by_period_materialization.sql", "unique_id": "macro.dbt_utils.get_period_boundaries", "macro_sql": "{% macro get_period_boundaries(target_schema, target_table, timestamp_field, start_date, stop_date, period) -%}\n    {{ return(adapter.dispatch('get_period_boundaries', 'dbt_utils')(target_schema, target_table, timestamp_field, start_date, stop_date, period)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_period_boundaries"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1823728, "supported_languages": null}, "macro.dbt_utils.default__get_period_boundaries": {"name": "default__get_period_boundaries", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/materializations/insert_by_period_materialization.sql", "original_file_path": "macros/materializations/insert_by_period_materialization.sql", "unique_id": "macro.dbt_utils.default__get_period_boundaries", "macro_sql": "{% macro default__get_period_boundaries(target_schema, target_table, timestamp_field, start_date, stop_date, period) -%}\n\n  {% call statement('period_boundaries', fetch_result=True) -%}\n    with data as (\n      select\n          coalesce(max(\"{{timestamp_field}}\"), '{{start_date}}')::timestamp as start_timestamp,\n          coalesce(\n            {{ dateadd('millisecond',\n                                -1,\n                                \"nullif('\" ~ stop_date ~ \"','')::timestamp\") }},\n            {{ dbt_utils.current_timestamp() }}\n          ) as stop_timestamp\n      from \"{{target_schema}}\".\"{{target_table}}\"\n    )\n\n    select\n      start_timestamp,\n      stop_timestamp,\n      {{ datediff('start_timestamp',\n                           'stop_timestamp',\n                           period) }}  + 1 as num_periods\n    from data\n  {%- endcall %}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt_utils.dateadd", "macro.dbt_utils.current_timestamp", "macro.dbt_utils.datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1830251, "supported_languages": null}, "macro.dbt_utils.get_period_sql": {"name": "get_period_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/materializations/insert_by_period_materialization.sql", "original_file_path": "macros/materializations/insert_by_period_materialization.sql", "unique_id": "macro.dbt_utils.get_period_sql", "macro_sql": "{% macro get_period_sql(target_cols_csv, sql, timestamp_field, period, start_timestamp, stop_timestamp, offset) -%}\n    {{ return(adapter.dispatch('get_period_sql', 'dbt_utils')(target_cols_csv, sql, timestamp_field, period, start_timestamp, stop_timestamp, offset)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_period_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.183425, "supported_languages": null}, "macro.dbt_utils.default__get_period_sql": {"name": "default__get_period_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/materializations/insert_by_period_materialization.sql", "original_file_path": "macros/materializations/insert_by_period_materialization.sql", "unique_id": "macro.dbt_utils.default__get_period_sql", "macro_sql": "{% macro default__get_period_sql(target_cols_csv, sql, timestamp_field, period, start_timestamp, stop_timestamp, offset) -%}\n\n  {%- set period_filter -%}\n    (\"{{timestamp_field}}\" >  '{{start_timestamp}}'::timestamp + interval '{{offset}} {{period}}' and\n     \"{{timestamp_field}}\" <= '{{start_timestamp}}'::timestamp + interval '{{offset}} {{period}}' + interval '1 {{period}}' and\n     \"{{timestamp_field}}\" <  '{{stop_timestamp}}'::timestamp)\n  {%- endset -%}\n\n  {%- set filtered_sql = sql | replace(\"__PERIOD_FILTER__\", period_filter) -%}\n\n  select\n    {{target_cols_csv}}\n  from (\n    {{filtered_sql}}\n  )\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1842585, "supported_languages": null}, "macro.dbt_utils.materialization_insert_by_period_default": {"name": "materialization_insert_by_period_default", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/materializations/insert_by_period_materialization.sql", "original_file_path": "macros/materializations/insert_by_period_materialization.sql", "unique_id": "macro.dbt_utils.materialization_insert_by_period_default", "macro_sql": "{% materialization insert_by_period, default -%}\n  {%- set timestamp_field = config.require('timestamp_field') -%}\n  {%- set start_date = config.require('start_date') -%}\n  {%- set stop_date = config.get('stop_date') or '' -%}\n  {%- set period = config.get('period') or 'week' -%}\n\n  {%- set deprecation_warning = \"Warning: the `insert_by_period` materialization will be removed from dbt_utils in version 1.0.0. Install from dbt-labs/dbt-labs-experimental-features instead (see https://github.com/dbt-labs/dbt-utils/discussions/487). The \" ~ package ~ \".\" ~ model ~ \" model triggered this warning.\" -%}\n  {%- do exceptions.warn(deprecation_warning) -%}\n\n  {%- if sql.find('__PERIOD_FILTER__') == -1 -%}\n    {%- set error_message -%}\n      Model '{{ model.unique_id }}' does not include the required string '__PERIOD_FILTER__' in its sql\n    {%- endset -%}\n    {{ exceptions.raise_compiler_error(error_message) }}\n  {%- endif -%}\n\n  {%- set identifier = model['name'] -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, type='table') -%}\n\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_not_as_table = (old_relation is not none and not old_relation.is_table) -%}\n\n  {%- set should_truncate = (non_destructive_mode and full_refresh_mode and exists_as_table) -%}\n  {%- set should_drop = (not should_truncate and (full_refresh_mode or exists_not_as_table)) -%}\n  {%- set force_create = (flags.FULL_REFRESH and not flags.NON_DESTRUCTIVE) -%}\n\n  -- setup\n  {% if old_relation is none -%}\n    -- noop\n  {%- elif should_truncate -%}\n    {{adapter.truncate_relation(old_relation)}}\n  {%- elif should_drop -%}\n    {{adapter.drop_relation(old_relation)}}\n    {%- set old_relation = none -%}\n  {%- endif %}\n\n  {{run_hooks(pre_hooks, inside_transaction=False)}}\n\n  -- `begin` happens here, so `commit` after it to finish the transaction\n  {{run_hooks(pre_hooks, inside_transaction=True)}}\n  {% call statement() -%}\n    begin; -- make extra sure we've closed out the transaction\n    commit;\n  {%- endcall %}\n\n  -- build model\n  {% if force_create or old_relation is none -%}\n    {# Create an empty target table -#}\n    {% call statement('main') -%}\n      {%- set empty_sql = sql | replace(\"__PERIOD_FILTER__\", 'false') -%}\n      {{create_table_as(False, target_relation, empty_sql)}}\n    {%- endcall %}\n  {%- endif %}\n\n  {% set _ = dbt_utils.get_period_boundaries(schema,\n                                              identifier,\n                                              timestamp_field,\n                                              start_date,\n                                              stop_date,\n                                              period) %}\n  {%- set start_timestamp = load_result('period_boundaries')['data'][0][0] | string -%}\n  {%- set stop_timestamp = load_result('period_boundaries')['data'][0][1] | string -%}\n  {%- set num_periods = load_result('period_boundaries')['data'][0][2] | int -%}\n\n  {% set target_columns = adapter.get_columns_in_relation(target_relation) %}\n  {%- set target_cols_csv = target_columns | map(attribute='quoted') | join(', ') -%}\n  {%- set loop_vars = {'sum_rows_inserted': 0} -%}\n\n  -- commit each period as a separate transaction\n  {% for i in range(num_periods) -%}\n    {%- set msg = \"Running for \" ~ period ~ \" \" ~ (i + 1) ~ \" of \" ~ (num_periods) -%}\n    {{ dbt_utils.log_info(msg) }}\n\n    {%- set tmp_identifier = model['name'] ~ '__dbt_incremental_period' ~ i ~ '_tmp' -%}\n    {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier,\n                                               schema=schema, type='table') -%}\n    {% call statement() -%}\n      {% set tmp_table_sql = dbt_utils.get_period_sql(target_cols_csv,\n                                                       sql,\n                                                       timestamp_field,\n                                                       period,\n                                                       start_timestamp,\n                                                       stop_timestamp,\n                                                       i) %}\n      {{dbt.create_table_as(True, tmp_relation, tmp_table_sql)}}\n    {%- endcall %}\n\n    {{adapter.expand_target_column_types(from_relation=tmp_relation,\n                                         to_relation=target_relation)}}\n    {%- set name = 'main-' ~ i -%}\n    {% call statement(name, fetch_result=True) -%}\n      insert into {{target_relation}} ({{target_cols_csv}})\n      (\n          select\n              {{target_cols_csv}}\n          from {{tmp_relation.include(schema=False)}}\n      );\n    {%- endcall %}\n    {% set result = load_result('main-' ~ i) %}\n    {% if 'response' in result.keys() %} {# added in v0.19.0 #}\n        {% set rows_inserted = result['response']['rows_affected'] %}\n    {% else %} {# older versions #}\n        {% set rows_inserted = result['status'].split(\" \")[2] | int %}\n    {% endif %}\n\n    {%- set sum_rows_inserted = loop_vars['sum_rows_inserted'] + rows_inserted -%}\n    {%- if loop_vars.update({'sum_rows_inserted': sum_rows_inserted}) %} {% endif -%}\n\n    {%- set msg = \"Ran for \" ~ period ~ \" \" ~ (i + 1) ~ \" of \" ~ (num_periods) ~ \"; \" ~ rows_inserted ~ \" records inserted\" -%}\n    {{ dbt_utils.log_info(msg) }}\n\n  {%- endfor %}\n\n  {% call statement() -%}\n    begin;\n  {%- endcall %}\n\n  {{run_hooks(post_hooks, inside_transaction=True)}}\n\n  {% call statement() -%}\n    commit;\n  {%- endcall %}\n\n  {{run_hooks(post_hooks, inside_transaction=False)}}\n\n  {%- set status_string = \"INSERT \" ~ loop_vars['sum_rows_inserted'] -%}\n\n  {% call noop_statement('main', status_string) -%}\n    -- no-op\n  {%- endcall %}\n\n  -- Return the relations created in this materialization\n  {{ return({'relations': [target_relation]}) }}\n\n{%- endmaterialization %}", "depends_on": {"macros": ["macro.dbt.run_hooks", "macro.dbt.statement", "macro.dbt.create_table_as", "macro.dbt_utils.get_period_boundaries", "macro.dbt_utils.log_info", "macro.dbt_utils.get_period_sql", "macro.dbt.noop_statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.191139, "supported_languages": ["sql"]}, "macro.dbt_utils.pretty_time": {"name": "pretty_time", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/pretty_time.sql", "original_file_path": "macros/jinja_helpers/pretty_time.sql", "unique_id": "macro.dbt_utils.pretty_time", "macro_sql": "{% macro pretty_time(format='%H:%M:%S') %}\n    {{ return(adapter.dispatch('pretty_time', 'dbt_utils')(format)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__pretty_time"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.191711, "supported_languages": null}, "macro.dbt_utils.default__pretty_time": {"name": "default__pretty_time", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/pretty_time.sql", "original_file_path": "macros/jinja_helpers/pretty_time.sql", "unique_id": "macro.dbt_utils.default__pretty_time", "macro_sql": "{% macro default__pretty_time(format='%H:%M:%S') %}\n    {{ return(modules.datetime.datetime.now().strftime(format)) }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1920428, "supported_languages": null}, "macro.dbt_utils._is_ephemeral": {"name": "_is_ephemeral", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/_is_ephemeral.sql", "original_file_path": "macros/jinja_helpers/_is_ephemeral.sql", "unique_id": "macro.dbt_utils._is_ephemeral", "macro_sql": "{% macro _is_ephemeral(obj, macro) %}\n    {%- if obj.is_cte -%}\n        {% set ephemeral_prefix = api.Relation.add_ephemeral_prefix('') %}\n        {% if obj.name.startswith(ephemeral_prefix) %}\n            {% set model_name = obj.name[(ephemeral_prefix|length):] %}\n        {% else %}\n            {% set model_name = obj.name %}\n        {%- endif -%}\n        {% set error_message %}\nThe `{{ macro }}` macro cannot be used with ephemeral models, as it relies on the information schema.\n\n`{{ model_name }}` is an ephemeral model. Consider making it a view or table instead.\n        {% endset %}\n        {%- do exceptions.raise_compiler_error(error_message) -%}\n    {%- endif -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1932113, "supported_languages": null}, "macro.dbt_utils.pretty_log_format": {"name": "pretty_log_format", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/pretty_log_format.sql", "original_file_path": "macros/jinja_helpers/pretty_log_format.sql", "unique_id": "macro.dbt_utils.pretty_log_format", "macro_sql": "{% macro pretty_log_format(message) %}\n    {{ return(adapter.dispatch('pretty_log_format', 'dbt_utils')(message)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__pretty_log_format"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.193597, "supported_languages": null}, "macro.dbt_utils.default__pretty_log_format": {"name": "default__pretty_log_format", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/pretty_log_format.sql", "original_file_path": "macros/jinja_helpers/pretty_log_format.sql", "unique_id": "macro.dbt_utils.default__pretty_log_format", "macro_sql": "{% macro default__pretty_log_format(message) %}\n    {{ return( dbt_utils.pretty_time() ~ ' + ' ~ message) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.pretty_time"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1938133, "supported_languages": null}, "macro.dbt_utils.log_info": {"name": "log_info", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/log_info.sql", "original_file_path": "macros/jinja_helpers/log_info.sql", "unique_id": "macro.dbt_utils.log_info", "macro_sql": "{% macro log_info(message) %}\n    {{ return(adapter.dispatch('log_info', 'dbt_utils')(message)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__log_info"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1941335, "supported_languages": null}, "macro.dbt_utils.default__log_info": {"name": "default__log_info", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/log_info.sql", "original_file_path": "macros/jinja_helpers/log_info.sql", "unique_id": "macro.dbt_utils.default__log_info", "macro_sql": "{% macro default__log_info(message) %}\n    {{ log(dbt_utils.pretty_log_format(message), info=True) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.pretty_log_format"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1943517, "supported_languages": null}, "macro.dbt_utils._is_relation": {"name": "_is_relation", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/_is_relation.sql", "original_file_path": "macros/jinja_helpers/_is_relation.sql", "unique_id": "macro.dbt_utils._is_relation", "macro_sql": "{% macro _is_relation(obj, macro) %}\n    {%- if not (obj is mapping and obj.get('metadata', {}).get('type', '').endswith('Relation')) -%}\n        {%- do exceptions.raise_compiler_error(\"Macro \" ~ macro ~ \" expected a Relation but received the value: \" ~ obj) -%}\n    {%- endif -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1949034, "supported_languages": null}, "macro.dbt_utils.slugify": {"name": "slugify", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/jinja_helpers/slugify.sql", "original_file_path": "macros/jinja_helpers/slugify.sql", "unique_id": "macro.dbt_utils.slugify", "macro_sql": "{% macro slugify(string) %}\n\n{#- Lower case the string -#}\n{% set string = string | lower %}\n{#- Replace spaces and dashes with underscores -#}\n{% set string = modules.re.sub('[ -]+', '_', string) %}\n{#- Only take letters, numbers, and underscores -#}\n{% set string = modules.re.sub('[^a-z0-9_]+', '', string) %}\n\n{{ return(string) }}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1954947, "supported_languages": null}, "macro.dbt_utils.get_url_parameter": {"name": "get_url_parameter", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_parameter.sql", "original_file_path": "macros/web/get_url_parameter.sql", "unique_id": "macro.dbt_utils.get_url_parameter", "macro_sql": "{% macro get_url_parameter(field, url_parameter) -%}\n    {{ return(adapter.dispatch('get_url_parameter', 'dbt_utils')(field, url_parameter)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_url_parameter"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1959686, "supported_languages": null}, "macro.dbt_utils.default__get_url_parameter": {"name": "default__get_url_parameter", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_parameter.sql", "original_file_path": "macros/web/get_url_parameter.sql", "unique_id": "macro.dbt_utils.default__get_url_parameter", "macro_sql": "{% macro default__get_url_parameter(field, url_parameter) -%}\n\n{%- set formatted_url_parameter = \"'\" + url_parameter + \"='\" -%}\n\n{%- set split = split_part(split_part(field, formatted_url_parameter, 2), \"'&'\", 1) -%}\n\nnullif({{ split }},'')\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.split_part"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1964722, "supported_languages": null}, "macro.dbt_utils.get_url_path": {"name": "get_url_path", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_path.sql", "original_file_path": "macros/web/get_url_path.sql", "unique_id": "macro.dbt_utils.get_url_path", "macro_sql": "{% macro get_url_path(field) -%}\n    {{ return(adapter.dispatch('get_url_path', 'dbt_utils')(field)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_url_path"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1969998, "supported_languages": null}, "macro.dbt_utils.default__get_url_path": {"name": "default__get_url_path", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_path.sql", "original_file_path": "macros/web/get_url_path.sql", "unique_id": "macro.dbt_utils.default__get_url_path", "macro_sql": "{% macro default__get_url_path(field) -%}\n\n    {%- set stripped_url =\n        replace(\n            replace(field, \"'http://'\", \"''\"), \"'https://'\", \"''\")\n    -%}\n\n    {%- set first_slash_pos -%}\n        coalesce(\n            nullif({{ position(\"'/'\", stripped_url) }}, 0),\n            {{ position(\"'?'\", stripped_url) }} - 1\n            )\n    {%- endset -%}\n\n    {%- set parsed_path =\n        split_part(\n            right(\n                stripped_url,\n                length(stripped_url) ~ \"-\" ~ first_slash_pos\n                ),\n            \"'?'\", 1\n            )\n    -%}\n\n    {{ safe_cast(\n        parsed_path,\n        type_string()\n    )}}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.replace", "macro.dbt_utils.position", "macro.dbt_utils.split_part", "macro.dbt_utils.right", "macro.dbt_utils.length", "macro.dbt_utils.safe_cast", "macro.dbt_utils.type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1978502, "supported_languages": null}, "macro.dbt_utils.get_url_host": {"name": "get_url_host", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_host.sql", "original_file_path": "macros/web/get_url_host.sql", "unique_id": "macro.dbt_utils.get_url_host", "macro_sql": "{% macro get_url_host(field) -%}\n    {{ return(adapter.dispatch('get_url_host', 'dbt_utils')(field)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_url_host"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1982217, "supported_languages": null}, "macro.dbt_utils.default__get_url_host": {"name": "default__get_url_host", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/web/get_url_host.sql", "original_file_path": "macros/web/get_url_host.sql", "unique_id": "macro.dbt_utils.default__get_url_host", "macro_sql": "{% macro default__get_url_host(field) -%}\n\n{%- set parsed =\n    split_part(\n        split_part(\n            replace(\n                replace(\n                    replace(field, \"'android-app://'\", \"''\"\n                    ), \"'http://'\", \"''\"\n                ), \"'https://'\", \"''\"\n            ), \"'/'\", 1\n        ), \"'?'\", 1\n    )\n\n-%}\n\n\n    {{ dbt.safe_cast(\n        parsed,\n        type_string()\n        )}}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.split_part", "macro.dbt_utils.replace", "macro.dbt.safe_cast", "macro.dbt_utils.type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.198743, "supported_languages": null}, "macro.dbt_utils.test_expression_is_true": {"name": "test_expression_is_true", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/expression_is_true.sql", "original_file_path": "macros/generic_tests/expression_is_true.sql", "unique_id": "macro.dbt_utils.test_expression_is_true", "macro_sql": "{% test expression_is_true(model, expression, column_name=None, condition='1=1') %}\n{# T-SQL has no boolean data type so we use 1=1 which returns TRUE #}\n{# ref https://stackoverflow.com/a/7170753/3842610 #}\n  {{ return(adapter.dispatch('test_expression_is_true', 'dbt_utils')(model, expression, column_name, condition)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_expression_is_true"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1992648, "supported_languages": null}, "macro.dbt_utils.default__test_expression_is_true": {"name": "default__test_expression_is_true", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/expression_is_true.sql", "original_file_path": "macros/generic_tests/expression_is_true.sql", "unique_id": "macro.dbt_utils.default__test_expression_is_true", "macro_sql": "{% macro default__test_expression_is_true(model, expression, column_name, condition) %}\n\nwith meet_condition as (\n    select * from {{ model }} where {{ condition }}\n)\n\nselect\n    *\nfrom meet_condition\n{% if column_name is none %}\nwhere not({{ expression }})\n{%- else %}\nwhere not({{ column_name }} {{ expression }})\n{%- endif %}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.1997902, "supported_languages": null}, "macro.dbt_utils.test_sequential_values": {"name": "test_sequential_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/sequential_values.sql", "original_file_path": "macros/generic_tests/sequential_values.sql", "unique_id": "macro.dbt_utils.test_sequential_values", "macro_sql": "{% test sequential_values(model, column_name, interval=1, datepart=None) %}\n\n  {{ return(adapter.dispatch('test_sequential_values', 'dbt_utils')(model, column_name, interval, datepart)) }}\n\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_sequential_values"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2005095, "supported_languages": null}, "macro.dbt_utils.default__test_sequential_values": {"name": "default__test_sequential_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/sequential_values.sql", "original_file_path": "macros/generic_tests/sequential_values.sql", "unique_id": "macro.dbt_utils.default__test_sequential_values", "macro_sql": "{% macro default__test_sequential_values(model, column_name, interval=1, datepart=None) %}\n\n{% set previous_column_name = \"previous_\" ~ dbt_utils.slugify(column_name) %}\n\nwith windowed as (\n\n    select\n        {{ column_name }},\n        lag({{ column_name }}) over (\n            order by {{ column_name }}\n        ) as {{ previous_column_name }}\n    from {{ model }}\n),\n\nvalidation_errors as (\n    select\n        *\n    from windowed\n    {% if datepart %}\n    where not(cast({{ column_name }} as {{ type_timestamp() }})= cast({{ dateadd(datepart, interval, previous_column_name) }} as {{ type_timestamp() }}))\n    {% else %}\n    where not({{ column_name }} = {{ previous_column_name }} + {{ interval }})\n    {% endif %}\n)\n\nselect *\nfrom validation_errors\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.slugify", "macro.dbt_utils.type_timestamp", "macro.dbt_utils.dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2014973, "supported_languages": null}, "macro.dbt_utils.test_not_null_proportion": {"name": "test_not_null_proportion", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_null_proportion.sql", "original_file_path": "macros/generic_tests/not_null_proportion.sql", "unique_id": "macro.dbt_utils.test_not_null_proportion", "macro_sql": "{% macro test_not_null_proportion(model) %}\n  {{ return(adapter.dispatch('test_not_null_proportion', 'dbt_utils')(model, **kwargs)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_not_null_proportion"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2019255, "supported_languages": null}, "macro.dbt_utils.default__test_not_null_proportion": {"name": "default__test_not_null_proportion", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_null_proportion.sql", "original_file_path": "macros/generic_tests/not_null_proportion.sql", "unique_id": "macro.dbt_utils.default__test_not_null_proportion", "macro_sql": "{% macro default__test_not_null_proportion(model) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('arg')) %}\n{% set at_least = kwargs.get('at_least', kwargs.get('arg')) %}\n{% set at_most = kwargs.get('at_most', kwargs.get('arg', 1)) %}\n\nwith validation as (\n  select\n    sum(case when {{ column_name }} is null then 0 else 1 end) / cast(count(*) as numeric) as not_null_proportion\n  from {{ model }}\n),\nvalidation_errors as (\n  select\n    not_null_proportion\n  from validation\n  where not_null_proportion < {{ at_least }} or not_null_proportion > {{ at_most }}\n)\nselect\n  *\nfrom validation_errors\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2025793, "supported_languages": null}, "macro.dbt_utils.test_accepted_range": {"name": "test_accepted_range", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/accepted_range.sql", "original_file_path": "macros/generic_tests/accepted_range.sql", "unique_id": "macro.dbt_utils.test_accepted_range", "macro_sql": "{% test accepted_range(model, column_name, min_value=none, max_value=none, inclusive=true) %}\n  {{ return(adapter.dispatch('test_accepted_range', 'dbt_utils')(model, column_name, min_value, max_value, inclusive)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_accepted_range"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2031717, "supported_languages": null}, "macro.dbt_utils.default__test_accepted_range": {"name": "default__test_accepted_range", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/accepted_range.sql", "original_file_path": "macros/generic_tests/accepted_range.sql", "unique_id": "macro.dbt_utils.default__test_accepted_range", "macro_sql": "{% macro default__test_accepted_range(model, column_name, min_value=none, max_value=none, inclusive=true) %}\n\nwith meet_condition as(\n  select *\n  from {{ model }}\n),\n\nvalidation_errors as (\n  select *\n  from meet_condition\n  where\n    -- never true, defaults to an empty result set. Exists to ensure any combo of the `or` clauses below succeeds\n    1 = 2\n\n  {%- if min_value is not none %}\n    -- records with a value >= min_value are permitted. The `not` flips this to find records that don't meet the rule.\n    or not {{ column_name }} > {{- \"=\" if inclusive }} {{ min_value }}\n  {%- endif %}\n\n  {%- if max_value is not none %}\n    -- records with a value <= max_value are permitted. The `not` flips this to find records that don't meet the rule.\n    or not {{ column_name }} < {{- \"=\" if inclusive }} {{ max_value }}\n  {%- endif %}\n)\n\nselect *\nfrom validation_errors\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2038798, "supported_languages": null}, "macro.dbt_utils.test_equal_rowcount": {"name": "test_equal_rowcount", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/equal_rowcount.sql", "original_file_path": "macros/generic_tests/equal_rowcount.sql", "unique_id": "macro.dbt_utils.test_equal_rowcount", "macro_sql": "{% test equal_rowcount(model, compare_model) %}\n  {{ return(adapter.dispatch('test_equal_rowcount', 'dbt_utils')(model, compare_model)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_equal_rowcount"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.204424, "supported_languages": null}, "macro.dbt_utils.default__test_equal_rowcount": {"name": "default__test_equal_rowcount", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/equal_rowcount.sql", "original_file_path": "macros/generic_tests/equal_rowcount.sql", "unique_id": "macro.dbt_utils.default__test_equal_rowcount", "macro_sql": "{% macro default__test_equal_rowcount(model, compare_model) %}\n\n{#-- Needs to be set at parse time, before we return '' below --#}\n{{ config(fail_calc = 'coalesce(diff_count, 0)') }}\n\n{#-- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. #}\n{%- if not execute -%}\n    {{ return('') }}\n{% endif %}\n\nwith a as (\n\n    select count(*) as count_a from {{ model }}\n\n),\nb as (\n\n    select count(*) as count_b from {{ compare_model }}\n\n),\nfinal as (\n\n    select\n        count_a,\n        count_b,\n        abs(count_a - count_b) as diff_count\n    from a\n    cross join b\n\n)\n\nselect * from final\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2049265, "supported_languages": null}, "macro.dbt_utils.test_fewer_rows_than": {"name": "test_fewer_rows_than", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/fewer_rows_than.sql", "original_file_path": "macros/generic_tests/fewer_rows_than.sql", "unique_id": "macro.dbt_utils.test_fewer_rows_than", "macro_sql": "{% test fewer_rows_than(model, compare_model) %}\n  {{ return(adapter.dispatch('test_fewer_rows_than', 'dbt_utils')(model, compare_model)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_fewer_rows_than"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.205451, "supported_languages": null}, "macro.dbt_utils.default__test_fewer_rows_than": {"name": "default__test_fewer_rows_than", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/fewer_rows_than.sql", "original_file_path": "macros/generic_tests/fewer_rows_than.sql", "unique_id": "macro.dbt_utils.default__test_fewer_rows_than", "macro_sql": "{% macro default__test_fewer_rows_than(model, compare_model) %}\n\n{{ config(fail_calc = 'coalesce(row_count_delta, 0)') }}\n\nwith a as (\n\n    select count(*) as count_our_model from {{ model }}\n\n),\nb as (\n\n    select count(*) as count_comparison_model from {{ compare_model }}\n\n),\ncounts as (\n\n    select\n        count_our_model,\n        count_comparison_model\n    from a\n    cross join b\n\n),\nfinal as (\n\n    select *,\n        case\n            -- fail the test if we have more rows than the reference model and return the row count delta\n            when count_our_model > count_comparison_model then (count_our_model - count_comparison_model)\n            -- fail the test if they are the same number\n            when count_our_model = count_comparison_model then 1\n            -- pass the test if the delta is positive (i.e. return the number 0)\n            else 0\n    end as row_count_delta\n    from counts\n\n)\n\nselect * from final\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2057543, "supported_languages": null}, "macro.dbt_utils.test_unique_combination_of_columns": {"name": "test_unique_combination_of_columns", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/unique_combination_of_columns.sql", "original_file_path": "macros/generic_tests/unique_combination_of_columns.sql", "unique_id": "macro.dbt_utils.test_unique_combination_of_columns", "macro_sql": "{% test unique_combination_of_columns(model, combination_of_columns, quote_columns=false) %}\n  {{ return(adapter.dispatch('test_unique_combination_of_columns', 'dbt_utils')(model, combination_of_columns, quote_columns)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_unique_combination_of_columns"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2062757, "supported_languages": null}, "macro.dbt_utils.default__test_unique_combination_of_columns": {"name": "default__test_unique_combination_of_columns", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/unique_combination_of_columns.sql", "original_file_path": "macros/generic_tests/unique_combination_of_columns.sql", "unique_id": "macro.dbt_utils.default__test_unique_combination_of_columns", "macro_sql": "{% macro default__test_unique_combination_of_columns(model, combination_of_columns, quote_columns=false) %}\n\n{% if not quote_columns %}\n    {%- set column_list=combination_of_columns %}\n{% elif quote_columns %}\n    {%- set column_list=[] %}\n        {% for column in combination_of_columns -%}\n            {% set column_list = column_list.append( adapter.quote(column) ) %}\n        {%- endfor %}\n{% else %}\n    {{ exceptions.raise_compiler_error(\n        \"`quote_columns` argument for unique_combination_of_columns test must be one of [True, False] Got: '\" ~ quote ~\"'.'\"\n    ) }}\n{% endif %}\n\n{%- set columns_csv=column_list | join(', ') %}\n\n\nwith validation_errors as (\n\n    select\n        {{ columns_csv }}\n    from {{ model }}\n    group by {{ columns_csv }}\n    having count(*) > 1\n\n)\n\nselect *\nfrom validation_errors\n\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2071028, "supported_languages": null}, "macro.dbt_utils.test_cardinality_equality": {"name": "test_cardinality_equality", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/cardinality_equality.sql", "original_file_path": "macros/generic_tests/cardinality_equality.sql", "unique_id": "macro.dbt_utils.test_cardinality_equality", "macro_sql": "{% test cardinality_equality(model, column_name, to, field) %}\n    {{ return(adapter.dispatch('test_cardinality_equality', 'dbt_utils')(model, column_name, to, field)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_cardinality_equality"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2075791, "supported_languages": null}, "macro.dbt_utils.default__test_cardinality_equality": {"name": "default__test_cardinality_equality", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/cardinality_equality.sql", "original_file_path": "macros/generic_tests/cardinality_equality.sql", "unique_id": "macro.dbt_utils.default__test_cardinality_equality", "macro_sql": "{% macro default__test_cardinality_equality(model, column_name, to, field) %}\n\n{# T-SQL does not let you use numbers as aliases for columns #}\n{# Thus, no \"GROUP BY 1\" #}\n\nwith table_a as (\nselect\n  {{ column_name }},\n  count(*) as num_rows\nfrom {{ model }}\ngroup by {{ column_name }}\n),\n\ntable_b as (\nselect\n  {{ field }},\n  count(*) as num_rows\nfrom {{ to }}\ngroup by {{ field }}\n),\n\nexcept_a as (\n  select *\n  from table_a\n  {{ except() }}\n  select *\n  from table_b\n),\n\nexcept_b as (\n  select *\n  from table_b\n  {{ except() }}\n  select *\n  from table_a\n),\n\nunioned as (\n  select *\n  from except_a\n  union all\n  select *\n  from except_b\n)\n\nselect *\nfrom unioned\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.except"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2079964, "supported_languages": null}, "macro.dbt_utils.test_not_null_where": {"name": "test_not_null_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/test_not_null_where.sql", "original_file_path": "macros/generic_tests/test_not_null_where.sql", "unique_id": "macro.dbt_utils.test_not_null_where", "macro_sql": "{% test not_null_where(model, column_name) %}\r\n  {%- set deprecation_warning = '\r\n    Warning: `dbt_utils.not_null_where` is no longer supported.\r\n    Starting in dbt v0.20.0, the built-in `not_null` test supports a `where` config.\r\n    ' -%}\r\n  {%- do exceptions.warn(deprecation_warning) -%}\r\n  {{ return(adapter.dispatch('test_not_null_where', 'dbt_utils')(model, column_name)) }}\r\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_not_null_where"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2085133, "supported_languages": null}, "macro.dbt_utils.default__test_not_null_where": {"name": "default__test_not_null_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/test_not_null_where.sql", "original_file_path": "macros/generic_tests/test_not_null_where.sql", "unique_id": "macro.dbt_utils.default__test_not_null_where", "macro_sql": "{% macro default__test_not_null_where(model, column_name) %}\r\n  {{ return(test_not_null(model, column_name)) }}\r\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.test_not_null"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2087328, "supported_languages": null}, "macro.dbt_utils.test_equality": {"name": "test_equality", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/equality.sql", "original_file_path": "macros/generic_tests/equality.sql", "unique_id": "macro.dbt_utils.test_equality", "macro_sql": "{% test equality(model, compare_model, compare_columns=None) %}\n  {{ return(adapter.dispatch('test_equality', 'dbt_utils')(model, compare_model, compare_columns)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_equality"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.209361, "supported_languages": null}, "macro.dbt_utils.default__test_equality": {"name": "default__test_equality", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/equality.sql", "original_file_path": "macros/generic_tests/equality.sql", "unique_id": "macro.dbt_utils.default__test_equality", "macro_sql": "{% macro default__test_equality(model, compare_model, compare_columns=None) %}\n\n{% set set_diff %}\n    count(*) + coalesce(abs(\n        sum(case when which_diff = 'a_minus_b' then 1 else 0 end) -\n        sum(case when which_diff = 'b_minus_a' then 1 else 0 end)\n    ), 0)\n{% endset %}\n\n{#-- Needs to be set at parse time, before we return '' below --#}\n{{ config(fail_calc = set_diff) }}\n\n{#-- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. #}\n{%- if not execute -%}\n    {{ return('') }}\n{% endif %}\n\n-- setup\n{%- do dbt_utils._is_relation(model, 'test_equality') -%}\n\n{#-\nIf the compare_cols arg is provided, we can run this test without querying the\ninformation schema\u00a0\u2014 this allows the model to be an ephemeral model\n-#}\n\n{%- if not compare_columns -%}\n    {%- do dbt_utils._is_ephemeral(model, 'test_equality') -%}\n    {%- set compare_columns = adapter.get_columns_in_relation(model) | map(attribute='quoted') -%}\n{%- endif -%}\n\n{% set compare_cols_csv = compare_columns | join(', ') %}\n\nwith a as (\n\n    select * from {{ model }}\n\n),\n\nb as (\n\n    select * from {{ compare_model }}\n\n),\n\na_minus_b as (\n\n    select {{compare_cols_csv}} from a\n    {{ except() }}\n    select {{compare_cols_csv}} from b\n\n),\n\nb_minus_a as (\n\n    select {{compare_cols_csv}} from b\n    {{ except() }}\n    select {{compare_cols_csv}} from a\n\n),\n\nunioned as (\n\n    select 'a_minus_b' as which_diff, a_minus_b.* from a_minus_b\n    union all\n    select 'b_minus_a' as which_diff, b_minus_a.* from b_minus_a\n\n)\n\nselect * from unioned\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral", "macro.dbt_utils.except"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2107549, "supported_languages": null}, "macro.dbt_utils.test_not_constant": {"name": "test_not_constant", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_constant.sql", "original_file_path": "macros/generic_tests/not_constant.sql", "unique_id": "macro.dbt_utils.test_not_constant", "macro_sql": "{% test not_constant(model, column_name) %}\n  {{ return(adapter.dispatch('test_not_constant', 'dbt_utils')(model, column_name)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_not_constant"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2111688, "supported_languages": null}, "macro.dbt_utils.default__test_not_constant": {"name": "default__test_not_constant", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_constant.sql", "original_file_path": "macros/generic_tests/not_constant.sql", "unique_id": "macro.dbt_utils.default__test_not_constant", "macro_sql": "{% macro default__test_not_constant(model, column_name) %}\n\n\nselect\n    {# In TSQL, subquery aggregate columns need aliases #}\n    {# thus: a filler col name, 'filler_column' #}\n    count(distinct {{ column_name }}) as filler_column\n\nfrom {{ model }}\n\nhaving count(distinct {{ column_name }}) = 1\n\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.211409, "supported_languages": null}, "macro.dbt_utils.test_at_least_one": {"name": "test_at_least_one", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/at_least_one.sql", "original_file_path": "macros/generic_tests/at_least_one.sql", "unique_id": "macro.dbt_utils.test_at_least_one", "macro_sql": "{% test at_least_one(model, column_name) %}\n  {{ return(adapter.dispatch('test_at_least_one', 'dbt_utils')(model, column_name)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_at_least_one"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2118874, "supported_languages": null}, "macro.dbt_utils.default__test_at_least_one": {"name": "default__test_at_least_one", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/at_least_one.sql", "original_file_path": "macros/generic_tests/at_least_one.sql", "unique_id": "macro.dbt_utils.default__test_at_least_one", "macro_sql": "{% macro default__test_at_least_one(model, column_name) %}\n\nselect *\nfrom (\n    select\n        {# In TSQL, subquery aggregate columns need aliases #}\n        {# thus: a filler col name, 'filler_column' #}\n      count({{ column_name }}) as filler_column\n\n    from {{ model }}\n\n    having count({{ column_name }}) = 0\n\n) validation_errors\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2121909, "supported_languages": null}, "macro.dbt_utils.test_not_accepted_values": {"name": "test_not_accepted_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_accepted_values.sql", "original_file_path": "macros/generic_tests/not_accepted_values.sql", "unique_id": "macro.dbt_utils.test_not_accepted_values", "macro_sql": "{% test not_accepted_values(model, column_name, values, quote=True) %}\n  {{ return(adapter.dispatch('test_not_accepted_values', 'dbt_utils')(model, column_name, values, quote)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_not_accepted_values"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2128448, "supported_languages": null}, "macro.dbt_utils.default__test_not_accepted_values": {"name": "default__test_not_accepted_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/not_accepted_values.sql", "original_file_path": "macros/generic_tests/not_accepted_values.sql", "unique_id": "macro.dbt_utils.default__test_not_accepted_values", "macro_sql": "{% macro default__test_not_accepted_values(model, column_name, values, quote=True) %}\nwith all_values as (\n\n    select distinct\n        {{ column_name }} as value_field\n\n    from {{ model }}\n\n),\n\nvalidation_errors as (\n\n    select\n        value_field\n\n    from all_values\n    where value_field in (\n        {% for value in values -%}\n            {% if quote -%}\n            '{{ value }}'\n            {%- else -%}\n            {{ value }}\n            {%- endif -%}\n            {%- if not loop.last -%},{%- endif %}\n        {%- endfor %}\n        )\n\n)\n\nselect *\nfrom validation_errors\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2134917, "supported_languages": null}, "macro.dbt_utils.test_relationships_where": {"name": "test_relationships_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/relationships_where.sql", "original_file_path": "macros/generic_tests/relationships_where.sql", "unique_id": "macro.dbt_utils.test_relationships_where", "macro_sql": "{% test relationships_where(model, column_name, to, field, from_condition=\"1=1\", to_condition=\"1=1\") %}\n  {{ return(adapter.dispatch('test_relationships_where', 'dbt_utils')(model, column_name, to, field, from_condition, to_condition)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_relationships_where"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.214079, "supported_languages": null}, "macro.dbt_utils.default__test_relationships_where": {"name": "default__test_relationships_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/relationships_where.sql", "original_file_path": "macros/generic_tests/relationships_where.sql", "unique_id": "macro.dbt_utils.default__test_relationships_where", "macro_sql": "{% macro default__test_relationships_where(model, column_name, to, field, from_condition=\"1=1\", to_condition=\"1=1\") %}\n\n{# T-SQL has no boolean data type so we use 1=1 which returns TRUE #}\n{# ref https://stackoverflow.com/a/7170753/3842610 #}\n\nwith left_table as (\n\n  select\n    {{column_name}} as id\n\n  from {{model}}\n\n  where {{column_name}} is not null\n    and {{from_condition}}\n\n),\n\nright_table as (\n\n  select\n    {{field}} as id\n\n  from {{to}}\n\n  where {{field}} is not null\n    and {{to_condition}}\n\n),\n\nexceptions as (\n\n  select\n    left_table.id,\n    right_table.id as right_id\n\n  from left_table\n\n  left join right_table\n         on left_table.id = right_table.id\n\n  where right_table.id is null\n\n)\n\nselect * from exceptions\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.214528, "supported_languages": null}, "macro.dbt_utils.test_unique_where": {"name": "test_unique_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/test_unique_where.sql", "original_file_path": "macros/generic_tests/test_unique_where.sql", "unique_id": "macro.dbt_utils.test_unique_where", "macro_sql": "{% test unique_where(model, column_name) %}\r\n  {%- set deprecation_warning = '\r\n    Warning: `dbt_utils.unique_where` is no longer supported.\r\n    Starting in dbt v0.20.0, the built-in `unique` test supports a `where` config.\r\n    ' -%}\r\n  {%- do exceptions.warn(deprecation_warning) -%}\r\n  {{ return(adapter.dispatch('test_unique_where', 'dbt_utils')(model, column_name)) }}\r\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_unique_where"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2150218, "supported_languages": null}, "macro.dbt_utils.default__test_unique_where": {"name": "default__test_unique_where", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/test_unique_where.sql", "original_file_path": "macros/generic_tests/test_unique_where.sql", "unique_id": "macro.dbt_utils.default__test_unique_where", "macro_sql": "{% macro default__test_unique_where(model, column_name) %}\r\n  {{ return(test_unique(model, column_name)) }}\r\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.test_unique"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2152433, "supported_languages": null}, "macro.dbt_utils.test_mutually_exclusive_ranges": {"name": "test_mutually_exclusive_ranges", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/mutually_exclusive_ranges.sql", "original_file_path": "macros/generic_tests/mutually_exclusive_ranges.sql", "unique_id": "macro.dbt_utils.test_mutually_exclusive_ranges", "macro_sql": "{% test mutually_exclusive_ranges(model, lower_bound_column, upper_bound_column, partition_by=None, gaps='allowed', zero_length_range_allowed=False) %}\n  {{ return(adapter.dispatch('test_mutually_exclusive_ranges', 'dbt_utils')(model, lower_bound_column, upper_bound_column, partition_by, gaps, zero_length_range_allowed)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_mutually_exclusive_ranges"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2162306, "supported_languages": null}, "macro.dbt_utils.default__test_mutually_exclusive_ranges": {"name": "default__test_mutually_exclusive_ranges", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/mutually_exclusive_ranges.sql", "original_file_path": "macros/generic_tests/mutually_exclusive_ranges.sql", "unique_id": "macro.dbt_utils.default__test_mutually_exclusive_ranges", "macro_sql": "{% macro default__test_mutually_exclusive_ranges(model, lower_bound_column, upper_bound_column, partition_by=None, gaps='allowed', zero_length_range_allowed=False) %}\n{% if gaps == 'not_allowed' %}\n    {% set allow_gaps_operator='=' %}\n    {% set allow_gaps_operator_in_words='equal_to' %}\n{% elif gaps == 'allowed' %}\n    {% set allow_gaps_operator='<=' %}\n    {% set allow_gaps_operator_in_words='less_than_or_equal_to' %}\n{% elif gaps == 'required' %}\n    {% set allow_gaps_operator='<' %}\n    {% set allow_gaps_operator_in_words='less_than' %}\n{% else %}\n    {{ exceptions.raise_compiler_error(\n        \"`gaps` argument for mutually_exclusive_ranges test must be one of ['not_allowed', 'allowed', 'required'] Got: '\" ~ gaps ~\"'.'\"\n    ) }}\n{% endif %}\n{% if not zero_length_range_allowed %}\n    {% set allow_zero_length_operator='<' %}\n    {% set allow_zero_length_operator_in_words='less_than' %}\n{% elif zero_length_range_allowed %}\n    {% set allow_zero_length_operator='<=' %}\n    {% set allow_zero_length_operator_in_words='less_than_or_equal_to' %}\n{% else %}\n    {{ exceptions.raise_compiler_error(\n        \"`zero_length_range_allowed` argument for mutually_exclusive_ranges test must be one of [true, false] Got: '\" ~ zero_length_range_allowed ~\"'.'\"\n    ) }}\n{% endif %}\n\n{% set partition_clause=\"partition by \" ~ partition_by if partition_by else '' %}\n\nwith window_functions as (\n\n    select\n        {% if partition_by %}\n        {{ partition_by }} as partition_by_col,\n        {% endif %}\n        {{ lower_bound_column }} as lower_bound,\n        {{ upper_bound_column }} as upper_bound,\n\n        lead({{ lower_bound_column }}) over (\n            {{ partition_clause }}\n            order by {{ lower_bound_column }}, {{ upper_bound_column }}\n        ) as next_lower_bound,\n\n        row_number() over (\n            {{ partition_clause }}\n            order by {{ lower_bound_column }} desc, {{ upper_bound_column }} desc\n        ) = 1 as is_last_record\n\n    from {{ model }}\n\n),\n\ncalc as (\n    -- We want to return records where one of our assumptions fails, so we'll use\n    -- the `not` function with `and` statements so we can write our assumptions nore cleanly\n    select\n        *,\n\n        -- For each record: lower_bound should be < upper_bound.\n        -- Coalesce it to return an error on the null case (implicit assumption\n        -- these columns are not_null)\n        coalesce(\n            lower_bound {{ allow_zero_length_operator }} upper_bound,\n            false\n        ) as lower_bound_{{ allow_zero_length_operator_in_words }}_upper_bound,\n\n        -- For each record: upper_bound {{ allow_gaps_operator }} the next lower_bound.\n        -- Coalesce it to handle null cases for the last record.\n        coalesce(\n            upper_bound {{ allow_gaps_operator }} next_lower_bound,\n            is_last_record,\n            false\n        ) as upper_bound_{{ allow_gaps_operator_in_words }}_next_lower_bound\n\n    from window_functions\n\n),\n\nvalidation_errors as (\n\n    select\n        *\n    from calc\n\n    where not(\n        -- THE FOLLOWING SHOULD BE TRUE --\n        lower_bound_{{ allow_zero_length_operator_in_words }}_upper_bound\n        and upper_bound_{{ allow_gaps_operator_in_words }}_next_lower_bound\n    )\n)\n\nselect * from validation_errors\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2182841, "supported_languages": null}, "macro.dbt_utils.test_recency": {"name": "test_recency", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/recency.sql", "original_file_path": "macros/generic_tests/recency.sql", "unique_id": "macro.dbt_utils.test_recency", "macro_sql": "{% test recency(model, field, datepart, interval) %}\n  {{ return(adapter.dispatch('test_recency', 'dbt_utils')(model, field, datepart, interval)) }}\n{% endtest %}", "depends_on": {"macros": ["macro.dbt_utils.default__test_recency"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2187543, "supported_languages": null}, "macro.dbt_utils.default__test_recency": {"name": "default__test_recency", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/generic_tests/recency.sql", "original_file_path": "macros/generic_tests/recency.sql", "unique_id": "macro.dbt_utils.default__test_recency", "macro_sql": "{% macro default__test_recency(model, field, datepart, interval) %}\n\n{% set threshold = dateadd(datepart, interval * -1, current_timestamp()) %}\n\nwith recency as (\n\n    select max({{field}}) as most_recent\n    from {{ model }}\n\n)\n\nselect\n\n    most_recent,\n    {{ threshold }} as threshold\n\nfrom recency\nwhere most_recent < {{ threshold }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.dateadd", "macro.dbt_utils.current_timestamp"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.219163, "supported_languages": null}, "macro.dbt_utils.get_powers_of_two": {"name": "get_powers_of_two", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/generate_series.sql", "original_file_path": "macros/sql/generate_series.sql", "unique_id": "macro.dbt_utils.get_powers_of_two", "macro_sql": "{% macro get_powers_of_two(upper_bound) %}\n    {{ return(adapter.dispatch('get_powers_of_two', 'dbt_utils')(upper_bound)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_powers_of_two"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2197123, "supported_languages": null}, "macro.dbt_utils.default__get_powers_of_two": {"name": "default__get_powers_of_two", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/generate_series.sql", "original_file_path": "macros/sql/generate_series.sql", "unique_id": "macro.dbt_utils.default__get_powers_of_two", "macro_sql": "{% macro default__get_powers_of_two(upper_bound) %}\n\n    {% if upper_bound <= 0 %}\n    {{ exceptions.raise_compiler_error(\"upper bound must be positive\") }}\n    {% endif %}\n\n    {% for _ in range(1, 100) %}\n       {% if upper_bound <= 2 ** loop.index %}{{ return(loop.index) }}{% endif %}\n    {% endfor %}\n\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2202415, "supported_languages": null}, "macro.dbt_utils.generate_series": {"name": "generate_series", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/generate_series.sql", "original_file_path": "macros/sql/generate_series.sql", "unique_id": "macro.dbt_utils.generate_series", "macro_sql": "{% macro generate_series(upper_bound) %}\n    {{ return(adapter.dispatch('generate_series', 'dbt_utils')(upper_bound)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__generate_series"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2204885, "supported_languages": null}, "macro.dbt_utils.default__generate_series": {"name": "default__generate_series", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/generate_series.sql", "original_file_path": "macros/sql/generate_series.sql", "unique_id": "macro.dbt_utils.default__generate_series", "macro_sql": "{% macro default__generate_series(upper_bound) %}\n\n    {% set n = dbt_utils.get_powers_of_two(upper_bound) %}\n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    {% for i in range(n) %}\n    p{{i}}.generated_number * power(2, {{i}})\n    {% if not loop.last %} + {% endif %}\n    {% endfor %}\n    + 1\n    as generated_number\n\n    from\n\n    {% for i in range(n) %}\n    p as p{{i}}\n    {% if not loop.last %} cross join {% endif %}\n    {% endfor %}\n\n    )\n\n    select *\n    from unioned\n    where generated_number <= {{upper_bound}}\n    order by generated_number\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.get_powers_of_two"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2211506, "supported_languages": null}, "macro.dbt_utils.get_query_results_as_dict": {"name": "get_query_results_as_dict", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_query_results_as_dict.sql", "original_file_path": "macros/sql/get_query_results_as_dict.sql", "unique_id": "macro.dbt_utils.get_query_results_as_dict", "macro_sql": "{% macro get_query_results_as_dict(query) %}\n    {{ return(adapter.dispatch('get_query_results_as_dict', 'dbt_utils')(query)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_query_results_as_dict"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2216027, "supported_languages": null}, "macro.dbt_utils.default__get_query_results_as_dict": {"name": "default__get_query_results_as_dict", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_query_results_as_dict.sql", "original_file_path": "macros/sql/get_query_results_as_dict.sql", "unique_id": "macro.dbt_utils.default__get_query_results_as_dict", "macro_sql": "{% macro default__get_query_results_as_dict(query) %}\n\n{# This macro returns a dictionary of the form {column_name: (tuple_of_results)} #}\n\n    {%- call statement('get_query_results', fetch_result=True,auto_begin=false) -%}\n\n        {{ query }}\n\n    {%- endcall -%}\n\n    {% set sql_results={} %}\n\n    {%- if execute -%}\n        {% set sql_results_table = load_result('get_query_results').table.columns %}\n        {% for column_name, column in sql_results_table.items() %}\n            {% do sql_results.update({column_name: column.values()}) %}\n        {% endfor %}\n    {%- endif -%}\n\n    {{ return(sql_results) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2223554, "supported_languages": null}, "macro.dbt_utils.union_relations": {"name": "union_relations", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/union.sql", "original_file_path": "macros/sql/union.sql", "unique_id": "macro.dbt_utils.union_relations", "macro_sql": "{%- macro union_relations(relations, column_override=none, include=[], exclude=[], source_column_name='_dbt_source_relation', where=none) -%}\n    {{ return(adapter.dispatch('union_relations', 'dbt_utils')(relations, column_override, include, exclude, source_column_name, where)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__union_relations"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2235599, "supported_languages": null}, "macro.dbt_utils.default__union_relations": {"name": "default__union_relations", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/union.sql", "original_file_path": "macros/sql/union.sql", "unique_id": "macro.dbt_utils.default__union_relations", "macro_sql": "\n\n{%- macro default__union_relations(relations, column_override=none, include=[], exclude=[], source_column_name='_dbt_source_relation', where=none) -%}\n\n    {%- if exclude and include -%}\n        {{ exceptions.raise_compiler_error(\"Both an exclude and include list were provided to the `union` macro. Only one is allowed\") }}\n    {%- endif -%}\n\n    {#-- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. -#}\n    {%- if not execute %}\n        {{ return('') }}\n    {% endif -%}\n\n    {%- set column_override = column_override if column_override is not none else {} -%}\n\n    {%- set relation_columns = {} -%}\n    {%- set column_superset = {} -%}\n\n    {%- for relation in relations -%}\n\n        {%- do relation_columns.update({relation: []}) -%}\n\n        {%- do dbt_utils._is_relation(relation, 'union_relations') -%}\n        {%- do dbt_utils._is_ephemeral(relation, 'union_relations') -%}\n        {%- set cols = adapter.get_columns_in_relation(relation) -%}\n        {%- for col in cols -%}\n\n        {#- If an exclude list was provided and the column is in the list, do nothing -#}\n        {%- if exclude and col.column in exclude -%}\n\n        {#- If an include list was provided and the column is not in the list, do nothing -#}\n        {%- elif include and col.column not in include -%}\n\n        {#- Otherwise add the column to the column superset -#}\n        {%- else -%}\n\n            {#- update the list of columns in this relation -#}\n            {%- do relation_columns[relation].append(col.column) -%}\n\n            {%- if col.column in column_superset -%}\n\n                {%- set stored = column_superset[col.column] -%}\n                {%- if col.is_string() and stored.is_string() and col.string_size() > stored.string_size() -%}\n\n                    {%- do column_superset.update({col.column: col}) -%}\n\n                {%- endif %}\n\n            {%- else -%}\n\n                {%- do column_superset.update({col.column: col}) -%}\n\n            {%- endif -%}\n\n        {%- endif -%}\n\n        {%- endfor -%}\n    {%- endfor -%}\n\n    {%- set ordered_column_names = column_superset.keys() -%}\n    {%- set dbt_command = flags.WHICH -%}\n\n\n    {% if dbt_command in ['run', 'build'] %}\n    {% if (include | length > 0 or exclude | length > 0) and not column_superset.keys() %}\n        {%- set relations_string -%}\n            {%- for relation in relations -%}\n                {{ relation.name }}\n            {%- if not loop.last %}, {% endif -%}\n            {%- endfor -%}\n        {%- endset -%}\n\n        {%- set error_message -%}\n            There were no columns found to union for relations {{ relations_string }}\n        {%- endset -%}\n\n        {{ exceptions.raise_compiler_error(error_message) }}\n    {%- endif -%}\n    {%- endif -%}\n\n    {%- for relation in relations %}\n\n        (\n            select\n\n                {%- if source_column_name is not none %}\n                cast({{ string_literal(relation) }} as {{ type_string() }}) as {{ source_column_name }},\n                {%- endif %}\n\n                {% for col_name in ordered_column_names -%}\n\n                    {%- set col = column_superset[col_name] %}\n                    {%- set col_type = column_override.get(col.column, col.data_type) %}\n                    {%- set col_name = adapter.quote(col_name) if col_name in relation_columns[relation] else 'null' %}\n                    cast({{ col_name }} as {{ col_type }}) as {{ col.quoted }} {% if not loop.last %},{% endif -%}\n\n                {%- endfor %}\n\n            from {{ relation }}\n\n            {% if where -%}\n            where {{ where }}\n            {%- endif %}\n        )\n\n        {% if not loop.last -%}\n            union all\n        {% endif -%}\n\n    {%- endfor -%}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral", "macro.dbt_utils.string_literal", "macro.dbt_utils.type_string"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.227508, "supported_languages": null}, "macro.dbt_utils.get_tables_by_prefix_sql": {"name": "get_tables_by_prefix_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_prefix_sql.sql", "original_file_path": "macros/sql/get_tables_by_prefix_sql.sql", "unique_id": "macro.dbt_utils.get_tables_by_prefix_sql", "macro_sql": "{% macro get_tables_by_prefix_sql(schema, prefix, exclude='', database=target.database) %}\n    {{ return(adapter.dispatch('get_tables_by_prefix_sql', 'dbt_utils')(schema, prefix, exclude, database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_tables_by_prefix_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2280533, "supported_languages": null}, "macro.dbt_utils.default__get_tables_by_prefix_sql": {"name": "default__get_tables_by_prefix_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_prefix_sql.sql", "original_file_path": "macros/sql/get_tables_by_prefix_sql.sql", "unique_id": "macro.dbt_utils.default__get_tables_by_prefix_sql", "macro_sql": "{% macro default__get_tables_by_prefix_sql(schema, prefix, exclude='', database=target.database) %}\n\n    {{ dbt_utils.get_tables_by_pattern_sql(\n        schema_pattern = schema,\n        table_pattern = prefix ~ '%',\n        exclude = exclude,\n        database = database\n    ) }}\n    \n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.get_tables_by_pattern_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.228426, "supported_languages": null}, "macro.dbt_utils.star": {"name": "star", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/star.sql", "original_file_path": "macros/sql/star.sql", "unique_id": "macro.dbt_utils.star", "macro_sql": "{% macro star(from, relation_alias=False, except=[], prefix='', suffix='') -%}\n    {{ return(adapter.dispatch('star', 'dbt_utils')(from, relation_alias, except, prefix, suffix)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__star"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.229156, "supported_languages": null}, "macro.dbt_utils.default__star": {"name": "default__star", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/star.sql", "original_file_path": "macros/sql/star.sql", "unique_id": "macro.dbt_utils.default__star", "macro_sql": "{% macro default__star(from, relation_alias=False, except=[], prefix='', suffix='') -%}\n    {%- do dbt_utils._is_relation(from, 'star') -%}\n    {%- do dbt_utils._is_ephemeral(from, 'star') -%}\n\n    {#-- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. #}\n    {%- if not execute -%}\n        {{ return('*') }}\n    {%- endif -%}\n\n    {% set cols = dbt_utils.get_filtered_columns_in_relation(from, except) %}\n\n    {%- if cols|length <= 0 -%}\n      {{- return('*') -}}\n    {%- else -%}\n        {%- for col in cols %}\n            {%- if relation_alias %}{{ relation_alias }}.{% else %}{%- endif -%}{{ adapter.quote(col)|trim }} {%- if prefix!='' or suffix!='' %} as {{ adapter.quote(prefix ~ col ~ suffix)|trim }} {%- endif -%}\n            {%- if not loop.last %},{{ '\\n  ' }}{% endif %}\n        {%- endfor -%}\n    {% endif %}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral", "macro.dbt_utils.get_filtered_columns_in_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2304206, "supported_languages": null}, "macro.dbt_utils.safe_add": {"name": "safe_add", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/safe_add.sql", "original_file_path": "macros/sql/safe_add.sql", "unique_id": "macro.dbt_utils.safe_add", "macro_sql": "{%- macro safe_add() -%}\n    {# needed for safe_add to allow for non-keyword arguments see SO post #}\n    {# https://stackoverflow.com/questions/13944751/args-kwargs-in-jinja2-macros #}\n    {% set frustrating_jinja_feature = varargs %}\n    {{ return(adapter.dispatch('safe_add', 'dbt_utils')(*varargs)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__safe_add"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2308996, "supported_languages": null}, "macro.dbt_utils.default__safe_add": {"name": "default__safe_add", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/safe_add.sql", "original_file_path": "macros/sql/safe_add.sql", "unique_id": "macro.dbt_utils.default__safe_add", "macro_sql": "\n\n{%- macro default__safe_add() -%}\n\n{% set fields = [] %}\n\n{%- for field in varargs -%}\n\n    {% do fields.append(\"coalesce(\" ~ field ~ \", 0)\") %}\n\n{%- endfor -%}\n\n{{ fields|join(' +\\n  ') }}\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2312794, "supported_languages": null}, "macro.dbt_utils.get_tables_by_pattern_sql": {"name": "get_tables_by_pattern_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_pattern_sql.sql", "original_file_path": "macros/sql/get_tables_by_pattern_sql.sql", "unique_id": "macro.dbt_utils.get_tables_by_pattern_sql", "macro_sql": "{% macro get_tables_by_pattern_sql(schema_pattern, table_pattern, exclude='', database=target.database) %}\n    {{ return(adapter.dispatch('get_tables_by_pattern_sql', 'dbt_utils')\n        (schema_pattern, table_pattern, exclude, database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_tables_by_pattern_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2321084, "supported_languages": null}, "macro.dbt_utils.default__get_tables_by_pattern_sql": {"name": "default__get_tables_by_pattern_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_pattern_sql.sql", "original_file_path": "macros/sql/get_tables_by_pattern_sql.sql", "unique_id": "macro.dbt_utils.default__get_tables_by_pattern_sql", "macro_sql": "{% macro default__get_tables_by_pattern_sql(schema_pattern, table_pattern, exclude='', database=target.database) %}\n\n        select distinct\n            table_schema as {{ adapter.quote('table_schema') }},\n            table_name as {{ adapter.quote('table_name') }},\n            {{ dbt_utils.get_table_types_sql() }}\n        from {{ database }}.information_schema.tables\n        where table_schema ilike '{{ schema_pattern }}'\n        and table_name ilike '{{ table_pattern }}'\n        and table_name not ilike '{{ exclude }}'\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.get_table_types_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2325752, "supported_languages": null}, "macro.dbt_utils.bigquery__get_tables_by_pattern_sql": {"name": "bigquery__get_tables_by_pattern_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_pattern_sql.sql", "original_file_path": "macros/sql/get_tables_by_pattern_sql.sql", "unique_id": "macro.dbt_utils.bigquery__get_tables_by_pattern_sql", "macro_sql": "{% macro bigquery__get_tables_by_pattern_sql(schema_pattern, table_pattern, exclude='', database=target.database) %}\n\n    {% if '%' in schema_pattern %}\n        {% set schemata=dbt_utils._bigquery__get_matching_schemata(schema_pattern, database) %}\n    {% else %}\n        {% set schemata=[schema_pattern] %}\n    {% endif %}\n\n    {% set sql %}\n        {% for schema in schemata %}\n            select distinct\n                table_schema,\n                table_name,\n                {{ dbt_utils.get_table_types_sql() }}\n\n            from {{ adapter.quote(database) }}.{{ schema }}.INFORMATION_SCHEMA.TABLES\n            where lower(table_name) like lower ('{{ table_pattern }}')\n                and lower(table_name) not like lower ('{{ exclude }}')\n\n            {% if not loop.last %} union all {% endif %}\n\n        {% endfor %}\n    {% endset %}\n\n    {{ return(sql) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._bigquery__get_matching_schemata", "macro.dbt_utils.get_table_types_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2334998, "supported_languages": null}, "macro.dbt_utils._bigquery__get_matching_schemata": {"name": "_bigquery__get_matching_schemata", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_tables_by_pattern_sql.sql", "original_file_path": "macros/sql/get_tables_by_pattern_sql.sql", "unique_id": "macro.dbt_utils._bigquery__get_matching_schemata", "macro_sql": "{% macro _bigquery__get_matching_schemata(schema_pattern, database) %}\n    {% if execute %}\n\n        {% set sql %}\n        select schema_name from {{ adapter.quote(database) }}.INFORMATION_SCHEMA.SCHEMATA\n        where lower(schema_name) like lower('{{ schema_pattern }}')\n        {% endset %}\n\n        {% set results=run_query(sql) %}\n\n        {% set schemata=results.columns['schema_name'].values() %}\n\n        {{ return(schemata) }}\n\n    {% else %}\n\n        {{ return([]) }}\n\n    {% endif %}\n\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.run_query"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.234159, "supported_languages": null}, "macro.dbt_utils.group_by": {"name": "group_by", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/groupby.sql", "original_file_path": "macros/sql/groupby.sql", "unique_id": "macro.dbt_utils.group_by", "macro_sql": "{%- macro group_by(n) -%}\n    {{ return(adapter.dispatch('group_by', 'dbt_utils')(n)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__group_by"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2345188, "supported_languages": null}, "macro.dbt_utils.default__group_by": {"name": "default__group_by", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/groupby.sql", "original_file_path": "macros/sql/groupby.sql", "unique_id": "macro.dbt_utils.default__group_by", "macro_sql": "\n\n{%- macro default__group_by(n) -%}\n\n  group by {% for i in range(1, n + 1) -%}\n      {{ i }}{{ ',' if not loop.last }}   \n   {%- endfor -%}\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.234838, "supported_languages": null}, "macro.dbt_utils.get_intervals_between": {"name": "get_intervals_between", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/date_spine.sql", "original_file_path": "macros/sql/date_spine.sql", "unique_id": "macro.dbt_utils.get_intervals_between", "macro_sql": "{% macro get_intervals_between(start_date, end_date, datepart) -%}\n    {{ return(adapter.dispatch('get_intervals_between', 'dbt_utils')(start_date, end_date, datepart)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_intervals_between"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2354417, "supported_languages": null}, "macro.dbt_utils.default__get_intervals_between": {"name": "default__get_intervals_between", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/date_spine.sql", "original_file_path": "macros/sql/date_spine.sql", "unique_id": "macro.dbt_utils.default__get_intervals_between", "macro_sql": "{% macro default__get_intervals_between(start_date, end_date, datepart) -%}\n    {%- call statement('get_intervals_between', fetch_result=True) %}\n\n        select {{ datediff(start_date, end_date, datepart) }}\n\n    {%- endcall -%}\n\n    {%- set value_list = load_result('get_intervals_between') -%}\n\n    {%- if value_list and value_list['data'] -%}\n        {%- set values = value_list['data'] | map(attribute=0) | list %}\n        {{ return(values[0]) }}\n    {%- else -%}\n        {{ return(1) }}\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt_utils.datediff"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2361948, "supported_languages": null}, "macro.dbt_utils.date_spine": {"name": "date_spine", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/date_spine.sql", "original_file_path": "macros/sql/date_spine.sql", "unique_id": "macro.dbt_utils.date_spine", "macro_sql": "{% macro date_spine(datepart, start_date, end_date) %}\n    {{ return(adapter.dispatch('date_spine', 'dbt_utils')(datepart, start_date, end_date)) }}\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__date_spine"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2364864, "supported_languages": null}, "macro.dbt_utils.default__date_spine": {"name": "default__date_spine", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/date_spine.sql", "original_file_path": "macros/sql/date_spine.sql", "unique_id": "macro.dbt_utils.default__date_spine", "macro_sql": "{% macro default__date_spine(datepart, start_date, end_date) %}\n\n\n{# call as follows:\n\ndate_spine(\n    \"day\",\n    \"to_date('01/01/2016', 'mm/dd/yyyy')\",\n    \"dateadd(week, 1, current_date)\"\n) #}\n\n\nwith rawdata as (\n\n    {{dbt_utils.generate_series(\n        dbt_utils.get_intervals_between(start_date, end_date, datepart)\n    )}}\n\n),\n\nall_periods as (\n\n    select (\n        {{\n            dateadd(\n                datepart,\n                \"row_number() over (order by 1) - 1\",\n                start_date\n            )\n        }}\n    ) as date_{{datepart}}\n    from rawdata\n\n),\n\nfiltered as (\n\n    select *\n    from all_periods\n    where date_{{datepart}} <= {{ end_date }}\n\n)\n\nselect * from filtered\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.generate_series", "macro.dbt_utils.get_intervals_between", "macro.dbt_utils.dateadd"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2369356, "supported_languages": null}, "macro.dbt_utils.nullcheck": {"name": "nullcheck", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/nullcheck.sql", "original_file_path": "macros/sql/nullcheck.sql", "unique_id": "macro.dbt_utils.nullcheck", "macro_sql": "{% macro nullcheck(cols) %}\n    {{ return(adapter.dispatch('nullcheck', 'dbt_utils')(cols)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__nullcheck"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.237323, "supported_languages": null}, "macro.dbt_utils.default__nullcheck": {"name": "default__nullcheck", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/nullcheck.sql", "original_file_path": "macros/sql/nullcheck.sql", "unique_id": "macro.dbt_utils.default__nullcheck", "macro_sql": "{% macro default__nullcheck(cols) %}\n{%- for col in cols %}\n\n    {% if col.is_string() -%}\n\n    nullif({{col.name}},'') as {{col.name}}\n\n    {%- else -%}\n\n    {{col.name}}\n\n    {%- endif -%}\n\n{%- if not loop.last -%} , {%- endif -%}\n\n{%- endfor -%}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2378623, "supported_languages": null}, "macro.dbt_utils.get_relations_by_pattern": {"name": "get_relations_by_pattern", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_relations_by_pattern.sql", "original_file_path": "macros/sql/get_relations_by_pattern.sql", "unique_id": "macro.dbt_utils.get_relations_by_pattern", "macro_sql": "{% macro get_relations_by_pattern(schema_pattern, table_pattern, exclude='', database=target.database) %}\n    {{ return(adapter.dispatch('get_relations_by_pattern', 'dbt_utils')(schema_pattern, table_pattern, exclude, database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_relations_by_pattern"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2384703, "supported_languages": null}, "macro.dbt_utils.default__get_relations_by_pattern": {"name": "default__get_relations_by_pattern", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_relations_by_pattern.sql", "original_file_path": "macros/sql/get_relations_by_pattern.sql", "unique_id": "macro.dbt_utils.default__get_relations_by_pattern", "macro_sql": "{% macro default__get_relations_by_pattern(schema_pattern, table_pattern, exclude='', database=target.database) %}\n\n    {%- call statement('get_tables', fetch_result=True) %}\n\n      {{ dbt_utils.get_tables_by_pattern_sql(schema_pattern, table_pattern, exclude, database) }}\n\n    {%- endcall -%}\n\n    {%- set table_list = load_result('get_tables') -%}\n\n    {%- if table_list and table_list['table'] -%}\n        {%- set tbl_relations = [] -%}\n        {%- for row in table_list['table'] -%}\n            {%- set tbl_relation = api.Relation.create(\n                database=database,\n                schema=row.table_schema,\n                identifier=row.table_name,\n                type=row.table_type\n            ) -%}\n            {%- do tbl_relations.append(tbl_relation) -%}\n        {%- endfor -%}\n\n        {{ return(tbl_relations) }}\n    {%- else -%}\n        {{ return([]) }}\n    {%- endif -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt_utils.get_tables_by_pattern_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.239555, "supported_languages": null}, "macro.dbt_utils.get_table_types_sql": {"name": "get_table_types_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_table_types_sql.sql", "original_file_path": "macros/sql/get_table_types_sql.sql", "unique_id": "macro.dbt_utils.get_table_types_sql", "macro_sql": "{%- macro get_table_types_sql() -%}\n  {{ return(adapter.dispatch('get_table_types_sql', 'dbt_utils')()) }}\n{%- endmacro -%}\n\n", "depends_on": {"macros": ["macro.dbt_utils.postgres__get_table_types_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2399259, "supported_languages": null}, "macro.dbt_utils.default__get_table_types_sql": {"name": "default__get_table_types_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_table_types_sql.sql", "original_file_path": "macros/sql/get_table_types_sql.sql", "unique_id": "macro.dbt_utils.default__get_table_types_sql", "macro_sql": "{% macro default__get_table_types_sql() %}\n            case table_type\n                when 'BASE TABLE' then 'table'\n                when 'EXTERNAL TABLE' then 'external'\n                when 'MATERIALIZED VIEW' then 'materializedview'\n                else lower(table_type)\n            end as {{ adapter.quote('table_type') }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2401116, "supported_languages": null}, "macro.dbt_utils.postgres__get_table_types_sql": {"name": "postgres__get_table_types_sql", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_table_types_sql.sql", "original_file_path": "macros/sql/get_table_types_sql.sql", "unique_id": "macro.dbt_utils.postgres__get_table_types_sql", "macro_sql": "{% macro postgres__get_table_types_sql() %}\n            case table_type\n                when 'BASE TABLE' then 'table'\n                when 'FOREIGN' then 'external'\n                when 'MATERIALIZED VIEW' then 'materializedview'\n                else lower(table_type)\n            end as {{ adapter.quote('table_type') }}\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2402902, "supported_languages": null}, "macro.dbt_utils.width_bucket": {"name": "width_bucket", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/width_bucket.sql", "original_file_path": "macros/sql/width_bucket.sql", "unique_id": "macro.dbt_utils.width_bucket", "macro_sql": "{% macro width_bucket(expr, min_value, max_value, num_buckets) %}\n  {{ return(adapter.dispatch('width_bucket', 'dbt_utils') (expr, min_value, max_value, num_buckets)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__width_bucket"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2409413, "supported_languages": null}, "macro.dbt_utils.default__width_bucket": {"name": "default__width_bucket", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/width_bucket.sql", "original_file_path": "macros/sql/width_bucket.sql", "unique_id": "macro.dbt_utils.default__width_bucket", "macro_sql": "{% macro default__width_bucket(expr, min_value, max_value, num_buckets) -%}\n\n    {% set bin_size -%}\n    (( {{ max_value }} - {{ min_value }} ) / {{ num_buckets }} )\n    {%- endset %}\n    (\n        -- to break ties when the amount is eaxtly at the bucket egde\n        case\n            when\n                mod(\n                    {{ dbt.safe_cast(expr, type_numeric() ) }},\n                    {{ dbt.safe_cast(bin_size, type_numeric() ) }}\n                ) = 0\n            then 1\n            else 0\n        end\n    ) +\n      -- Anything over max_value goes the N+1 bucket\n    least(\n        ceil(\n            ({{ expr }} - {{ min_value }})/{{ bin_size }}\n        ),\n        {{ num_buckets }} + 1\n    )\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.safe_cast", "macro.dbt_utils.type_numeric"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2415352, "supported_languages": null}, "macro.dbt_utils.redshift__width_bucket": {"name": "redshift__width_bucket", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/width_bucket.sql", "original_file_path": "macros/sql/width_bucket.sql", "unique_id": "macro.dbt_utils.redshift__width_bucket", "macro_sql": "{% macro redshift__width_bucket(expr, min_value, max_value, num_buckets) -%}\n\n    {% set bin_size -%}\n    (( {{ max_value }} - {{ min_value }} ) / {{ num_buckets }} )\n    {%- endset %}\n    (\n        -- to break ties when the amount is exactly at the bucket edge\n        case\n            when\n                {{ dbt.safe_cast(expr, type_numeric() ) }} %\n                {{ dbt.safe_cast(bin_size, type_numeric() ) }}\n                 = 0\n            then 1\n            else 0\n        end\n    ) +\n      -- Anything over max_value goes the N+1 bucket\n    least(\n        ceil(\n            ({{ expr }} - {{ min_value }})/{{ bin_size }}\n        ),\n        {{ num_buckets }} + 1\n    )\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt.safe_cast", "macro.dbt_utils.type_numeric"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2421136, "supported_languages": null}, "macro.dbt_utils.snowflake__width_bucket": {"name": "snowflake__width_bucket", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/width_bucket.sql", "original_file_path": "macros/sql/width_bucket.sql", "unique_id": "macro.dbt_utils.snowflake__width_bucket", "macro_sql": "{% macro snowflake__width_bucket(expr, min_value, max_value, num_buckets) %}\n    width_bucket({{ expr }}, {{ min_value }}, {{ max_value }}, {{ num_buckets }} )\n{% endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2432413, "supported_languages": null}, "macro.dbt_utils.deduplicate": {"name": "deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.deduplicate", "macro_sql": "{%- macro deduplicate(relation, partition_by, order_by=none, relation_alias=none) -%}\n\n    {%- set error_message_group_by -%}\nWarning: the `group_by` parameter of the `deduplicate` macro is no longer supported and will be deprecated in a future release of dbt-utils.\nUse `partition_by` instead.\nThe {{ model.package_name }}.{{ model.name }} model triggered this warning.\n    {%- endset -%}\n\n    {% if kwargs.get('group_by') %}\n    {%- do exceptions.warn(error_message_group_by) -%}\n    {%- endif -%}\n\n    {%- set error_message_order_by -%}\nWarning: `order_by` as an optional parameter of the `deduplicate` macro is no longer supported and will be deprecated in a future release of dbt-utils.\nSupply a non-null value for `order_by` instead.\nThe {{ model.package_name }}.{{ model.name }} model triggered this warning.\n    {%- endset -%}\n\n    {% if not order_by %}\n    {%- do exceptions.warn(error_message_order_by) -%}\n    {%- endif -%}\n\n    {%- set error_message_alias -%}\nWarning: the `relation_alias` parameter of the `deduplicate` macro is no longer supported and will be deprecated in a future release of dbt-utils.\nIf you were using `relation_alias` to point to a CTE previously then you can now pass the alias directly to `relation` instead.\nThe {{ model.package_name }}.{{ model.name }} model triggered this warning.\n    {%- endset -%}\n\n    {% if relation_alias %}\n    {%- do exceptions.warn(error_message_alias) -%}\n    {%- endif -%}\n\n    {% set partition_by = partition_by or kwargs.get('group_by') %}\n    {% set relation = relation_alias or relation %}\n    {% set order_by = order_by or \"'1'\" %}\n\n    {{ return(adapter.dispatch('deduplicate', 'dbt_utils')(relation, partition_by, order_by)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.postgres__deduplicate"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.245239, "supported_languages": null}, "macro.dbt_utils.default__deduplicate": {"name": "default__deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.default__deduplicate", "macro_sql": "\n\n{%- macro default__deduplicate(relation, partition_by, order_by) -%}\n\n    with row_numbered as (\n        select\n            _inner.*,\n            row_number() over (\n                partition by {{ partition_by }}\n                order by {{ order_by }}\n            ) as rn\n        from {{ relation }} as _inner\n    )\n\n    select\n        distinct data.*\n    from {{ relation }} as data\n    {#\n    -- Not all DBs will support natural joins but the ones that do include:\n    -- Oracle, MySQL, SQLite, Redshift, Teradata, Materialize, Databricks\n    -- Apache Spark, SingleStore, Vertica\n    -- Those that do not appear to support natural joins include:\n    -- SQLServer, Trino, Presto, Rockset, Athena\n    #}\n    natural join row_numbered\n    where row_numbered.rn = 1\n\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2455943, "supported_languages": null}, "macro.dbt_utils.redshift__deduplicate": {"name": "redshift__deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.redshift__deduplicate", "macro_sql": "{% macro redshift__deduplicate(relation, partition_by, order_by) -%}\n\n    {{ return(dbt_utils.default__deduplicate(relation, partition_by, order_by=order_by)) }}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__deduplicate"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2458632, "supported_languages": null}, "macro.dbt_utils.postgres__deduplicate": {"name": "postgres__deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.postgres__deduplicate", "macro_sql": "\n{%- macro postgres__deduplicate(relation, partition_by, order_by) -%}\n\n    select\n        distinct on ({{ partition_by }}) *\n    from {{ relation }}\n    order by {{ partition_by }}{{ ',' ~ order_by }}\n\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2461185, "supported_languages": null}, "macro.dbt_utils.snowflake__deduplicate": {"name": "snowflake__deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.snowflake__deduplicate", "macro_sql": "\n{%- macro snowflake__deduplicate(relation, partition_by, order_by) -%}\n\n    select *\n    from {{ relation }}\n    qualify\n        row_number() over (\n            partition by {{ partition_by }}\n            order by {{ order_by }}\n        ) = 1\n\n{%- endmacro -%}\n\n", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2463508, "supported_languages": null}, "macro.dbt_utils.bigquery__deduplicate": {"name": "bigquery__deduplicate", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/deduplicate.sql", "original_file_path": "macros/sql/deduplicate.sql", "unique_id": "macro.dbt_utils.bigquery__deduplicate", "macro_sql": "\n{%- macro bigquery__deduplicate(relation, partition_by, order_by) -%}\n\n    select unique.*\n    from (\n        select\n            array_agg (\n                original\n                order by {{ order_by }}\n                limit 1\n            )[offset(0)] unique\n        from {{ relation }} original\n        group by {{ partition_by }}\n    )\n\n{%- endmacro -%}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.246582, "supported_languages": null}, "macro.dbt_utils.unpivot": {"name": "unpivot", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/unpivot.sql", "original_file_path": "macros/sql/unpivot.sql", "unique_id": "macro.dbt_utils.unpivot", "macro_sql": "{% macro unpivot(relation=none, cast_to='varchar', exclude=none, remove=none, field_name='field_name', value_name='value', table=none) -%}\n    {{ return(adapter.dispatch('unpivot', 'dbt_utils')(relation, cast_to, exclude, remove, field_name, value_name, table)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__unpivot"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.247621, "supported_languages": null}, "macro.dbt_utils.default__unpivot": {"name": "default__unpivot", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/unpivot.sql", "original_file_path": "macros/sql/unpivot.sql", "unique_id": "macro.dbt_utils.default__unpivot", "macro_sql": "{% macro default__unpivot(relation=none, cast_to='varchar', exclude=none, remove=none, field_name='field_name', value_name='value', table=none) -%}\n\n    {% if table %}\n        {%- set error_message = '\n            Warning: the `unpivot` macro no longer accepts a `table` parameter. \\\n            This parameter will be deprecated in a future release of dbt-utils. Use the `relation` parameter instead. \\\n            The {}.{} model triggered this warning. \\\n            '.format(model.package_name, model.name) -%}\n        {%- do exceptions.warn(error_message) -%}\n    {% endif %}\n\n    {% if relation and table %}\n        {{ exceptions.raise_compiler_error(\"Error: both the `relation` and `table` parameters were provided to `unpivot` macro. Choose one only (we recommend `relation`).\") }}\n    {% elif not relation and table %}\n        {% set relation=table %}\n    {% elif not relation and not table %}\n        {{ exceptions.raise_compiler_error(\"Error: argument `relation` is required for `unpivot` macro.\") }}\n    {% endif %}\n\n  {%- set exclude = exclude if exclude is not none else [] %}\n  {%- set remove = remove if remove is not none else [] %}\n\n  {%- set include_cols = [] %}\n\n  {%- set table_columns = {} %}\n\n  {%- do table_columns.update({relation: []}) %}\n\n  {%- do dbt_utils._is_relation(relation, 'unpivot') -%}\n  {%- do dbt_utils._is_ephemeral(relation, 'unpivot') -%}\n  {%- set cols = adapter.get_columns_in_relation(relation) %}\n\n  {%- for col in cols -%}\n    {%- if col.column.lower() not in remove|map('lower') and col.column.lower() not in exclude|map('lower') -%}\n      {% do include_cols.append(col) %}\n    {%- endif %}\n  {%- endfor %}\n\n\n  {%- for col in include_cols -%}\n    select\n      {%- for exclude_col in exclude %}\n        {{ exclude_col }},\n      {%- endfor %}\n\n      cast('{{ col.column }}' as {{ type_string() }}) as {{ field_name }},\n      cast(  {% if col.data_type == 'boolean' %}\n           {{ cast_bool_to_text(col.column) }}\n             {% else %}\n           {{ col.column }}\n             {% endif %}\n           as {{ cast_to }}) as {{ value_name }}\n\n    from {{ relation }}\n\n    {% if not loop.last -%}\n      union all\n    {% endif -%}\n  {%- endfor -%}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral", "macro.dbt_utils.type_string", "macro.dbt_utils.cast_bool_to_text"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2502723, "supported_languages": null}, "macro.dbt_utils.get_relations_by_prefix": {"name": "get_relations_by_prefix", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_relations_by_prefix.sql", "original_file_path": "macros/sql/get_relations_by_prefix.sql", "unique_id": "macro.dbt_utils.get_relations_by_prefix", "macro_sql": "{% macro get_relations_by_prefix(schema, prefix, exclude='', database=target.database) %}\n    {{ return(adapter.dispatch('get_relations_by_prefix', 'dbt_utils')(schema, prefix, exclude, database)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_relations_by_prefix"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2509227, "supported_languages": null}, "macro.dbt_utils.default__get_relations_by_prefix": {"name": "default__get_relations_by_prefix", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_relations_by_prefix.sql", "original_file_path": "macros/sql/get_relations_by_prefix.sql", "unique_id": "macro.dbt_utils.default__get_relations_by_prefix", "macro_sql": "{% macro default__get_relations_by_prefix(schema, prefix, exclude='', database=target.database) %}\n\n    {%- call statement('get_tables', fetch_result=True) %}\n\n      {{ dbt_utils.get_tables_by_prefix_sql(schema, prefix, exclude, database) }}\n\n    {%- endcall -%}\n\n    {%- set table_list = load_result('get_tables') -%}\n\n    {%- if table_list and table_list['table'] -%}\n        {%- set tbl_relations = [] -%}\n        {%- for row in table_list['table'] -%}\n            {%- set tbl_relation = api.Relation.create(\n                database=database,\n                schema=row.table_schema,\n                identifier=row.table_name,\n                type=row.table_type\n            ) -%}\n            {%- do tbl_relations.append(tbl_relation) -%}\n        {%- endfor -%}\n\n        {{ return(tbl_relations) }}\n    {%- else -%}\n        {{ return([]) }}\n    {%- endif -%}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt.statement", "macro.dbt_utils.get_tables_by_prefix_sql"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2520216, "supported_languages": null}, "macro.dbt_utils.nullcheck_table": {"name": "nullcheck_table", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/nullcheck_table.sql", "original_file_path": "macros/sql/nullcheck_table.sql", "unique_id": "macro.dbt_utils.nullcheck_table", "macro_sql": "{% macro nullcheck_table(relation) %}\n    {{ return(adapter.dispatch('nullcheck_table', 'dbt_utils')(relation)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__nullcheck_table"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2524066, "supported_languages": null}, "macro.dbt_utils.default__nullcheck_table": {"name": "default__nullcheck_table", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/nullcheck_table.sql", "original_file_path": "macros/sql/nullcheck_table.sql", "unique_id": "macro.dbt_utils.default__nullcheck_table", "macro_sql": "{% macro default__nullcheck_table(relation) %}\n\n  {%- do dbt_utils._is_relation(relation, 'nullcheck_table') -%}\n  {%- do dbt_utils._is_ephemeral(relation, 'nullcheck_table') -%}\n  {% set cols = adapter.get_columns_in_relation(relation) %}\n\n  select {{ dbt_utils.nullcheck(cols) }}\n  from {{relation}}\n\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral", "macro.dbt_utils.nullcheck"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2528434, "supported_languages": null}, "macro.dbt_utils.pivot": {"name": "pivot", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/pivot.sql", "original_file_path": "macros/sql/pivot.sql", "unique_id": "macro.dbt_utils.pivot", "macro_sql": "{% macro pivot(column,\n               values,\n               alias=True,\n               agg='sum',\n               cmp='=',\n               prefix='',\n               suffix='',\n               then_value=1,\n               else_value=0,\n               quote_identifiers=True,\n               distinct=False) %}\n    {{ return(adapter.dispatch('pivot', 'dbt_utils')(column, values, alias, agg, cmp, prefix, suffix, then_value, else_value, quote_identifiers, distinct)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__pivot"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2538793, "supported_languages": null}, "macro.dbt_utils.default__pivot": {"name": "default__pivot", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/pivot.sql", "original_file_path": "macros/sql/pivot.sql", "unique_id": "macro.dbt_utils.default__pivot", "macro_sql": "{% macro default__pivot(column,\n               values,\n               alias=True,\n               agg='sum',\n               cmp='=',\n               prefix='',\n               suffix='',\n               then_value=1,\n               else_value=0,\n               quote_identifiers=True,\n               distinct=False) %}\n  {% for value in values %}\n    {{ agg }}(\n      {% if distinct %} distinct {% endif %}\n      case\n      when {{ column }} {{ cmp }} '{{ dbt_utils.escape_single_quotes(value) }}'\n        then {{ then_value }}\n      else {{ else_value }}\n      end\n    )\n    {% if alias %}\n      {% if quote_identifiers %}\n            as {{ adapter.quote(prefix ~ value ~ suffix) }}\n      {% else %}\n        as {{ dbt_utils.slugify(prefix ~ value ~ suffix) }}\n      {% endif %}\n    {% endif %}\n    {% if not loop.last %},{% endif %}\n  {% endfor %}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.escape_single_quotes", "macro.dbt_utils.slugify"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2549717, "supported_languages": null}, "macro.dbt_utils.get_filtered_columns_in_relation": {"name": "get_filtered_columns_in_relation", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_filtered_columns_in_relation.sql", "original_file_path": "macros/sql/get_filtered_columns_in_relation.sql", "unique_id": "macro.dbt_utils.get_filtered_columns_in_relation", "macro_sql": "{% macro get_filtered_columns_in_relation(from, except=[]) -%}\n    {{ return(adapter.dispatch('get_filtered_columns_in_relation', 'dbt_utils')(from, except)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_filtered_columns_in_relation"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2554824, "supported_languages": null}, "macro.dbt_utils.default__get_filtered_columns_in_relation": {"name": "default__get_filtered_columns_in_relation", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_filtered_columns_in_relation.sql", "original_file_path": "macros/sql/get_filtered_columns_in_relation.sql", "unique_id": "macro.dbt_utils.default__get_filtered_columns_in_relation", "macro_sql": "{% macro default__get_filtered_columns_in_relation(from, except=[]) -%}\n    {%- do dbt_utils._is_relation(from, 'get_filtered_columns_in_relation') -%}\n    {%- do dbt_utils._is_ephemeral(from, 'get_filtered_columns_in_relation') -%}\n\n    {# -- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. #}\n    {%- if not execute -%}\n        {{ return('') }}\n    {% endif %}\n\n    {%- set include_cols = [] %}\n    {%- set cols = adapter.get_columns_in_relation(from) -%}\n    {%- set except = except | map(\"lower\") | list %}\n    {%- for col in cols -%}\n        {%- if col.column|lower not in except -%}\n            {% do include_cols.append(col.column) %}\n        {%- endif %}\n    {%- endfor %}\n\n    {{ return(include_cols) }}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_relation", "macro.dbt_utils._is_ephemeral"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2564344, "supported_languages": null}, "macro.dbt_utils.surrogate_key": {"name": "surrogate_key", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/surrogate_key.sql", "original_file_path": "macros/sql/surrogate_key.sql", "unique_id": "macro.dbt_utils.surrogate_key", "macro_sql": "{%- macro surrogate_key(field_list) -%}\n    {# needed for safe_add to allow for non-keyword arguments see SO post #}\n    {# https://stackoverflow.com/questions/13944751/args-kwargs-in-jinja2-macros #}\n    {% set frustrating_jinja_feature = varargs %}\n    {{ return(adapter.dispatch('surrogate_key', 'dbt_utils')(field_list, *varargs)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__surrogate_key"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2570777, "supported_languages": null}, "macro.dbt_utils.default__surrogate_key": {"name": "default__surrogate_key", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/surrogate_key.sql", "original_file_path": "macros/sql/surrogate_key.sql", "unique_id": "macro.dbt_utils.default__surrogate_key", "macro_sql": "\n\n{%- macro default__surrogate_key(field_list) -%}\n\n{%- if varargs|length >= 1 or field_list is string %}\n\n{%- set error_message = '\nWarning: the `surrogate_key` macro now takes a single list argument instead of \\\nmultiple string arguments. Support for multiple string arguments will be \\\ndeprecated in a future release of dbt-utils. The {}.{} model triggered this warning. \\\n'.format(model.package_name, model.name) -%}\n\n{%- do exceptions.warn(error_message) -%}\n\n{# first argument is not included in varargs, so add first element to field_list_xf #}\n{%- set field_list_xf = [field_list] -%}\n\n{%- for field in varargs %}\n{%- set _ = field_list_xf.append(field) -%}\n{%- endfor -%}\n\n{%- else -%}\n\n{# if using list, just set field_list_xf as field_list #}\n{%- set field_list_xf = field_list -%}\n\n{%- endif -%}\n\n\n{%- set fields = [] -%}\n\n{%- for field in field_list_xf -%}\n\n    {%- set _ = fields.append(\n        \"coalesce(cast(\" ~ field ~ \" as \" ~ type_string() ~ \"), '')\"\n    ) -%}\n\n    {%- if not loop.last %}\n        {%- set _ = fields.append(\"'-'\") -%}\n    {%- endif -%}\n\n{%- endfor -%}\n\n{{ hash(concat(fields)) }}\n\n{%- endmacro -%}", "depends_on": {"macros": ["macro.dbt_utils.type_string", "macro.dbt_utils.hash", "macro.dbt_utils.concat"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2582645, "supported_languages": null}, "macro.dbt_utils.degrees_to_radians": {"name": "degrees_to_radians", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/haversine_distance.sql", "original_file_path": "macros/sql/haversine_distance.sql", "unique_id": "macro.dbt_utils.degrees_to_radians", "macro_sql": "{% macro degrees_to_radians(degrees) -%}\n    acos(-1) * {{degrees}} / 180\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2588246, "supported_languages": null}, "macro.dbt_utils.haversine_distance": {"name": "haversine_distance", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/haversine_distance.sql", "original_file_path": "macros/sql/haversine_distance.sql", "unique_id": "macro.dbt_utils.haversine_distance", "macro_sql": "{% macro haversine_distance(lat1, lon1, lat2, lon2, unit='mi') -%}\n    {{ return(adapter.dispatch('haversine_distance', 'dbt_utils')(lat1,lon1,lat2,lon2,unit)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__haversine_distance"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2591803, "supported_languages": null}, "macro.dbt_utils.default__haversine_distance": {"name": "default__haversine_distance", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/haversine_distance.sql", "original_file_path": "macros/sql/haversine_distance.sql", "unique_id": "macro.dbt_utils.default__haversine_distance", "macro_sql": "{% macro default__haversine_distance(lat1, lon1, lat2, lon2, unit='mi') -%}\n{%- if unit == 'mi' %}\n    {% set conversion_rate = 1 %}\n{% elif unit == 'km' %}\n    {% set conversion_rate = 1.60934 %}\n{% else %}\n    {{ exceptions.raise_compiler_error(\"unit input must be one of 'mi' or 'km'. Got \" ~ unit) }}\n{% endif %}\n\n    2 * 3961 * asin(sqrt(power((sin(radians(({{ lat2 }} - {{ lat1 }}) / 2))), 2) +\n    cos(radians({{lat1}})) * cos(radians({{lat2}})) *\n    power((sin(radians(({{ lon2 }} - {{ lon1 }}) / 2))), 2))) * {{ conversion_rate }}\n\n{%- endmacro %}", "depends_on": {"macros": []}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2598944, "supported_languages": null}, "macro.dbt_utils.bigquery__haversine_distance": {"name": "bigquery__haversine_distance", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/haversine_distance.sql", "original_file_path": "macros/sql/haversine_distance.sql", "unique_id": "macro.dbt_utils.bigquery__haversine_distance", "macro_sql": "{% macro bigquery__haversine_distance(lat1, lon1, lat2, lon2, unit='mi') -%}\n{% set radians_lat1 = dbt_utils.degrees_to_radians(lat1) %}\n{% set radians_lat2 = dbt_utils.degrees_to_radians(lat2) %}\n{% set radians_lon1 = dbt_utils.degrees_to_radians(lon1) %}\n{% set radians_lon2 = dbt_utils.degrees_to_radians(lon2) %}\n{%- if unit == 'mi' %}\n    {% set conversion_rate = 1 %}\n{% elif unit == 'km' %}\n    {% set conversion_rate = 1.60934 %}\n{% else %}\n    {{ exceptions.raise_compiler_error(\"unit input must be one of 'mi' or 'km'. Got \" ~ unit) }}\n{% endif %}\n    2 * 3961 * asin(sqrt(power(sin(({{ radians_lat2 }} - {{ radians_lat1 }}) / 2), 2) +\n    cos({{ radians_lat1 }}) * cos({{ radians_lat2 }}) *\n    power(sin(({{ radians_lon2 }} - {{ radians_lon1 }}) / 2), 2))) * {{ conversion_rate }}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.degrees_to_radians"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2609942, "supported_languages": null}, "macro.dbt_utils.get_column_values": {"name": "get_column_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_column_values.sql", "original_file_path": "macros/sql/get_column_values.sql", "unique_id": "macro.dbt_utils.get_column_values", "macro_sql": "{% macro get_column_values(table, column, order_by='count(*) desc', max_records=none, default=none, where=none) -%}\n    {{ return(adapter.dispatch('get_column_values', 'dbt_utils')(table, column, order_by, max_records, default, where)) }}\n{% endmacro %}", "depends_on": {"macros": ["macro.dbt_utils.default__get_column_values"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.261908, "supported_languages": null}, "macro.dbt_utils.default__get_column_values": {"name": "default__get_column_values", "resource_type": "macro", "package_name": "dbt_utils", "path": "macros/sql/get_column_values.sql", "original_file_path": "macros/sql/get_column_values.sql", "unique_id": "macro.dbt_utils.default__get_column_values", "macro_sql": "{% macro default__get_column_values(table, column, order_by='count(*) desc', max_records=none, default=none, where=none) -%}\n    {#-- Prevent querying of db in parsing mode. This works because this macro does not create any new refs. #}\n    {%- if not execute -%}\n        {% set default = [] if not default %}\n        {{ return(default) }}\n    {% endif %}\n\n    {%- do dbt_utils._is_ephemeral(table, 'get_column_values') -%}\n\n    {# Not all relations are tables. Renaming for internal clarity without breaking functionality for anyone using named arguments #}\n    {# TODO: Change the method signature in a future 0.x.0 release #}\n    {%- set target_relation = table -%}\n\n    {# adapter.load_relation is a convenience wrapper to avoid building a Relation when we already have one #}\n    {% set relation_exists = (load_relation(target_relation)) is not none %}\n\n    {%- call statement('get_column_values', fetch_result=true) %}\n\n        {%- if not relation_exists and default is none -%}\n\n          {{ exceptions.raise_compiler_error(\"In get_column_values(): relation \" ~ target_relation ~ \" does not exist and no default value was provided.\") }}\n\n        {%- elif not relation_exists and default is not none -%}\n\n          {{ log(\"Relation \" ~ target_relation ~ \" does not exist. Returning the default value: \" ~ default) }}\n\n          {{ return(default) }}\n\n        {%- else -%}\n\n\n            select\n                {{ column }} as value\n\n            from {{ target_relation }}\n\n            {% if where is not none %}\n            where {{ where }}\n            {% endif %}\n\n            group by {{ column }}\n            order by {{ order_by }}\n\n            {% if max_records is not none %}\n            limit {{ max_records }}\n            {% endif %}\n\n        {% endif %}\n\n    {%- endcall -%}\n\n    {%- set value_list = load_result('get_column_values') -%}\n\n    {%- if value_list and value_list['data'] -%}\n        {%- set values = value_list['data'] | map(attribute=0) | list %}\n        {{ return(values) }}\n    {%- else -%}\n        {{ return(default) }}\n    {%- endif -%}\n\n{%- endmacro %}", "depends_on": {"macros": ["macro.dbt_utils._is_ephemeral", "macro.dbt.load_relation", "macro.dbt.statement"]}, "description": "", "meta": {}, "docs": {"show": true, "node_color": null}, "patch_path": null, "arguments": [], "created_at": 1742132014.2638555, "supported_languages": null}}, "docs": {"doc.dbt.__overview__": {"name": "__overview__", "resource_type": "doc", "package_name": "dbt", "path": "overview.md", "original_file_path": "docs/overview.md", "unique_id": "doc.dbt.__overview__", "block_contents": "### Welcome!\n\nWelcome to the auto-generated documentation for your dbt project!\n\n### Navigation\n\nYou can use the `Project` and `Database` navigation tabs on the left side of the window to explore the models\nin your project.\n\n#### Project Tab\nThe `Project` tab mirrors the directory structure of your dbt project. In this tab, you can see all of the\nmodels defined in your dbt project, as well as models imported from dbt packages.\n\n#### Database Tab\nThe `Database` tab also exposes your models, but in a format that looks more like a database explorer. This view\nshows relations (tables and views) grouped into database schemas. Note that ephemeral models are _not_ shown\nin this interface, as they do not exist in the database.\n\n### Graph Exploration\nYou can click the blue icon on the bottom-right corner of the page to view the lineage graph of your models.\n\nOn model pages, you'll see the immediate parents and children of the model you're exploring. By clicking the `Expand`\nbutton at the top-right of this lineage pane, you'll be able to see all of the models that are used to build,\nor are built from, the model you're exploring.\n\nOnce expanded, you'll be able to use the `--select` and `--exclude` model selection syntax to filter the\nmodels in the graph. For more information on model selection, check out the [dbt docs](https://docs.getdbt.com/docs/model-selection-syntax).\n\nNote that you can also right-click on models to interactively filter and explore the graph.\n\n---\n\n### More information\n\n- [What is dbt](https://docs.getdbt.com/docs/introduction)?\n- Read the [dbt viewpoint](https://docs.getdbt.com/docs/viewpoint)\n- [Installation](https://docs.getdbt.com/docs/installation)\n- Join the [dbt Community](https://www.getdbt.com/community/) for questions and discussion"}}, "exposures": {}, "metrics": {}, "groups": {}, "selectors": {}, "disabled": {"test.nerd_facts_dbt.relationships_stg_swapi_max_speed__speed__ref_valid_speed_ranges_.f14be6e201": [{"database": "nerd_facts", "schema": "public_dbt_test__audit", "name": "relationships_stg_swapi_max_speed__speed__ref_valid_speed_ranges_", "resource_type": "test", "package_name": "nerd_facts_dbt", "path": "relationships_stg_swapi_c1a80fd7c20c8db0e492b1b70a97e0b6.sql", "original_file_path": "models/staging/swapi/stg_swapi.yml", "unique_id": "test.nerd_facts_dbt.relationships_stg_swapi_max_speed__speed__ref_valid_speed_ranges_.f14be6e201", "fqn": ["nerd_facts_dbt", "staging", "swapi", "relationships_stg_swapi_max_speed__speed__ref_valid_speed_ranges_"], "alias": "relationships_stg_swapi_c1a80fd7c20c8db0e492b1b70a97e0b6", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": false, "alias": "relationships_stg_swapi_c1a80fd7c20c8db0e492b1b70a97e0b6", "schema": "dbt_test__audit", "database": null, "tags": [], "meta": {}, "group": null, "materialized": "test", "severity": "warn", "store_failures": null, "store_failures_as": null, "where": null, "limit": null, "fail_calc": "count(*)", "warn_if": "!= 0", "error_if": "!= 0"}, "tags": [], "description": "", "columns": {}, "meta": {}, "group": null, "docs": {"show": true, "node_color": null}, "patch_path": null, "build_path": null, "unrendered_config": {"severity": "warn", "alias": "relationships_stg_swapi_c1a80fd7c20c8db0e492b1b70a97e0b6"}, "created_at": 1742132014.9946146, "relation_name": null, "raw_code": "{{ test_relationships(**_dbt_generic_test_kwargs) }}{{ config(severity=\"warn\",alias=\"relationships_stg_swapi_c1a80fd7c20c8db0e492b1b70a97e0b6\") }}", "language": "sql", "refs": [{"name": "valid_speed_ranges", "package": null, "version": null}, {"name": "stg_swapi", "package": null, "version": null}], "sources": [], "metrics": [], "depends_on": {"macros": ["macro.dbt.test_relationships", "macro.dbt.get_where_subquery"], "nodes": ["model.nerd_facts_dbt.stg_swapi"]}, "compiled_path": null, "contract": {"enforced": false, "alias_types": true, "checksum": null}, "column_name": "max_speed", "file_key_name": "models.stg_swapi", "attached_node": "model.nerd_facts_dbt.stg_swapi", "test_metadata": {"name": "relationships", "kwargs": {"to": "ref('valid_speed_ranges')", "field": "speed", "column_name": "max_speed", "model": "{{ get_where_subquery(ref('stg_swapi')) }}"}, "namespace": null}}]}, "parent_map": {"model.nerd_facts_dbt.dim_pokemon_moves": ["model.nerd_facts_dbt.stg_pokeapi_moves"], "model.nerd_facts_dbt.stg_pokeapi_abilities": [], "model.nerd_facts_dbt.stg_netrunner_packs": [], "model.nerd_facts_dbt.bridge_pokemon_abilities": ["model.nerd_facts_dbt.dim_pokemon_abilities", "model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.fct_netrunner_card_power": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"], "model.nerd_facts_dbt.dim_pokemon_abilities": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.stg_pokeapi_moves": ["source.nerd_facts_dbt.pokeapi.moves"], "model.nerd_facts_dbt.bridge_pokemon_moves": ["model.nerd_facts_dbt.dim_pokemon_moves", "model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.dim_netrunner_cards": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"], "model.nerd_facts_dbt.fct_pokemon_matchups": ["model.nerd_facts_dbt.dim_pokemon_types", "model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.stg_pokeapi_items": [], "model.nerd_facts_dbt.stg_netrunner_cards": [], "model.nerd_facts_dbt.dim_netrunner_factions": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_factions", "model.nerd_facts_dbt.stg_netrunner_packs"], "model.nerd_facts_dbt.fact_netrunner_cards": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs"], "model.nerd_facts_dbt.dim_pokemon_types": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.fct_pokemon": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.fct_starships": ["model.nerd_facts_dbt.stg_swapi_starships"], "model.nerd_facts_dbt.stg_pokeapi_pokemon": [], "model.nerd_facts_dbt.fct_pokemon_stats": ["model.nerd_facts_dbt.stg_pokeapi_pokemon"], "model.nerd_facts_dbt.stg_netrunner_factions": [], "model.nerd_facts_dbt.stg_pokeapi_types": [], "test.nerd_facts_dbt.source_unique_pokeapi_moves_id.d93d417c11": ["source.nerd_facts_dbt.pokeapi.moves"], "test.nerd_facts_dbt.source_not_null_pokeapi_moves_id.c4a229cda9": ["source.nerd_facts_dbt.pokeapi.moves"], "test.nerd_facts_dbt.source_not_null_pokeapi_moves_name.5721c278f3": ["source.nerd_facts_dbt.pokeapi.moves"], "model.nerd_facts_dbt.stg_swapi_starships": [], "test.nerd_facts_dbt.unique_stg_swapi_starships_id.faa87ea4e7": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.not_null_stg_swapi_starships_id.7ec0941917": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.not_null_stg_swapi_starships_name.0962a611d5": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing.2fef0b1acf": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.not_null_stg_swapi_starships_max_atmosphering_speed.9fc07f34cf": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL.ec823ef959": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0.8f9d0183b8": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL.1915ec346c": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5.de460c4fa4": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL.c35df747e6": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL.176b315457": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL.8339feb5a2": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL.4849ab31ba": ["model.nerd_facts_dbt.stg_swapi_starships"], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_.2b12d505ec": ["model.nerd_facts_dbt.stg_swapi_starships"], "model.nerd_facts_dbt.bridge_sw_characters_films": ["model.nerd_facts_dbt.stg_swapi_films", "model.nerd_facts_dbt.stg_swapi_people"], "model.nerd_facts_dbt.dim_sw_films": ["model.nerd_facts_dbt.stg_swapi_films"], "model.nerd_facts_dbt.bridge_sw_starships_pilots": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_swapi_species", "model.nerd_facts_dbt.stg_swapi_starships"], "model.nerd_facts_dbt.dim_characters": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.stg_swapi_people"], "model.nerd_facts_dbt.fct_power_ratings": ["model.nerd_facts_dbt.stg_netrunner_cards", "model.nerd_facts_dbt.stg_netrunner_packs", "model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.stg_swapi_people"], "model.nerd_facts_dbt.fct_sw_characters": ["model.nerd_facts_dbt.stg_swapi_people", "model.nerd_facts_dbt.stg_swapi_planets", "model.nerd_facts_dbt.stg_swapi_species"], "model.nerd_facts_dbt.stg_swapi_people": ["source.nerd_facts_dbt.swapi.people"], "model.nerd_facts_dbt.dim_locations": ["model.nerd_facts_dbt.stg_pokeapi_pokemon", "model.nerd_facts_dbt.stg_swapi_planets"], "model.nerd_facts_dbt.dim_sw_planets": ["model.nerd_facts_dbt.stg_swapi_planets"], "model.nerd_facts_dbt.stg_swapi_species": ["source.nerd_facts_dbt.swapi.species"], "model.nerd_facts_dbt.dim_sw_vehicles": ["model.nerd_facts_dbt.stg_swapi_vehicles"], "model.nerd_facts_dbt.stg_swapi_vehicles": ["source.nerd_facts_dbt.swapi.vehicles"], "test.nerd_facts_dbt.unique_stg_swapi_people_id.61c011a764": ["model.nerd_facts_dbt.stg_swapi_people"], "test.nerd_facts_dbt.not_null_stg_swapi_people_id.7a1b515eed": ["model.nerd_facts_dbt.stg_swapi_people"], "test.nerd_facts_dbt.not_null_stg_swapi_people_name.f39acc5c3f": ["model.nerd_facts_dbt.stg_swapi_people"], "test.nerd_facts_dbt.unique_stg_swapi_species_id.d223d89b92": ["model.nerd_facts_dbt.stg_swapi_species"], "test.nerd_facts_dbt.not_null_stg_swapi_species_id.09ea9d15a8": ["model.nerd_facts_dbt.stg_swapi_species"], "test.nerd_facts_dbt.not_null_stg_swapi_species_name.72dd894221": ["model.nerd_facts_dbt.stg_swapi_species"], "test.nerd_facts_dbt.unique_stg_swapi_vehicles_id.8b524818ea": ["model.nerd_facts_dbt.stg_swapi_vehicles"], "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_id.fb013dcb6d": ["model.nerd_facts_dbt.stg_swapi_vehicles"], "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_name.f1ef2875b7": ["model.nerd_facts_dbt.stg_swapi_vehicles"], "test.nerd_facts_dbt.source_unique_swapi_starships_id.4a35a82bda": ["source.nerd_facts_dbt.swapi.starships"], "test.nerd_facts_dbt.source_not_null_swapi_starships_id.20f60e38ef": ["source.nerd_facts_dbt.swapi.starships"], "model.nerd_facts_dbt.stg_swapi_films": ["source.nerd_facts_dbt.swapi.films"], "test.nerd_facts_dbt.unique_stg_swapi_films_id.14c2b7f5e2": ["model.nerd_facts_dbt.stg_swapi_films"], "test.nerd_facts_dbt.not_null_stg_swapi_films_id.4e52f2f208": ["model.nerd_facts_dbt.stg_swapi_films"], "test.nerd_facts_dbt.not_null_stg_swapi_films_title.4f45458548": ["model.nerd_facts_dbt.stg_swapi_films"], "test.nerd_facts_dbt.not_null_stg_swapi_films_episode_id.bc98d1b696": ["model.nerd_facts_dbt.stg_swapi_films"], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.a5d4199e05": ["model.nerd_facts_dbt.stg_swapi_films"], "test.nerd_facts_dbt.not_null_stg_swapi_films_release_date.6599c8fb74": ["model.nerd_facts_dbt.stg_swapi_films"], "model.nerd_facts_dbt.stg_swapi_planets": ["source.nerd_facts_dbt.swapi.planets"], "test.nerd_facts_dbt.unique_stg_swapi_planets_id.6c040cab42": ["model.nerd_facts_dbt.stg_swapi_planets"], "test.nerd_facts_dbt.not_null_stg_swapi_planets_id.1980954ad2": ["model.nerd_facts_dbt.stg_swapi_planets"], "test.nerd_facts_dbt.not_null_stg_swapi_planets_name.290277cf78": ["model.nerd_facts_dbt.stg_swapi_planets"], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0.a9aca03c03": ["model.nerd_facts_dbt.stg_swapi_planets"], "source.nerd_facts_dbt.raw.swapi_people": [], "source.nerd_facts_dbt.raw.swapi_planets": [], "source.nerd_facts_dbt.raw.swapi_starships": [], "source.nerd_facts_dbt.raw.swapi_vehicles": [], "source.nerd_facts_dbt.raw.swapi_species": [], "source.nerd_facts_dbt.raw.swapi_films": [], "source.nerd_facts_dbt.raw.pokeapi_pokemon": [], "source.nerd_facts_dbt.raw.pokeapi_types": [], "source.nerd_facts_dbt.raw.pokeapi_abilities": [], "source.nerd_facts_dbt.raw.pokeapi_moves": [], "source.nerd_facts_dbt.raw.pokeapi_items": [], "source.nerd_facts_dbt.pokeapi.moves": [], "source.nerd_facts_dbt.swapi.starships": [], "source.nerd_facts_dbt.swapi.films": [], "source.nerd_facts_dbt.swapi.people": [], "source.nerd_facts_dbt.swapi.planets": [], "source.nerd_facts_dbt.swapi.species": [], "source.nerd_facts_dbt.swapi.vehicles": []}, "child_map": {"model.nerd_facts_dbt.dim_pokemon_moves": ["model.nerd_facts_dbt.bridge_pokemon_moves"], "model.nerd_facts_dbt.stg_pokeapi_abilities": [], "model.nerd_facts_dbt.stg_netrunner_packs": ["model.nerd_facts_dbt.dim_netrunner_cards", "model.nerd_facts_dbt.dim_netrunner_factions", "model.nerd_facts_dbt.fact_netrunner_cards", "model.nerd_facts_dbt.fct_netrunner_card_power", "model.nerd_facts_dbt.fct_power_ratings"], "model.nerd_facts_dbt.bridge_pokemon_abilities": [], "model.nerd_facts_dbt.fct_netrunner_card_power": [], "model.nerd_facts_dbt.dim_pokemon_abilities": ["model.nerd_facts_dbt.bridge_pokemon_abilities"], "model.nerd_facts_dbt.stg_pokeapi_moves": ["model.nerd_facts_dbt.dim_pokemon_moves"], "model.nerd_facts_dbt.bridge_pokemon_moves": [], "model.nerd_facts_dbt.dim_netrunner_cards": [], "model.nerd_facts_dbt.fct_pokemon_matchups": [], "model.nerd_facts_dbt.stg_pokeapi_items": [], "model.nerd_facts_dbt.stg_netrunner_cards": ["model.nerd_facts_dbt.dim_characters", "model.nerd_facts_dbt.dim_netrunner_cards", "model.nerd_facts_dbt.dim_netrunner_factions", "model.nerd_facts_dbt.fact_netrunner_cards", "model.nerd_facts_dbt.fct_netrunner_card_power", "model.nerd_facts_dbt.fct_power_ratings"], "model.nerd_facts_dbt.dim_netrunner_factions": [], "model.nerd_facts_dbt.fact_netrunner_cards": [], "model.nerd_facts_dbt.dim_pokemon_types": ["model.nerd_facts_dbt.fct_pokemon_matchups"], "model.nerd_facts_dbt.fct_pokemon": [], "model.nerd_facts_dbt.fct_starships": [], "model.nerd_facts_dbt.stg_pokeapi_pokemon": ["model.nerd_facts_dbt.bridge_pokemon_abilities", "model.nerd_facts_dbt.bridge_pokemon_moves", "model.nerd_facts_dbt.dim_characters", "model.nerd_facts_dbt.dim_locations", "model.nerd_facts_dbt.dim_pokemon_abilities", "model.nerd_facts_dbt.dim_pokemon_types", "model.nerd_facts_dbt.fct_pokemon", "model.nerd_facts_dbt.fct_pokemon_matchups", "model.nerd_facts_dbt.fct_pokemon_stats", "model.nerd_facts_dbt.fct_power_ratings"], "model.nerd_facts_dbt.fct_pokemon_stats": [], "model.nerd_facts_dbt.stg_netrunner_factions": ["model.nerd_facts_dbt.dim_netrunner_factions"], "model.nerd_facts_dbt.stg_pokeapi_types": [], "test.nerd_facts_dbt.source_unique_pokeapi_moves_id.d93d417c11": [], "test.nerd_facts_dbt.source_not_null_pokeapi_moves_id.c4a229cda9": [], "test.nerd_facts_dbt.source_not_null_pokeapi_moves_name.5721c278f3": [], "model.nerd_facts_dbt.stg_swapi_starships": ["model.nerd_facts_dbt.bridge_sw_starships_pilots", "model.nerd_facts_dbt.fct_starships", "test.nerd_facts_dbt.accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing.2fef0b1acf", "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5.de460c4fa4", "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0.8f9d0183b8", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL.4849ab31ba", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL.8339feb5a2", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL.c35df747e6", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_.2b12d505ec", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL.1915ec346c", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL.ec823ef959", "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL.176b315457", "test.nerd_facts_dbt.not_null_stg_swapi_starships_id.7ec0941917", "test.nerd_facts_dbt.not_null_stg_swapi_starships_max_atmosphering_speed.9fc07f34cf", "test.nerd_facts_dbt.not_null_stg_swapi_starships_name.0962a611d5", "test.nerd_facts_dbt.unique_stg_swapi_starships_id.faa87ea4e7"], "test.nerd_facts_dbt.unique_stg_swapi_starships_id.faa87ea4e7": [], "test.nerd_facts_dbt.not_null_stg_swapi_starships_id.7ec0941917": [], "test.nerd_facts_dbt.not_null_stg_swapi_starships_name.0962a611d5": [], "test.nerd_facts_dbt.accepted_values_stg_swapi_starships_manufacturer__Kuat_Drive_Yards__Corellian_Engineering_Corporation__Sienar_Fleet_Systems__Cygnus_Spaceworks__Incom_Corporation__Koensayr_Manufacturing.2fef0b1acf": [], "test.nerd_facts_dbt.not_null_stg_swapi_starships_max_atmosphering_speed.9fc07f34cf": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_max_atmosphering_speed___0_OR_IS_NULL.ec823ef959": [], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_max_atmosphering_speed__2000__0.8f9d0183b8": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_length___0_OR_IS_NULL.1915ec346c": [], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_starships_hyperdrive_rating__10__0_5.de460c4fa4": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew___1_OR_IS_NULL.c35df747e6": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_passengers___0_OR_IS_NULL.176b315457": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_cargo_capacity___0_OR_IS_NULL.8339feb5a2": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_MGLT___0_OR_IS_NULL.4849ab31ba": [], "test.nerd_facts_dbt.dbt_utils_expression_is_true_stg_swapi_starships_crew_numeric_passengers_numeric_50_OR_passengers_IS_NULL_OR_crew_IS_NULL_OR_crew_unknown_.2b12d505ec": [], "model.nerd_facts_dbt.bridge_sw_characters_films": [], "model.nerd_facts_dbt.dim_sw_films": [], "model.nerd_facts_dbt.bridge_sw_starships_pilots": [], "model.nerd_facts_dbt.dim_characters": [], "model.nerd_facts_dbt.fct_power_ratings": [], "model.nerd_facts_dbt.fct_sw_characters": [], "model.nerd_facts_dbt.stg_swapi_people": ["model.nerd_facts_dbt.bridge_sw_characters_films", "model.nerd_facts_dbt.bridge_sw_starships_pilots", "model.nerd_facts_dbt.dim_characters", "model.nerd_facts_dbt.fct_power_ratings", "model.nerd_facts_dbt.fct_sw_characters", "test.nerd_facts_dbt.not_null_stg_swapi_people_id.7a1b515eed", "test.nerd_facts_dbt.not_null_stg_swapi_people_name.f39acc5c3f", "test.nerd_facts_dbt.unique_stg_swapi_people_id.61c011a764"], "model.nerd_facts_dbt.dim_locations": [], "model.nerd_facts_dbt.dim_sw_planets": [], "model.nerd_facts_dbt.stg_swapi_species": ["model.nerd_facts_dbt.bridge_sw_starships_pilots", "model.nerd_facts_dbt.fct_sw_characters", "test.nerd_facts_dbt.not_null_stg_swapi_species_id.09ea9d15a8", "test.nerd_facts_dbt.not_null_stg_swapi_species_name.72dd894221", "test.nerd_facts_dbt.unique_stg_swapi_species_id.d223d89b92"], "model.nerd_facts_dbt.dim_sw_vehicles": [], "model.nerd_facts_dbt.stg_swapi_vehicles": ["model.nerd_facts_dbt.dim_sw_vehicles", "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_id.fb013dcb6d", "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_name.f1ef2875b7", "test.nerd_facts_dbt.unique_stg_swapi_vehicles_id.8b524818ea"], "test.nerd_facts_dbt.unique_stg_swapi_people_id.61c011a764": [], "test.nerd_facts_dbt.not_null_stg_swapi_people_id.7a1b515eed": [], "test.nerd_facts_dbt.not_null_stg_swapi_people_name.f39acc5c3f": [], "test.nerd_facts_dbt.unique_stg_swapi_species_id.d223d89b92": [], "test.nerd_facts_dbt.not_null_stg_swapi_species_id.09ea9d15a8": [], "test.nerd_facts_dbt.not_null_stg_swapi_species_name.72dd894221": [], "test.nerd_facts_dbt.unique_stg_swapi_vehicles_id.8b524818ea": [], "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_id.fb013dcb6d": [], "test.nerd_facts_dbt.not_null_stg_swapi_vehicles_name.f1ef2875b7": [], "test.nerd_facts_dbt.source_unique_swapi_starships_id.4a35a82bda": [], "test.nerd_facts_dbt.source_not_null_swapi_starships_id.20f60e38ef": [], "model.nerd_facts_dbt.stg_swapi_films": ["model.nerd_facts_dbt.bridge_sw_characters_films", "model.nerd_facts_dbt.dim_sw_films", "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.a5d4199e05", "test.nerd_facts_dbt.not_null_stg_swapi_films_episode_id.bc98d1b696", "test.nerd_facts_dbt.not_null_stg_swapi_films_id.4e52f2f208", "test.nerd_facts_dbt.not_null_stg_swapi_films_release_date.6599c8fb74", "test.nerd_facts_dbt.not_null_stg_swapi_films_title.4f45458548", "test.nerd_facts_dbt.unique_stg_swapi_films_id.14c2b7f5e2"], "test.nerd_facts_dbt.unique_stg_swapi_films_id.14c2b7f5e2": [], "test.nerd_facts_dbt.not_null_stg_swapi_films_id.4e52f2f208": [], "test.nerd_facts_dbt.not_null_stg_swapi_films_title.4f45458548": [], "test.nerd_facts_dbt.not_null_stg_swapi_films_episode_id.bc98d1b696": [], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_films_episode_id__9__1.a5d4199e05": [], "test.nerd_facts_dbt.not_null_stg_swapi_films_release_date.6599c8fb74": [], "model.nerd_facts_dbt.stg_swapi_planets": ["model.nerd_facts_dbt.dim_locations", "model.nerd_facts_dbt.dim_sw_planets", "model.nerd_facts_dbt.fct_sw_characters", "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0.a9aca03c03", "test.nerd_facts_dbt.not_null_stg_swapi_planets_id.1980954ad2", "test.nerd_facts_dbt.not_null_stg_swapi_planets_name.290277cf78", "test.nerd_facts_dbt.unique_stg_swapi_planets_id.6c040cab42"], "test.nerd_facts_dbt.unique_stg_swapi_planets_id.6c040cab42": [], "test.nerd_facts_dbt.not_null_stg_swapi_planets_id.1980954ad2": [], "test.nerd_facts_dbt.not_null_stg_swapi_planets_name.290277cf78": [], "test.nerd_facts_dbt.dbt_utils_accepted_range_stg_swapi_planets_surface_water__100__0.a9aca03c03": [], "source.nerd_facts_dbt.raw.swapi_people": [], "source.nerd_facts_dbt.raw.swapi_planets": [], "source.nerd_facts_dbt.raw.swapi_starships": [], "source.nerd_facts_dbt.raw.swapi_vehicles": [], "source.nerd_facts_dbt.raw.swapi_species": [], "source.nerd_facts_dbt.raw.swapi_films": [], "source.nerd_facts_dbt.raw.pokeapi_pokemon": [], "source.nerd_facts_dbt.raw.pokeapi_types": [], "source.nerd_facts_dbt.raw.pokeapi_abilities": [], "source.nerd_facts_dbt.raw.pokeapi_moves": [], "source.nerd_facts_dbt.raw.pokeapi_items": [], "source.nerd_facts_dbt.pokeapi.moves": ["model.nerd_facts_dbt.stg_pokeapi_moves", "test.nerd_facts_dbt.source_not_null_pokeapi_moves_id.c4a229cda9", "test.nerd_facts_dbt.source_not_null_pokeapi_moves_name.5721c278f3", "test.nerd_facts_dbt.source_unique_pokeapi_moves_id.d93d417c11"], "source.nerd_facts_dbt.swapi.starships": ["test.nerd_facts_dbt.source_not_null_swapi_starships_id.20f60e38ef", "test.nerd_facts_dbt.source_unique_swapi_starships_id.4a35a82bda"], "source.nerd_facts_dbt.swapi.films": ["model.nerd_facts_dbt.stg_swapi_films"], "source.nerd_facts_dbt.swapi.people": ["model.nerd_facts_dbt.stg_swapi_people"], "source.nerd_facts_dbt.swapi.planets": ["model.nerd_facts_dbt.stg_swapi_planets"], "source.nerd_facts_dbt.swapi.species": ["model.nerd_facts_dbt.stg_swapi_species"], "source.nerd_facts_dbt.swapi.vehicles": ["model.nerd_facts_dbt.stg_swapi_vehicles"]}, "group_map": {}, "saved_queries": {}, "semantic_models": {}, "unit_tests": {}}